// Generated by Molecule 0.7.5
// Generated by Moleculec-Go 0.1.11

package config_history
import (
    "bytes"
    "encoding/binary"
    "errors"
    "strconv"
    "strings"
       )

type ConfigCellMainV1Builder struct {
    status Uint8
type_id_table TypeIdTableV1
das_lock_out_point_table DasLockOutPointTableV1
}
        

func (s *ConfigCellMainV1Builder) Build() ConfigCellMainV1 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (3 + 1)
    offsets := make([]uint32, 0, 3)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.status.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.type_id_table.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.das_lock_out_point_table.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.status.AsSlice())
b.Write(s.type_id_table.AsSlice())
b.Write(s.das_lock_out_point_table.AsSlice())
    return ConfigCellMainV1{inner: b.Bytes()}
}
                

func (s *ConfigCellMainV1Builder) Status(v Uint8) *ConfigCellMainV1Builder {
    s.status = v
    return s
}
            

func (s *ConfigCellMainV1Builder) TypeIdTable(v TypeIdTableV1) *ConfigCellMainV1Builder {
    s.type_id_table = v
    return s
}
            

func (s *ConfigCellMainV1Builder) DasLockOutPointTable(v DasLockOutPointTableV1) *ConfigCellMainV1Builder {
    s.das_lock_out_point_table = v
    return s
}
            

func NewConfigCellMainV1Builder() *ConfigCellMainV1Builder {
	return &ConfigCellMainV1Builder{ status: Uint8Default(),type_id_table: TypeIdTableV1Default(),das_lock_out_point_table: DasLockOutPointTableV1Default() }
}
    

type ConfigCellMainV1 struct {
    inner []byte
}
        

func ConfigCellMainV1FromSliceUnchecked(slice []byte) *ConfigCellMainV1 {
    return &ConfigCellMainV1{inner: slice}
}
func (s *ConfigCellMainV1) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellMainV1Default() ConfigCellMainV1 {
    return *ConfigCellMainV1FromSliceUnchecked([]byte{ 221,1,0,0,16,0,0,0,17,0,0,0,17,1,0,0,0,0,1,0,0,32,0,0,0,64,0,0,0,96,0,0,0,128,0,0,0,160,0,0,0,192,0,0,0,224,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,204,0,0,0,24,0,0,0,60,0,0,0,96,0,0,0,132,0,0,0,168,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellMainV1FromSlice(slice []byte, compatible bool) (*ConfigCellMainV1, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV1", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellMainV1", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 3 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 3 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = TypeIdTableV1FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = DasLockOutPointTableV1FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellMainV1{inner: slice}, nil
}
            

func (s *ConfigCellMainV1) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellMainV1) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellMainV1) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellMainV1) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellMainV1) CountExtraFields() uint {
    return s.FieldCount() - 3
}

func (s *ConfigCellMainV1) HasExtraFields() bool {
    return 3 != s.FieldCount()
}
            

func (s *ConfigCellMainV1) Status() *Uint8 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellMainV1) TypeIdTable() *TypeIdTableV1 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return TypeIdTableV1FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellMainV1) DasLockOutPointTable() *DasLockOutPointTableV1 {
    var ret *DasLockOutPointTableV1
    start := unpackNumber(s.inner[12:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[16:])
        ret = DasLockOutPointTableV1FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = DasLockOutPointTableV1FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellMainV1) AsBuilder() ConfigCellMainV1Builder {
    ret := NewConfigCellMainV1Builder().Status(*s.Status()).TypeIdTable(*s.TypeIdTable()).DasLockOutPointTable(*s.DasLockOutPointTable())
    return *ret
}
        

type TypeIdTableV1Builder struct {
    account_cell Hash
apply_register_cell Hash
bidding_cell Hash
income_cell Hash
on_sale_cell Hash
pre_account_cell Hash
proposal_cell Hash
}
        

func (s *TypeIdTableV1Builder) Build() TypeIdTableV1 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (7 + 1)
    offsets := make([]uint32, 0, 7)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.apply_register_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.bidding_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.income_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.on_sale_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.pre_account_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_cell.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.account_cell.AsSlice())
b.Write(s.apply_register_cell.AsSlice())
b.Write(s.bidding_cell.AsSlice())
b.Write(s.income_cell.AsSlice())
b.Write(s.on_sale_cell.AsSlice())
b.Write(s.pre_account_cell.AsSlice())
b.Write(s.proposal_cell.AsSlice())
    return TypeIdTableV1{inner: b.Bytes()}
}
                

func (s *TypeIdTableV1Builder) AccountCell(v Hash) *TypeIdTableV1Builder {
    s.account_cell = v
    return s
}
            

func (s *TypeIdTableV1Builder) ApplyRegisterCell(v Hash) *TypeIdTableV1Builder {
    s.apply_register_cell = v
    return s
}
            

func (s *TypeIdTableV1Builder) BiddingCell(v Hash) *TypeIdTableV1Builder {
    s.bidding_cell = v
    return s
}
            

func (s *TypeIdTableV1Builder) IncomeCell(v Hash) *TypeIdTableV1Builder {
    s.income_cell = v
    return s
}
            

func (s *TypeIdTableV1Builder) OnSaleCell(v Hash) *TypeIdTableV1Builder {
    s.on_sale_cell = v
    return s
}
            

func (s *TypeIdTableV1Builder) PreAccountCell(v Hash) *TypeIdTableV1Builder {
    s.pre_account_cell = v
    return s
}
            

func (s *TypeIdTableV1Builder) ProposalCell(v Hash) *TypeIdTableV1Builder {
    s.proposal_cell = v
    return s
}
            

func NewTypeIdTableV1Builder() *TypeIdTableV1Builder {
	return &TypeIdTableV1Builder{ account_cell: HashDefault(),apply_register_cell: HashDefault(),bidding_cell: HashDefault(),income_cell: HashDefault(),on_sale_cell: HashDefault(),pre_account_cell: HashDefault(),proposal_cell: HashDefault() }
}
    

type TypeIdTableV1 struct {
    inner []byte
}
        

func TypeIdTableV1FromSliceUnchecked(slice []byte) *TypeIdTableV1 {
    return &TypeIdTableV1{inner: slice}
}
func (s *TypeIdTableV1) AsSlice() []byte {
    return s.inner
}
            

func TypeIdTableV1Default() TypeIdTableV1 {
    return *TypeIdTableV1FromSliceUnchecked([]byte{ 0,1,0,0,32,0,0,0,64,0,0,0,96,0,0,0,128,0,0,0,160,0,0,0,192,0,0,0,224,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func TypeIdTableV1FromSlice(slice []byte, compatible bool) (*TypeIdTableV1, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV1", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "TypeIdTableV1", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 7 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 7 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = HashFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

    return &TypeIdTableV1{inner: slice}, nil
}
            

func (s *TypeIdTableV1) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *TypeIdTableV1) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *TypeIdTableV1) Len() uint {
    return s.FieldCount()
}
func (s *TypeIdTableV1) IsEmpty() bool {
    return s.Len() == 0
}
func (s *TypeIdTableV1) CountExtraFields() uint {
    return s.FieldCount() - 7
}

func (s *TypeIdTableV1) HasExtraFields() bool {
    return 7 != s.FieldCount()
}
            

func (s *TypeIdTableV1) AccountCell() *Hash {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV1) ApplyRegisterCell() *Hash {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV1) BiddingCell() *Hash {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV1) IncomeCell() *Hash {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV1) OnSaleCell() *Hash {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV1) PreAccountCell() *Hash {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV1) ProposalCell() *Hash {
    var ret *Hash
    start := unpackNumber(s.inner[28:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[32:])
        ret = HashFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = HashFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *TypeIdTableV1) AsBuilder() TypeIdTableV1Builder {
    ret := NewTypeIdTableV1Builder().AccountCell(*s.AccountCell()).ApplyRegisterCell(*s.ApplyRegisterCell()).BiddingCell(*s.BiddingCell()).IncomeCell(*s.IncomeCell()).OnSaleCell(*s.OnSaleCell()).PreAccountCell(*s.PreAccountCell()).ProposalCell(*s.ProposalCell())
    return *ret
}
        

type DasLockOutPointTableV1Builder struct {
    ckb_signall OutPoint
ckb_multisign OutPoint
ckb_anyone_can_pay OutPoint
eth OutPoint
tron OutPoint
}
        

func (s *DasLockOutPointTableV1Builder) Build() DasLockOutPointTableV1 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (5 + 1)
    offsets := make([]uint32, 0, 5)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.ckb_signall.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.ckb_multisign.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.ckb_anyone_can_pay.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.eth.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.tron.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.ckb_signall.AsSlice())
b.Write(s.ckb_multisign.AsSlice())
b.Write(s.ckb_anyone_can_pay.AsSlice())
b.Write(s.eth.AsSlice())
b.Write(s.tron.AsSlice())
    return DasLockOutPointTableV1{inner: b.Bytes()}
}
                

func (s *DasLockOutPointTableV1Builder) CkbSignall(v OutPoint) *DasLockOutPointTableV1Builder {
    s.ckb_signall = v
    return s
}
            

func (s *DasLockOutPointTableV1Builder) CkbMultisign(v OutPoint) *DasLockOutPointTableV1Builder {
    s.ckb_multisign = v
    return s
}
            

func (s *DasLockOutPointTableV1Builder) CkbAnyoneCanPay(v OutPoint) *DasLockOutPointTableV1Builder {
    s.ckb_anyone_can_pay = v
    return s
}
            

func (s *DasLockOutPointTableV1Builder) Eth(v OutPoint) *DasLockOutPointTableV1Builder {
    s.eth = v
    return s
}
            

func (s *DasLockOutPointTableV1Builder) Tron(v OutPoint) *DasLockOutPointTableV1Builder {
    s.tron = v
    return s
}
            

func NewDasLockOutPointTableV1Builder() *DasLockOutPointTableV1Builder {
	return &DasLockOutPointTableV1Builder{ ckb_signall: OutPointDefault(),ckb_multisign: OutPointDefault(),ckb_anyone_can_pay: OutPointDefault(),eth: OutPointDefault(),tron: OutPointDefault() }
}
    

type DasLockOutPointTableV1 struct {
    inner []byte
}
        

func DasLockOutPointTableV1FromSliceUnchecked(slice []byte) *DasLockOutPointTableV1 {
    return &DasLockOutPointTableV1{inner: slice}
}
func (s *DasLockOutPointTableV1) AsSlice() []byte {
    return s.inner
}
            

func DasLockOutPointTableV1Default() DasLockOutPointTableV1 {
    return *DasLockOutPointTableV1FromSliceUnchecked([]byte{ 204,0,0,0,24,0,0,0,60,0,0,0,96,0,0,0,132,0,0,0,168,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func DasLockOutPointTableV1FromSlice(slice []byte, compatible bool) (*DasLockOutPointTableV1, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "DasLockOutPointTableV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "DasLockOutPointTableV1", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "DasLockOutPointTableV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "DasLockOutPointTableV1", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "DasLockOutPointTableV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 5 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 5 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = OutPointFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = OutPointFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = OutPointFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = OutPointFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = OutPointFromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

    return &DasLockOutPointTableV1{inner: slice}, nil
}
            

func (s *DasLockOutPointTableV1) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *DasLockOutPointTableV1) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *DasLockOutPointTableV1) Len() uint {
    return s.FieldCount()
}
func (s *DasLockOutPointTableV1) IsEmpty() bool {
    return s.Len() == 0
}
func (s *DasLockOutPointTableV1) CountExtraFields() uint {
    return s.FieldCount() - 5
}

func (s *DasLockOutPointTableV1) HasExtraFields() bool {
    return 5 != s.FieldCount()
}
            

func (s *DasLockOutPointTableV1) CkbSignall() *OutPoint {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return OutPointFromSliceUnchecked(s.inner[start:end])
}
               

func (s *DasLockOutPointTableV1) CkbMultisign() *OutPoint {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return OutPointFromSliceUnchecked(s.inner[start:end])
}
               

func (s *DasLockOutPointTableV1) CkbAnyoneCanPay() *OutPoint {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return OutPointFromSliceUnchecked(s.inner[start:end])
}
               

func (s *DasLockOutPointTableV1) Eth() *OutPoint {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return OutPointFromSliceUnchecked(s.inner[start:end])
}
               

func (s *DasLockOutPointTableV1) Tron() *OutPoint {
    var ret *OutPoint
    start := unpackNumber(s.inner[20:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[24:])
        ret = OutPointFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = OutPointFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *DasLockOutPointTableV1) AsBuilder() DasLockOutPointTableV1Builder {
    ret := NewDasLockOutPointTableV1Builder().CkbSignall(*s.CkbSignall()).CkbMultisign(*s.CkbMultisign()).CkbAnyoneCanPay(*s.CkbAnyoneCanPay()).Eth(*s.Eth()).Tron(*s.Tron())
    return *ret
}
        

type ConfigCellMainV2Builder struct {
    status Uint8
type_id_table TypeIdTableV2
das_lock_out_point_table DasLockOutPointTableV1
}
        

func (s *ConfigCellMainV2Builder) Build() ConfigCellMainV2 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (3 + 1)
    offsets := make([]uint32, 0, 3)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.status.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.type_id_table.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.das_lock_out_point_table.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.status.AsSlice())
b.Write(s.type_id_table.AsSlice())
b.Write(s.das_lock_out_point_table.AsSlice())
    return ConfigCellMainV2{inner: b.Bytes()}
}
                

func (s *ConfigCellMainV2Builder) Status(v Uint8) *ConfigCellMainV2Builder {
    s.status = v
    return s
}
            

func (s *ConfigCellMainV2Builder) TypeIdTable(v TypeIdTableV2) *ConfigCellMainV2Builder {
    s.type_id_table = v
    return s
}
            

func (s *ConfigCellMainV2Builder) DasLockOutPointTable(v DasLockOutPointTableV1) *ConfigCellMainV2Builder {
    s.das_lock_out_point_table = v
    return s
}
            

func NewConfigCellMainV2Builder() *ConfigCellMainV2Builder {
	return &ConfigCellMainV2Builder{ status: Uint8Default(),type_id_table: TypeIdTableV2Default(),das_lock_out_point_table: DasLockOutPointTableV1Default() }
}
    

type ConfigCellMainV2 struct {
    inner []byte
}
        

func ConfigCellMainV2FromSliceUnchecked(slice []byte) *ConfigCellMainV2 {
    return &ConfigCellMainV2{inner: slice}
}
func (s *ConfigCellMainV2) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellMainV2Default() ConfigCellMainV2 {
    return *ConfigCellMainV2FromSliceUnchecked([]byte{ 185,1,0,0,16,0,0,0,17,0,0,0,237,0,0,0,0,220,0,0,0,28,0,0,0,60,0,0,0,92,0,0,0,124,0,0,0,156,0,0,0,188,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,204,0,0,0,24,0,0,0,60,0,0,0,96,0,0,0,132,0,0,0,168,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellMainV2FromSlice(slice []byte, compatible bool) (*ConfigCellMainV2, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV2", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellMainV2", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 3 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 3 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = TypeIdTableV2FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = DasLockOutPointTableV1FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellMainV2{inner: slice}, nil
}
            

func (s *ConfigCellMainV2) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellMainV2) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellMainV2) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellMainV2) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellMainV2) CountExtraFields() uint {
    return s.FieldCount() - 3
}

func (s *ConfigCellMainV2) HasExtraFields() bool {
    return 3 != s.FieldCount()
}
            

func (s *ConfigCellMainV2) Status() *Uint8 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellMainV2) TypeIdTable() *TypeIdTableV2 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return TypeIdTableV2FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellMainV2) DasLockOutPointTable() *DasLockOutPointTableV1 {
    var ret *DasLockOutPointTableV1
    start := unpackNumber(s.inner[12:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[16:])
        ret = DasLockOutPointTableV1FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = DasLockOutPointTableV1FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellMainV2) AsBuilder() ConfigCellMainV2Builder {
    ret := NewConfigCellMainV2Builder().Status(*s.Status()).TypeIdTable(*s.TypeIdTable()).DasLockOutPointTable(*s.DasLockOutPointTable())
    return *ret
}
        

type TypeIdTableV2Builder struct {
    account_cell Hash
apply_register_cell Hash
balance_cell Hash
income_cell Hash
pre_account_cell Hash
proposal_cell Hash
}
        

func (s *TypeIdTableV2Builder) Build() TypeIdTableV2 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (6 + 1)
    offsets := make([]uint32, 0, 6)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.apply_register_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.balance_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.income_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.pre_account_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_cell.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.account_cell.AsSlice())
b.Write(s.apply_register_cell.AsSlice())
b.Write(s.balance_cell.AsSlice())
b.Write(s.income_cell.AsSlice())
b.Write(s.pre_account_cell.AsSlice())
b.Write(s.proposal_cell.AsSlice())
    return TypeIdTableV2{inner: b.Bytes()}
}
                

func (s *TypeIdTableV2Builder) AccountCell(v Hash) *TypeIdTableV2Builder {
    s.account_cell = v
    return s
}
            

func (s *TypeIdTableV2Builder) ApplyRegisterCell(v Hash) *TypeIdTableV2Builder {
    s.apply_register_cell = v
    return s
}
            

func (s *TypeIdTableV2Builder) BalanceCell(v Hash) *TypeIdTableV2Builder {
    s.balance_cell = v
    return s
}
            

func (s *TypeIdTableV2Builder) IncomeCell(v Hash) *TypeIdTableV2Builder {
    s.income_cell = v
    return s
}
            

func (s *TypeIdTableV2Builder) PreAccountCell(v Hash) *TypeIdTableV2Builder {
    s.pre_account_cell = v
    return s
}
            

func (s *TypeIdTableV2Builder) ProposalCell(v Hash) *TypeIdTableV2Builder {
    s.proposal_cell = v
    return s
}
            

func NewTypeIdTableV2Builder() *TypeIdTableV2Builder {
	return &TypeIdTableV2Builder{ account_cell: HashDefault(),apply_register_cell: HashDefault(),balance_cell: HashDefault(),income_cell: HashDefault(),pre_account_cell: HashDefault(),proposal_cell: HashDefault() }
}
    

type TypeIdTableV2 struct {
    inner []byte
}
        

func TypeIdTableV2FromSliceUnchecked(slice []byte) *TypeIdTableV2 {
    return &TypeIdTableV2{inner: slice}
}
func (s *TypeIdTableV2) AsSlice() []byte {
    return s.inner
}
            

func TypeIdTableV2Default() TypeIdTableV2 {
    return *TypeIdTableV2FromSliceUnchecked([]byte{ 220,0,0,0,28,0,0,0,60,0,0,0,92,0,0,0,124,0,0,0,156,0,0,0,188,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func TypeIdTableV2FromSlice(slice []byte, compatible bool) (*TypeIdTableV2, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV2", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "TypeIdTableV2", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 6 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 6 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = HashFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

    return &TypeIdTableV2{inner: slice}, nil
}
            

func (s *TypeIdTableV2) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *TypeIdTableV2) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *TypeIdTableV2) Len() uint {
    return s.FieldCount()
}
func (s *TypeIdTableV2) IsEmpty() bool {
    return s.Len() == 0
}
func (s *TypeIdTableV2) CountExtraFields() uint {
    return s.FieldCount() - 6
}

func (s *TypeIdTableV2) HasExtraFields() bool {
    return 6 != s.FieldCount()
}
            

func (s *TypeIdTableV2) AccountCell() *Hash {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV2) ApplyRegisterCell() *Hash {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV2) BalanceCell() *Hash {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV2) IncomeCell() *Hash {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV2) PreAccountCell() *Hash {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV2) ProposalCell() *Hash {
    var ret *Hash
    start := unpackNumber(s.inner[24:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[28:])
        ret = HashFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = HashFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *TypeIdTableV2) AsBuilder() TypeIdTableV2Builder {
    ret := NewTypeIdTableV2Builder().AccountCell(*s.AccountCell()).ApplyRegisterCell(*s.ApplyRegisterCell()).BalanceCell(*s.BalanceCell()).IncomeCell(*s.IncomeCell()).PreAccountCell(*s.PreAccountCell()).ProposalCell(*s.ProposalCell())
    return *ret
}
        

type ConfigCellMainV3Builder struct {
    status Uint8
type_id_table TypeIdTableV3
das_lock_out_point_table DasLockOutPointTableV1
}
        

func (s *ConfigCellMainV3Builder) Build() ConfigCellMainV3 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (3 + 1)
    offsets := make([]uint32, 0, 3)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.status.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.type_id_table.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.das_lock_out_point_table.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.status.AsSlice())
b.Write(s.type_id_table.AsSlice())
b.Write(s.das_lock_out_point_table.AsSlice())
    return ConfigCellMainV3{inner: b.Bytes()}
}
                

func (s *ConfigCellMainV3Builder) Status(v Uint8) *ConfigCellMainV3Builder {
    s.status = v
    return s
}
            

func (s *ConfigCellMainV3Builder) TypeIdTable(v TypeIdTableV3) *ConfigCellMainV3Builder {
    s.type_id_table = v
    return s
}
            

func (s *ConfigCellMainV3Builder) DasLockOutPointTable(v DasLockOutPointTableV1) *ConfigCellMainV3Builder {
    s.das_lock_out_point_table = v
    return s
}
            

func NewConfigCellMainV3Builder() *ConfigCellMainV3Builder {
	return &ConfigCellMainV3Builder{ status: Uint8Default(),type_id_table: TypeIdTableV3Default(),das_lock_out_point_table: DasLockOutPointTableV1Default() }
}
    

type ConfigCellMainV3 struct {
    inner []byte
}
        

func ConfigCellMainV3FromSliceUnchecked(slice []byte) *ConfigCellMainV3 {
    return &ConfigCellMainV3{inner: slice}
}
func (s *ConfigCellMainV3) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellMainV3Default() ConfigCellMainV3 {
    return *ConfigCellMainV3FromSliceUnchecked([]byte{ 1,2,0,0,16,0,0,0,17,0,0,0,53,1,0,0,0,36,1,0,0,36,0,0,0,68,0,0,0,100,0,0,0,132,0,0,0,164,0,0,0,196,0,0,0,228,0,0,0,4,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,204,0,0,0,24,0,0,0,60,0,0,0,96,0,0,0,132,0,0,0,168,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellMainV3FromSlice(slice []byte, compatible bool) (*ConfigCellMainV3, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV3", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV3", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV3", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellMainV3", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV3", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 3 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 3 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = TypeIdTableV3FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = DasLockOutPointTableV1FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellMainV3{inner: slice}, nil
}
            

func (s *ConfigCellMainV3) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellMainV3) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellMainV3) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellMainV3) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellMainV3) CountExtraFields() uint {
    return s.FieldCount() - 3
}

func (s *ConfigCellMainV3) HasExtraFields() bool {
    return 3 != s.FieldCount()
}
            

func (s *ConfigCellMainV3) Status() *Uint8 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellMainV3) TypeIdTable() *TypeIdTableV3 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return TypeIdTableV3FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellMainV3) DasLockOutPointTable() *DasLockOutPointTableV1 {
    var ret *DasLockOutPointTableV1
    start := unpackNumber(s.inner[12:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[16:])
        ret = DasLockOutPointTableV1FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = DasLockOutPointTableV1FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellMainV3) AsBuilder() ConfigCellMainV3Builder {
    ret := NewConfigCellMainV3Builder().Status(*s.Status()).TypeIdTable(*s.TypeIdTable()).DasLockOutPointTable(*s.DasLockOutPointTable())
    return *ret
}
        

type TypeIdTableV3Builder struct {
    account_cell Hash
apply_register_cell Hash
balance_cell Hash
income_cell Hash
pre_account_cell Hash
proposal_cell Hash
account_sale_cell Hash
account_auction_cell Hash
}
        

func (s *TypeIdTableV3Builder) Build() TypeIdTableV3 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (8 + 1)
    offsets := make([]uint32, 0, 8)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.apply_register_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.balance_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.income_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.pre_account_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_sale_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_auction_cell.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.account_cell.AsSlice())
b.Write(s.apply_register_cell.AsSlice())
b.Write(s.balance_cell.AsSlice())
b.Write(s.income_cell.AsSlice())
b.Write(s.pre_account_cell.AsSlice())
b.Write(s.proposal_cell.AsSlice())
b.Write(s.account_sale_cell.AsSlice())
b.Write(s.account_auction_cell.AsSlice())
    return TypeIdTableV3{inner: b.Bytes()}
}
                

func (s *TypeIdTableV3Builder) AccountCell(v Hash) *TypeIdTableV3Builder {
    s.account_cell = v
    return s
}
            

func (s *TypeIdTableV3Builder) ApplyRegisterCell(v Hash) *TypeIdTableV3Builder {
    s.apply_register_cell = v
    return s
}
            

func (s *TypeIdTableV3Builder) BalanceCell(v Hash) *TypeIdTableV3Builder {
    s.balance_cell = v
    return s
}
            

func (s *TypeIdTableV3Builder) IncomeCell(v Hash) *TypeIdTableV3Builder {
    s.income_cell = v
    return s
}
            

func (s *TypeIdTableV3Builder) PreAccountCell(v Hash) *TypeIdTableV3Builder {
    s.pre_account_cell = v
    return s
}
            

func (s *TypeIdTableV3Builder) ProposalCell(v Hash) *TypeIdTableV3Builder {
    s.proposal_cell = v
    return s
}
            

func (s *TypeIdTableV3Builder) AccountSaleCell(v Hash) *TypeIdTableV3Builder {
    s.account_sale_cell = v
    return s
}
            

func (s *TypeIdTableV3Builder) AccountAuctionCell(v Hash) *TypeIdTableV3Builder {
    s.account_auction_cell = v
    return s
}
            

func NewTypeIdTableV3Builder() *TypeIdTableV3Builder {
	return &TypeIdTableV3Builder{ account_cell: HashDefault(),apply_register_cell: HashDefault(),balance_cell: HashDefault(),income_cell: HashDefault(),pre_account_cell: HashDefault(),proposal_cell: HashDefault(),account_sale_cell: HashDefault(),account_auction_cell: HashDefault() }
}
    

type TypeIdTableV3 struct {
    inner []byte
}
        

func TypeIdTableV3FromSliceUnchecked(slice []byte) *TypeIdTableV3 {
    return &TypeIdTableV3{inner: slice}
}
func (s *TypeIdTableV3) AsSlice() []byte {
    return s.inner
}
            

func TypeIdTableV3Default() TypeIdTableV3 {
    return *TypeIdTableV3FromSliceUnchecked([]byte{ 36,1,0,0,36,0,0,0,68,0,0,0,100,0,0,0,132,0,0,0,164,0,0,0,196,0,0,0,228,0,0,0,4,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func TypeIdTableV3FromSlice(slice []byte, compatible bool) (*TypeIdTableV3, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV3", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV3", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV3", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "TypeIdTableV3", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV3", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 8 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 8 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = HashFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

    return &TypeIdTableV3{inner: slice}, nil
}
            

func (s *TypeIdTableV3) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *TypeIdTableV3) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *TypeIdTableV3) Len() uint {
    return s.FieldCount()
}
func (s *TypeIdTableV3) IsEmpty() bool {
    return s.Len() == 0
}
func (s *TypeIdTableV3) CountExtraFields() uint {
    return s.FieldCount() - 8
}

func (s *TypeIdTableV3) HasExtraFields() bool {
    return 8 != s.FieldCount()
}
            

func (s *TypeIdTableV3) AccountCell() *Hash {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV3) ApplyRegisterCell() *Hash {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV3) BalanceCell() *Hash {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV3) IncomeCell() *Hash {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV3) PreAccountCell() *Hash {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV3) ProposalCell() *Hash {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV3) AccountSaleCell() *Hash {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV3) AccountAuctionCell() *Hash {
    var ret *Hash
    start := unpackNumber(s.inner[32:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[36:])
        ret = HashFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = HashFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *TypeIdTableV3) AsBuilder() TypeIdTableV3Builder {
    ret := NewTypeIdTableV3Builder().AccountCell(*s.AccountCell()).ApplyRegisterCell(*s.ApplyRegisterCell()).BalanceCell(*s.BalanceCell()).IncomeCell(*s.IncomeCell()).PreAccountCell(*s.PreAccountCell()).ProposalCell(*s.ProposalCell()).AccountSaleCell(*s.AccountSaleCell()).AccountAuctionCell(*s.AccountAuctionCell())
    return *ret
}
        

type ConfigCellMainV4Builder struct {
    status Uint8
type_id_table TypeIdTableV4
das_lock_out_point_table DasLockOutPointTableV1
}
        

func (s *ConfigCellMainV4Builder) Build() ConfigCellMainV4 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (3 + 1)
    offsets := make([]uint32, 0, 3)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.status.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.type_id_table.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.das_lock_out_point_table.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.status.AsSlice())
b.Write(s.type_id_table.AsSlice())
b.Write(s.das_lock_out_point_table.AsSlice())
    return ConfigCellMainV4{inner: b.Bytes()}
}
                

func (s *ConfigCellMainV4Builder) Status(v Uint8) *ConfigCellMainV4Builder {
    s.status = v
    return s
}
            

func (s *ConfigCellMainV4Builder) TypeIdTable(v TypeIdTableV4) *ConfigCellMainV4Builder {
    s.type_id_table = v
    return s
}
            

func (s *ConfigCellMainV4Builder) DasLockOutPointTable(v DasLockOutPointTableV1) *ConfigCellMainV4Builder {
    s.das_lock_out_point_table = v
    return s
}
            

func NewConfigCellMainV4Builder() *ConfigCellMainV4Builder {
	return &ConfigCellMainV4Builder{ status: Uint8Default(),type_id_table: TypeIdTableV4Default(),das_lock_out_point_table: DasLockOutPointTableV1Default() }
}
    

type ConfigCellMainV4 struct {
    inner []byte
}
        

func ConfigCellMainV4FromSliceUnchecked(slice []byte) *ConfigCellMainV4 {
    return &ConfigCellMainV4{inner: slice}
}
func (s *ConfigCellMainV4) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellMainV4Default() ConfigCellMainV4 {
    return *ConfigCellMainV4FromSliceUnchecked([]byte{ 73,2,0,0,16,0,0,0,17,0,0,0,125,1,0,0,0,108,1,0,0,44,0,0,0,76,0,0,0,108,0,0,0,140,0,0,0,172,0,0,0,204,0,0,0,236,0,0,0,12,1,0,0,44,1,0,0,76,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,204,0,0,0,24,0,0,0,60,0,0,0,96,0,0,0,132,0,0,0,168,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellMainV4FromSlice(slice []byte, compatible bool) (*ConfigCellMainV4, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV4", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV4", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV4", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellMainV4", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV4", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 3 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 3 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = TypeIdTableV4FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = DasLockOutPointTableV1FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellMainV4{inner: slice}, nil
}
            

func (s *ConfigCellMainV4) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellMainV4) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellMainV4) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellMainV4) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellMainV4) CountExtraFields() uint {
    return s.FieldCount() - 3
}

func (s *ConfigCellMainV4) HasExtraFields() bool {
    return 3 != s.FieldCount()
}
            

func (s *ConfigCellMainV4) Status() *Uint8 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellMainV4) TypeIdTable() *TypeIdTableV4 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return TypeIdTableV4FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellMainV4) DasLockOutPointTable() *DasLockOutPointTableV1 {
    var ret *DasLockOutPointTableV1
    start := unpackNumber(s.inner[12:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[16:])
        ret = DasLockOutPointTableV1FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = DasLockOutPointTableV1FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellMainV4) AsBuilder() ConfigCellMainV4Builder {
    ret := NewConfigCellMainV4Builder().Status(*s.Status()).TypeIdTable(*s.TypeIdTable()).DasLockOutPointTable(*s.DasLockOutPointTable())
    return *ret
}
        

type ConfigCellMainV5Builder struct {
    status Uint8
type_id_table TypeIdTableV4
das_lock_out_point_table DasLockOutPointTable
}
        

func (s *ConfigCellMainV5Builder) Build() ConfigCellMainV5 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (3 + 1)
    offsets := make([]uint32, 0, 3)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.status.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.type_id_table.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.das_lock_out_point_table.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.status.AsSlice())
b.Write(s.type_id_table.AsSlice())
b.Write(s.das_lock_out_point_table.AsSlice())
    return ConfigCellMainV5{inner: b.Bytes()}
}
                

func (s *ConfigCellMainV5Builder) Status(v Uint8) *ConfigCellMainV5Builder {
    s.status = v
    return s
}
            

func (s *ConfigCellMainV5Builder) TypeIdTable(v TypeIdTableV4) *ConfigCellMainV5Builder {
    s.type_id_table = v
    return s
}
            

func (s *ConfigCellMainV5Builder) DasLockOutPointTable(v DasLockOutPointTable) *ConfigCellMainV5Builder {
    s.das_lock_out_point_table = v
    return s
}
            

func NewConfigCellMainV5Builder() *ConfigCellMainV5Builder {
	return &ConfigCellMainV5Builder{ status: Uint8Default(),type_id_table: TypeIdTableV4Default(),das_lock_out_point_table: DasLockOutPointTableDefault() }
}
    

type ConfigCellMainV5 struct {
    inner []byte
}
        

func ConfigCellMainV5FromSliceUnchecked(slice []byte) *ConfigCellMainV5 {
    return &ConfigCellMainV5{inner: slice}
}
func (s *ConfigCellMainV5) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellMainV5Default() ConfigCellMainV5 {
    return *ConfigCellMainV5FromSliceUnchecked([]byte{ 153,2,0,0,16,0,0,0,17,0,0,0,125,1,0,0,0,108,1,0,0,44,0,0,0,76,0,0,0,108,0,0,0,140,0,0,0,172,0,0,0,204,0,0,0,236,0,0,0,12,1,0,0,44,1,0,0,76,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,1,0,0,32,0,0,0,68,0,0,0,104,0,0,0,140,0,0,0,176,0,0,0,212,0,0,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellMainV5FromSlice(slice []byte, compatible bool) (*ConfigCellMainV5, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV5", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV5", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV5", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellMainV5", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV5", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 3 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 3 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = TypeIdTableV4FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = DasLockOutPointTableFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellMainV5{inner: slice}, nil
}
            

func (s *ConfigCellMainV5) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellMainV5) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellMainV5) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellMainV5) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellMainV5) CountExtraFields() uint {
    return s.FieldCount() - 3
}

func (s *ConfigCellMainV5) HasExtraFields() bool {
    return 3 != s.FieldCount()
}
            

func (s *ConfigCellMainV5) Status() *Uint8 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellMainV5) TypeIdTable() *TypeIdTableV4 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return TypeIdTableV4FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellMainV5) DasLockOutPointTable() *DasLockOutPointTable {
    var ret *DasLockOutPointTable
    start := unpackNumber(s.inner[12:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[16:])
        ret = DasLockOutPointTableFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = DasLockOutPointTableFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellMainV5) AsBuilder() ConfigCellMainV5Builder {
    ret := NewConfigCellMainV5Builder().Status(*s.Status()).TypeIdTable(*s.TypeIdTable()).DasLockOutPointTable(*s.DasLockOutPointTable())
    return *ret
}
        

type TypeIdTableV4Builder struct {
    account_cell Hash
apply_register_cell Hash
balance_cell Hash
income_cell Hash
pre_account_cell Hash
proposal_cell Hash
account_sale_cell Hash
account_auction_cell Hash
offer_cell Hash
reverse_record_cell Hash
}
        

func (s *TypeIdTableV4Builder) Build() TypeIdTableV4 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (10 + 1)
    offsets := make([]uint32, 0, 10)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.apply_register_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.balance_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.income_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.pre_account_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_sale_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_auction_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.offer_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.reverse_record_cell.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.account_cell.AsSlice())
b.Write(s.apply_register_cell.AsSlice())
b.Write(s.balance_cell.AsSlice())
b.Write(s.income_cell.AsSlice())
b.Write(s.pre_account_cell.AsSlice())
b.Write(s.proposal_cell.AsSlice())
b.Write(s.account_sale_cell.AsSlice())
b.Write(s.account_auction_cell.AsSlice())
b.Write(s.offer_cell.AsSlice())
b.Write(s.reverse_record_cell.AsSlice())
    return TypeIdTableV4{inner: b.Bytes()}
}
                

func (s *TypeIdTableV4Builder) AccountCell(v Hash) *TypeIdTableV4Builder {
    s.account_cell = v
    return s
}
            

func (s *TypeIdTableV4Builder) ApplyRegisterCell(v Hash) *TypeIdTableV4Builder {
    s.apply_register_cell = v
    return s
}
            

func (s *TypeIdTableV4Builder) BalanceCell(v Hash) *TypeIdTableV4Builder {
    s.balance_cell = v
    return s
}
            

func (s *TypeIdTableV4Builder) IncomeCell(v Hash) *TypeIdTableV4Builder {
    s.income_cell = v
    return s
}
            

func (s *TypeIdTableV4Builder) PreAccountCell(v Hash) *TypeIdTableV4Builder {
    s.pre_account_cell = v
    return s
}
            

func (s *TypeIdTableV4Builder) ProposalCell(v Hash) *TypeIdTableV4Builder {
    s.proposal_cell = v
    return s
}
            

func (s *TypeIdTableV4Builder) AccountSaleCell(v Hash) *TypeIdTableV4Builder {
    s.account_sale_cell = v
    return s
}
            

func (s *TypeIdTableV4Builder) AccountAuctionCell(v Hash) *TypeIdTableV4Builder {
    s.account_auction_cell = v
    return s
}
            

func (s *TypeIdTableV4Builder) OfferCell(v Hash) *TypeIdTableV4Builder {
    s.offer_cell = v
    return s
}
            

func (s *TypeIdTableV4Builder) ReverseRecordCell(v Hash) *TypeIdTableV4Builder {
    s.reverse_record_cell = v
    return s
}
            

func NewTypeIdTableV4Builder() *TypeIdTableV4Builder {
	return &TypeIdTableV4Builder{ account_cell: HashDefault(),apply_register_cell: HashDefault(),balance_cell: HashDefault(),income_cell: HashDefault(),pre_account_cell: HashDefault(),proposal_cell: HashDefault(),account_sale_cell: HashDefault(),account_auction_cell: HashDefault(),offer_cell: HashDefault(),reverse_record_cell: HashDefault() }
}
    

type TypeIdTableV4 struct {
    inner []byte
}
        

func TypeIdTableV4FromSliceUnchecked(slice []byte) *TypeIdTableV4 {
    return &TypeIdTableV4{inner: slice}
}
func (s *TypeIdTableV4) AsSlice() []byte {
    return s.inner
}
            

func TypeIdTableV4Default() TypeIdTableV4 {
    return *TypeIdTableV4FromSliceUnchecked([]byte{ 108,1,0,0,44,0,0,0,76,0,0,0,108,0,0,0,140,0,0,0,172,0,0,0,204,0,0,0,236,0,0,0,12,1,0,0,44,1,0,0,76,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func TypeIdTableV4FromSlice(slice []byte, compatible bool) (*TypeIdTableV4, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV4", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV4", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV4", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "TypeIdTableV4", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV4", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 10 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 10 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = HashFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[8]:offsets[9]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[9]:offsets[10]], compatible)
if err != nil {
    return nil, err
}
                

    return &TypeIdTableV4{inner: slice}, nil
}
            

func (s *TypeIdTableV4) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *TypeIdTableV4) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *TypeIdTableV4) Len() uint {
    return s.FieldCount()
}
func (s *TypeIdTableV4) IsEmpty() bool {
    return s.Len() == 0
}
func (s *TypeIdTableV4) CountExtraFields() uint {
    return s.FieldCount() - 10
}

func (s *TypeIdTableV4) HasExtraFields() bool {
    return 10 != s.FieldCount()
}
            

func (s *TypeIdTableV4) AccountCell() *Hash {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV4) ApplyRegisterCell() *Hash {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV4) BalanceCell() *Hash {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV4) IncomeCell() *Hash {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV4) PreAccountCell() *Hash {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV4) ProposalCell() *Hash {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV4) AccountSaleCell() *Hash {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV4) AccountAuctionCell() *Hash {
    start := unpackNumber(s.inner[32:])
    end := unpackNumber(s.inner[36:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV4) OfferCell() *Hash {
    start := unpackNumber(s.inner[36:])
    end := unpackNumber(s.inner[40:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV4) ReverseRecordCell() *Hash {
    var ret *Hash
    start := unpackNumber(s.inner[40:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[44:])
        ret = HashFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = HashFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *TypeIdTableV4) AsBuilder() TypeIdTableV4Builder {
    ret := NewTypeIdTableV4Builder().AccountCell(*s.AccountCell()).ApplyRegisterCell(*s.ApplyRegisterCell()).BalanceCell(*s.BalanceCell()).IncomeCell(*s.IncomeCell()).PreAccountCell(*s.PreAccountCell()).ProposalCell(*s.ProposalCell()).AccountSaleCell(*s.AccountSaleCell()).AccountAuctionCell(*s.AccountAuctionCell()).OfferCell(*s.OfferCell()).ReverseRecordCell(*s.ReverseRecordCell())
    return *ret
}
        

type ConfigCellMainV6Builder struct {
    status Uint8
type_id_table TypeIdTableV5
das_lock_out_point_table DasLockOutPointTable
}
        

func (s *ConfigCellMainV6Builder) Build() ConfigCellMainV6 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (3 + 1)
    offsets := make([]uint32, 0, 3)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.status.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.type_id_table.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.das_lock_out_point_table.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.status.AsSlice())
b.Write(s.type_id_table.AsSlice())
b.Write(s.das_lock_out_point_table.AsSlice())
    return ConfigCellMainV6{inner: b.Bytes()}
}
                

func (s *ConfigCellMainV6Builder) Status(v Uint8) *ConfigCellMainV6Builder {
    s.status = v
    return s
}
            

func (s *ConfigCellMainV6Builder) TypeIdTable(v TypeIdTableV5) *ConfigCellMainV6Builder {
    s.type_id_table = v
    return s
}
            

func (s *ConfigCellMainV6Builder) DasLockOutPointTable(v DasLockOutPointTable) *ConfigCellMainV6Builder {
    s.das_lock_out_point_table = v
    return s
}
            

func NewConfigCellMainV6Builder() *ConfigCellMainV6Builder {
	return &ConfigCellMainV6Builder{ status: Uint8Default(),type_id_table: TypeIdTableV5Default(),das_lock_out_point_table: DasLockOutPointTableDefault() }
}
    

type ConfigCellMainV6 struct {
    inner []byte
}
        

func ConfigCellMainV6FromSliceUnchecked(slice []byte) *ConfigCellMainV6 {
    return &ConfigCellMainV6{inner: slice}
}
func (s *ConfigCellMainV6) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellMainV6Default() ConfigCellMainV6 {
    return *ConfigCellMainV6FromSliceUnchecked([]byte{ 189,2,0,0,16,0,0,0,17,0,0,0,161,1,0,0,0,144,1,0,0,48,0,0,0,80,0,0,0,112,0,0,0,144,0,0,0,176,0,0,0,208,0,0,0,240,0,0,0,16,1,0,0,48,1,0,0,80,1,0,0,112,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,1,0,0,32,0,0,0,68,0,0,0,104,0,0,0,140,0,0,0,176,0,0,0,212,0,0,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellMainV6FromSlice(slice []byte, compatible bool) (*ConfigCellMainV6, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV6", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV6", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV6", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellMainV6", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV6", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 3 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 3 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = TypeIdTableV5FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = DasLockOutPointTableFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellMainV6{inner: slice}, nil
}
            

func (s *ConfigCellMainV6) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellMainV6) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellMainV6) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellMainV6) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellMainV6) CountExtraFields() uint {
    return s.FieldCount() - 3
}

func (s *ConfigCellMainV6) HasExtraFields() bool {
    return 3 != s.FieldCount()
}
            

func (s *ConfigCellMainV6) Status() *Uint8 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellMainV6) TypeIdTable() *TypeIdTableV5 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return TypeIdTableV5FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellMainV6) DasLockOutPointTable() *DasLockOutPointTable {
    var ret *DasLockOutPointTable
    start := unpackNumber(s.inner[12:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[16:])
        ret = DasLockOutPointTableFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = DasLockOutPointTableFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellMainV6) AsBuilder() ConfigCellMainV6Builder {
    ret := NewConfigCellMainV6Builder().Status(*s.Status()).TypeIdTable(*s.TypeIdTable()).DasLockOutPointTable(*s.DasLockOutPointTable())
    return *ret
}
        

type TypeIdTableV5Builder struct {
    account_cell Hash
apply_register_cell Hash
balance_cell Hash
income_cell Hash
pre_account_cell Hash
proposal_cell Hash
account_sale_cell Hash
account_auction_cell Hash
offer_cell Hash
reverse_record_cell Hash
sub_account_cell Hash
}
        

func (s *TypeIdTableV5Builder) Build() TypeIdTableV5 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (11 + 1)
    offsets := make([]uint32, 0, 11)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.apply_register_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.balance_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.income_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.pre_account_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_sale_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_auction_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.offer_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.reverse_record_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.sub_account_cell.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.account_cell.AsSlice())
b.Write(s.apply_register_cell.AsSlice())
b.Write(s.balance_cell.AsSlice())
b.Write(s.income_cell.AsSlice())
b.Write(s.pre_account_cell.AsSlice())
b.Write(s.proposal_cell.AsSlice())
b.Write(s.account_sale_cell.AsSlice())
b.Write(s.account_auction_cell.AsSlice())
b.Write(s.offer_cell.AsSlice())
b.Write(s.reverse_record_cell.AsSlice())
b.Write(s.sub_account_cell.AsSlice())
    return TypeIdTableV5{inner: b.Bytes()}
}
                

func (s *TypeIdTableV5Builder) AccountCell(v Hash) *TypeIdTableV5Builder {
    s.account_cell = v
    return s
}
            

func (s *TypeIdTableV5Builder) ApplyRegisterCell(v Hash) *TypeIdTableV5Builder {
    s.apply_register_cell = v
    return s
}
            

func (s *TypeIdTableV5Builder) BalanceCell(v Hash) *TypeIdTableV5Builder {
    s.balance_cell = v
    return s
}
            

func (s *TypeIdTableV5Builder) IncomeCell(v Hash) *TypeIdTableV5Builder {
    s.income_cell = v
    return s
}
            

func (s *TypeIdTableV5Builder) PreAccountCell(v Hash) *TypeIdTableV5Builder {
    s.pre_account_cell = v
    return s
}
            

func (s *TypeIdTableV5Builder) ProposalCell(v Hash) *TypeIdTableV5Builder {
    s.proposal_cell = v
    return s
}
            

func (s *TypeIdTableV5Builder) AccountSaleCell(v Hash) *TypeIdTableV5Builder {
    s.account_sale_cell = v
    return s
}
            

func (s *TypeIdTableV5Builder) AccountAuctionCell(v Hash) *TypeIdTableV5Builder {
    s.account_auction_cell = v
    return s
}
            

func (s *TypeIdTableV5Builder) OfferCell(v Hash) *TypeIdTableV5Builder {
    s.offer_cell = v
    return s
}
            

func (s *TypeIdTableV5Builder) ReverseRecordCell(v Hash) *TypeIdTableV5Builder {
    s.reverse_record_cell = v
    return s
}
            

func (s *TypeIdTableV5Builder) SubAccountCell(v Hash) *TypeIdTableV5Builder {
    s.sub_account_cell = v
    return s
}
            

func NewTypeIdTableV5Builder() *TypeIdTableV5Builder {
	return &TypeIdTableV5Builder{ account_cell: HashDefault(),apply_register_cell: HashDefault(),balance_cell: HashDefault(),income_cell: HashDefault(),pre_account_cell: HashDefault(),proposal_cell: HashDefault(),account_sale_cell: HashDefault(),account_auction_cell: HashDefault(),offer_cell: HashDefault(),reverse_record_cell: HashDefault(),sub_account_cell: HashDefault() }
}
    

type TypeIdTableV5 struct {
    inner []byte
}
        

func TypeIdTableV5FromSliceUnchecked(slice []byte) *TypeIdTableV5 {
    return &TypeIdTableV5{inner: slice}
}
func (s *TypeIdTableV5) AsSlice() []byte {
    return s.inner
}
            

func TypeIdTableV5Default() TypeIdTableV5 {
    return *TypeIdTableV5FromSliceUnchecked([]byte{ 144,1,0,0,48,0,0,0,80,0,0,0,112,0,0,0,144,0,0,0,176,0,0,0,208,0,0,0,240,0,0,0,16,1,0,0,48,1,0,0,80,1,0,0,112,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func TypeIdTableV5FromSlice(slice []byte, compatible bool) (*TypeIdTableV5, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV5", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV5", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV5", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "TypeIdTableV5", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV5", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 11 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 11 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = HashFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[8]:offsets[9]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[9]:offsets[10]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[10]:offsets[11]], compatible)
if err != nil {
    return nil, err
}
                

    return &TypeIdTableV5{inner: slice}, nil
}
            

func (s *TypeIdTableV5) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *TypeIdTableV5) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *TypeIdTableV5) Len() uint {
    return s.FieldCount()
}
func (s *TypeIdTableV5) IsEmpty() bool {
    return s.Len() == 0
}
func (s *TypeIdTableV5) CountExtraFields() uint {
    return s.FieldCount() - 11
}

func (s *TypeIdTableV5) HasExtraFields() bool {
    return 11 != s.FieldCount()
}
            

func (s *TypeIdTableV5) AccountCell() *Hash {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV5) ApplyRegisterCell() *Hash {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV5) BalanceCell() *Hash {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV5) IncomeCell() *Hash {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV5) PreAccountCell() *Hash {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV5) ProposalCell() *Hash {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV5) AccountSaleCell() *Hash {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV5) AccountAuctionCell() *Hash {
    start := unpackNumber(s.inner[32:])
    end := unpackNumber(s.inner[36:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV5) OfferCell() *Hash {
    start := unpackNumber(s.inner[36:])
    end := unpackNumber(s.inner[40:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV5) ReverseRecordCell() *Hash {
    start := unpackNumber(s.inner[40:])
    end := unpackNumber(s.inner[44:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV5) SubAccountCell() *Hash {
    var ret *Hash
    start := unpackNumber(s.inner[44:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[48:])
        ret = HashFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = HashFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *TypeIdTableV5) AsBuilder() TypeIdTableV5Builder {
    ret := NewTypeIdTableV5Builder().AccountCell(*s.AccountCell()).ApplyRegisterCell(*s.ApplyRegisterCell()).BalanceCell(*s.BalanceCell()).IncomeCell(*s.IncomeCell()).PreAccountCell(*s.PreAccountCell()).ProposalCell(*s.ProposalCell()).AccountSaleCell(*s.AccountSaleCell()).AccountAuctionCell(*s.AccountAuctionCell()).OfferCell(*s.OfferCell()).ReverseRecordCell(*s.ReverseRecordCell()).SubAccountCell(*s.SubAccountCell())
    return *ret
}
        

type ConfigCellMainV7Builder struct {
    status Uint8
type_id_table TypeIdTableV5
das_lock_out_point_table DasLockOutPointTable
}
        

func (s *ConfigCellMainV7Builder) Build() ConfigCellMainV7 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (3 + 1)
    offsets := make([]uint32, 0, 3)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.status.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.type_id_table.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.das_lock_out_point_table.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.status.AsSlice())
b.Write(s.type_id_table.AsSlice())
b.Write(s.das_lock_out_point_table.AsSlice())
    return ConfigCellMainV7{inner: b.Bytes()}
}
                

func (s *ConfigCellMainV7Builder) Status(v Uint8) *ConfigCellMainV7Builder {
    s.status = v
    return s
}
            

func (s *ConfigCellMainV7Builder) TypeIdTable(v TypeIdTableV5) *ConfigCellMainV7Builder {
    s.type_id_table = v
    return s
}
            

func (s *ConfigCellMainV7Builder) DasLockOutPointTable(v DasLockOutPointTable) *ConfigCellMainV7Builder {
    s.das_lock_out_point_table = v
    return s
}
            

func NewConfigCellMainV7Builder() *ConfigCellMainV7Builder {
	return &ConfigCellMainV7Builder{ status: Uint8Default(),type_id_table: TypeIdTableV5Default(),das_lock_out_point_table: DasLockOutPointTableDefault() }
}
    

type ConfigCellMainV7 struct {
    inner []byte
}
        

func ConfigCellMainV7FromSliceUnchecked(slice []byte) *ConfigCellMainV7 {
    return &ConfigCellMainV7{inner: slice}
}
func (s *ConfigCellMainV7) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellMainV7Default() ConfigCellMainV7 {
    return *ConfigCellMainV7FromSliceUnchecked([]byte{ 189,2,0,0,16,0,0,0,17,0,0,0,161,1,0,0,0,144,1,0,0,48,0,0,0,80,0,0,0,112,0,0,0,144,0,0,0,176,0,0,0,208,0,0,0,240,0,0,0,16,1,0,0,48,1,0,0,80,1,0,0,112,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,1,0,0,32,0,0,0,68,0,0,0,104,0,0,0,140,0,0,0,176,0,0,0,212,0,0,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellMainV7FromSlice(slice []byte, compatible bool) (*ConfigCellMainV7, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV7", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV7", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMainV7", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellMainV7", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMainV7", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 3 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 3 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = TypeIdTableV5FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = DasLockOutPointTableFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellMainV7{inner: slice}, nil
}
            

func (s *ConfigCellMainV7) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellMainV7) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellMainV7) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellMainV7) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellMainV7) CountExtraFields() uint {
    return s.FieldCount() - 3
}

func (s *ConfigCellMainV7) HasExtraFields() bool {
    return 3 != s.FieldCount()
}
            

func (s *ConfigCellMainV7) Status() *Uint8 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellMainV7) TypeIdTable() *TypeIdTableV5 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return TypeIdTableV5FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellMainV7) DasLockOutPointTable() *DasLockOutPointTable {
    var ret *DasLockOutPointTable
    start := unpackNumber(s.inner[12:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[16:])
        ret = DasLockOutPointTableFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = DasLockOutPointTableFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellMainV7) AsBuilder() ConfigCellMainV7Builder {
    ret := NewConfigCellMainV7Builder().Status(*s.Status()).TypeIdTable(*s.TypeIdTable()).DasLockOutPointTable(*s.DasLockOutPointTable())
    return *ret
}
        

type TypeIdTableV6Builder struct {
    account_cell Hash
apply_register_cell Hash
balance_cell Hash
income_cell Hash
pre_account_cell Hash
proposal_cell Hash
account_sale_cell Hash
account_auction_cell Hash
offer_cell Hash
reverse_record_cell Hash
sub_account_cell Hash
eip712_lib Hash
}
        

func (s *TypeIdTableV6Builder) Build() TypeIdTableV6 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (12 + 1)
    offsets := make([]uint32, 0, 12)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.apply_register_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.balance_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.income_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.pre_account_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_sale_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_auction_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.offer_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.reverse_record_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.sub_account_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.eip712_lib.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.account_cell.AsSlice())
b.Write(s.apply_register_cell.AsSlice())
b.Write(s.balance_cell.AsSlice())
b.Write(s.income_cell.AsSlice())
b.Write(s.pre_account_cell.AsSlice())
b.Write(s.proposal_cell.AsSlice())
b.Write(s.account_sale_cell.AsSlice())
b.Write(s.account_auction_cell.AsSlice())
b.Write(s.offer_cell.AsSlice())
b.Write(s.reverse_record_cell.AsSlice())
b.Write(s.sub_account_cell.AsSlice())
b.Write(s.eip712_lib.AsSlice())
    return TypeIdTableV6{inner: b.Bytes()}
}
                

func (s *TypeIdTableV6Builder) AccountCell(v Hash) *TypeIdTableV6Builder {
    s.account_cell = v
    return s
}
            

func (s *TypeIdTableV6Builder) ApplyRegisterCell(v Hash) *TypeIdTableV6Builder {
    s.apply_register_cell = v
    return s
}
            

func (s *TypeIdTableV6Builder) BalanceCell(v Hash) *TypeIdTableV6Builder {
    s.balance_cell = v
    return s
}
            

func (s *TypeIdTableV6Builder) IncomeCell(v Hash) *TypeIdTableV6Builder {
    s.income_cell = v
    return s
}
            

func (s *TypeIdTableV6Builder) PreAccountCell(v Hash) *TypeIdTableV6Builder {
    s.pre_account_cell = v
    return s
}
            

func (s *TypeIdTableV6Builder) ProposalCell(v Hash) *TypeIdTableV6Builder {
    s.proposal_cell = v
    return s
}
            

func (s *TypeIdTableV6Builder) AccountSaleCell(v Hash) *TypeIdTableV6Builder {
    s.account_sale_cell = v
    return s
}
            

func (s *TypeIdTableV6Builder) AccountAuctionCell(v Hash) *TypeIdTableV6Builder {
    s.account_auction_cell = v
    return s
}
            

func (s *TypeIdTableV6Builder) OfferCell(v Hash) *TypeIdTableV6Builder {
    s.offer_cell = v
    return s
}
            

func (s *TypeIdTableV6Builder) ReverseRecordCell(v Hash) *TypeIdTableV6Builder {
    s.reverse_record_cell = v
    return s
}
            

func (s *TypeIdTableV6Builder) SubAccountCell(v Hash) *TypeIdTableV6Builder {
    s.sub_account_cell = v
    return s
}
            

func (s *TypeIdTableV6Builder) Eip712Lib(v Hash) *TypeIdTableV6Builder {
    s.eip712_lib = v
    return s
}
            

func NewTypeIdTableV6Builder() *TypeIdTableV6Builder {
	return &TypeIdTableV6Builder{ account_cell: HashDefault(),apply_register_cell: HashDefault(),balance_cell: HashDefault(),income_cell: HashDefault(),pre_account_cell: HashDefault(),proposal_cell: HashDefault(),account_sale_cell: HashDefault(),account_auction_cell: HashDefault(),offer_cell: HashDefault(),reverse_record_cell: HashDefault(),sub_account_cell: HashDefault(),eip712_lib: HashDefault() }
}
    

type TypeIdTableV6 struct {
    inner []byte
}
        

func TypeIdTableV6FromSliceUnchecked(slice []byte) *TypeIdTableV6 {
    return &TypeIdTableV6{inner: slice}
}
func (s *TypeIdTableV6) AsSlice() []byte {
    return s.inner
}
            

func TypeIdTableV6Default() TypeIdTableV6 {
    return *TypeIdTableV6FromSliceUnchecked([]byte{ 180,1,0,0,52,0,0,0,84,0,0,0,116,0,0,0,148,0,0,0,180,0,0,0,212,0,0,0,244,0,0,0,20,1,0,0,52,1,0,0,84,1,0,0,116,1,0,0,148,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func TypeIdTableV6FromSlice(slice []byte, compatible bool) (*TypeIdTableV6, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV6", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV6", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTableV6", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "TypeIdTableV6", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTableV6", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 12 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 12 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = HashFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[8]:offsets[9]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[9]:offsets[10]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[10]:offsets[11]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[11]:offsets[12]], compatible)
if err != nil {
    return nil, err
}
                

    return &TypeIdTableV6{inner: slice}, nil
}
            

func (s *TypeIdTableV6) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *TypeIdTableV6) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *TypeIdTableV6) Len() uint {
    return s.FieldCount()
}
func (s *TypeIdTableV6) IsEmpty() bool {
    return s.Len() == 0
}
func (s *TypeIdTableV6) CountExtraFields() uint {
    return s.FieldCount() - 12
}

func (s *TypeIdTableV6) HasExtraFields() bool {
    return 12 != s.FieldCount()
}
            

func (s *TypeIdTableV6) AccountCell() *Hash {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV6) ApplyRegisterCell() *Hash {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV6) BalanceCell() *Hash {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV6) IncomeCell() *Hash {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV6) PreAccountCell() *Hash {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV6) ProposalCell() *Hash {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV6) AccountSaleCell() *Hash {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV6) AccountAuctionCell() *Hash {
    start := unpackNumber(s.inner[32:])
    end := unpackNumber(s.inner[36:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV6) OfferCell() *Hash {
    start := unpackNumber(s.inner[36:])
    end := unpackNumber(s.inner[40:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV6) ReverseRecordCell() *Hash {
    start := unpackNumber(s.inner[40:])
    end := unpackNumber(s.inner[44:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV6) SubAccountCell() *Hash {
    start := unpackNumber(s.inner[44:])
    end := unpackNumber(s.inner[48:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTableV6) Eip712Lib() *Hash {
    var ret *Hash
    start := unpackNumber(s.inner[48:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[52:])
        ret = HashFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = HashFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *TypeIdTableV6) AsBuilder() TypeIdTableV6Builder {
    ret := NewTypeIdTableV6Builder().AccountCell(*s.AccountCell()).ApplyRegisterCell(*s.ApplyRegisterCell()).BalanceCell(*s.BalanceCell()).IncomeCell(*s.IncomeCell()).PreAccountCell(*s.PreAccountCell()).ProposalCell(*s.ProposalCell()).AccountSaleCell(*s.AccountSaleCell()).AccountAuctionCell(*s.AccountAuctionCell()).OfferCell(*s.OfferCell()).ReverseRecordCell(*s.ReverseRecordCell()).SubAccountCell(*s.SubAccountCell()).Eip712Lib(*s.Eip712Lib())
    return *ret
}
        

type ConfigCellAccountV1Builder struct {
    max_length Uint32
basic_capacity Uint64
prepared_fee_capacity Uint64
expiration_grace_period Uint32
record_min_ttl Uint32
record_size_limit Uint32
transfer_account_fee Uint64
edit_manager_fee Uint64
edit_records_fee Uint64
transfer_account_throttle Uint32
edit_manager_throttle Uint32
edit_records_throttle Uint32
}
        

func (s *ConfigCellAccountV1Builder) Build() ConfigCellAccountV1 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (12 + 1)
    offsets := make([]uint32, 0, 12)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.max_length.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.basic_capacity.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.prepared_fee_capacity.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.expiration_grace_period.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.record_min_ttl.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.record_size_limit.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.transfer_account_fee.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.edit_manager_fee.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.edit_records_fee.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.transfer_account_throttle.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.edit_manager_throttle.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.edit_records_throttle.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.max_length.AsSlice())
b.Write(s.basic_capacity.AsSlice())
b.Write(s.prepared_fee_capacity.AsSlice())
b.Write(s.expiration_grace_period.AsSlice())
b.Write(s.record_min_ttl.AsSlice())
b.Write(s.record_size_limit.AsSlice())
b.Write(s.transfer_account_fee.AsSlice())
b.Write(s.edit_manager_fee.AsSlice())
b.Write(s.edit_records_fee.AsSlice())
b.Write(s.transfer_account_throttle.AsSlice())
b.Write(s.edit_manager_throttle.AsSlice())
b.Write(s.edit_records_throttle.AsSlice())
    return ConfigCellAccountV1{inner: b.Bytes()}
}
                

func (s *ConfigCellAccountV1Builder) MaxLength(v Uint32) *ConfigCellAccountV1Builder {
    s.max_length = v
    return s
}
            

func (s *ConfigCellAccountV1Builder) BasicCapacity(v Uint64) *ConfigCellAccountV1Builder {
    s.basic_capacity = v
    return s
}
            

func (s *ConfigCellAccountV1Builder) PreparedFeeCapacity(v Uint64) *ConfigCellAccountV1Builder {
    s.prepared_fee_capacity = v
    return s
}
            

func (s *ConfigCellAccountV1Builder) ExpirationGracePeriod(v Uint32) *ConfigCellAccountV1Builder {
    s.expiration_grace_period = v
    return s
}
            

func (s *ConfigCellAccountV1Builder) RecordMinTtl(v Uint32) *ConfigCellAccountV1Builder {
    s.record_min_ttl = v
    return s
}
            

func (s *ConfigCellAccountV1Builder) RecordSizeLimit(v Uint32) *ConfigCellAccountV1Builder {
    s.record_size_limit = v
    return s
}
            

func (s *ConfigCellAccountV1Builder) TransferAccountFee(v Uint64) *ConfigCellAccountV1Builder {
    s.transfer_account_fee = v
    return s
}
            

func (s *ConfigCellAccountV1Builder) EditManagerFee(v Uint64) *ConfigCellAccountV1Builder {
    s.edit_manager_fee = v
    return s
}
            

func (s *ConfigCellAccountV1Builder) EditRecordsFee(v Uint64) *ConfigCellAccountV1Builder {
    s.edit_records_fee = v
    return s
}
            

func (s *ConfigCellAccountV1Builder) TransferAccountThrottle(v Uint32) *ConfigCellAccountV1Builder {
    s.transfer_account_throttle = v
    return s
}
            

func (s *ConfigCellAccountV1Builder) EditManagerThrottle(v Uint32) *ConfigCellAccountV1Builder {
    s.edit_manager_throttle = v
    return s
}
            

func (s *ConfigCellAccountV1Builder) EditRecordsThrottle(v Uint32) *ConfigCellAccountV1Builder {
    s.edit_records_throttle = v
    return s
}
            

func NewConfigCellAccountV1Builder() *ConfigCellAccountV1Builder {
	return &ConfigCellAccountV1Builder{ max_length: Uint32Default(),basic_capacity: Uint64Default(),prepared_fee_capacity: Uint64Default(),expiration_grace_period: Uint32Default(),record_min_ttl: Uint32Default(),record_size_limit: Uint32Default(),transfer_account_fee: Uint64Default(),edit_manager_fee: Uint64Default(),edit_records_fee: Uint64Default(),transfer_account_throttle: Uint32Default(),edit_manager_throttle: Uint32Default(),edit_records_throttle: Uint32Default() }
}
    

type ConfigCellAccountV1 struct {
    inner []byte
}
        

func ConfigCellAccountV1FromSliceUnchecked(slice []byte) *ConfigCellAccountV1 {
    return &ConfigCellAccountV1{inner: slice}
}
func (s *ConfigCellAccountV1) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellAccountV1Default() ConfigCellAccountV1 {
    return *ConfigCellAccountV1FromSliceUnchecked([]byte{ 120,0,0,0,52,0,0,0,56,0,0,0,64,0,0,0,72,0,0,0,76,0,0,0,80,0,0,0,84,0,0,0,92,0,0,0,100,0,0,0,108,0,0,0,112,0,0,0,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellAccountV1FromSlice(slice []byte, compatible bool) (*ConfigCellAccountV1, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellAccountV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellAccountV1", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellAccountV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellAccountV1", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellAccountV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 12 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 12 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[8]:offsets[9]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[9]:offsets[10]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[10]:offsets[11]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[11]:offsets[12]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellAccountV1{inner: slice}, nil
}
            

func (s *ConfigCellAccountV1) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellAccountV1) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellAccountV1) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellAccountV1) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellAccountV1) CountExtraFields() uint {
    return s.FieldCount() - 12
}

func (s *ConfigCellAccountV1) HasExtraFields() bool {
    return 12 != s.FieldCount()
}
            

func (s *ConfigCellAccountV1) MaxLength() *Uint32 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccountV1) BasicCapacity() *Uint64 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccountV1) PreparedFeeCapacity() *Uint64 {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccountV1) ExpirationGracePeriod() *Uint32 {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccountV1) RecordMinTtl() *Uint32 {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccountV1) RecordSizeLimit() *Uint32 {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccountV1) TransferAccountFee() *Uint64 {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccountV1) EditManagerFee() *Uint64 {
    start := unpackNumber(s.inner[32:])
    end := unpackNumber(s.inner[36:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccountV1) EditRecordsFee() *Uint64 {
    start := unpackNumber(s.inner[36:])
    end := unpackNumber(s.inner[40:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccountV1) TransferAccountThrottle() *Uint32 {
    start := unpackNumber(s.inner[40:])
    end := unpackNumber(s.inner[44:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccountV1) EditManagerThrottle() *Uint32 {
    start := unpackNumber(s.inner[44:])
    end := unpackNumber(s.inner[48:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccountV1) EditRecordsThrottle() *Uint32 {
    var ret *Uint32
    start := unpackNumber(s.inner[48:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[52:])
        ret = Uint32FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint32FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellAccountV1) AsBuilder() ConfigCellAccountV1Builder {
    ret := NewConfigCellAccountV1Builder().MaxLength(*s.MaxLength()).BasicCapacity(*s.BasicCapacity()).PreparedFeeCapacity(*s.PreparedFeeCapacity()).ExpirationGracePeriod(*s.ExpirationGracePeriod()).RecordMinTtl(*s.RecordMinTtl()).RecordSizeLimit(*s.RecordSizeLimit()).TransferAccountFee(*s.TransferAccountFee()).EditManagerFee(*s.EditManagerFee()).EditRecordsFee(*s.EditRecordsFee()).TransferAccountThrottle(*s.TransferAccountThrottle()).EditManagerThrottle(*s.EditManagerThrottle()).EditRecordsThrottle(*s.EditRecordsThrottle())
    return *ret
}
        

type ConfigCellProfitRateV1Builder struct {
    inviter Uint32
channel Uint32
proposal_create Uint32
proposal_confirm Uint32
income_consolidate Uint32
}
        

func (s *ConfigCellProfitRateV1Builder) Build() ConfigCellProfitRateV1 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (5 + 1)
    offsets := make([]uint32, 0, 5)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.inviter.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.channel.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_create.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_confirm.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.income_consolidate.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.inviter.AsSlice())
b.Write(s.channel.AsSlice())
b.Write(s.proposal_create.AsSlice())
b.Write(s.proposal_confirm.AsSlice())
b.Write(s.income_consolidate.AsSlice())
    return ConfigCellProfitRateV1{inner: b.Bytes()}
}
                

func (s *ConfigCellProfitRateV1Builder) Inviter(v Uint32) *ConfigCellProfitRateV1Builder {
    s.inviter = v
    return s
}
            

func (s *ConfigCellProfitRateV1Builder) Channel(v Uint32) *ConfigCellProfitRateV1Builder {
    s.channel = v
    return s
}
            

func (s *ConfigCellProfitRateV1Builder) ProposalCreate(v Uint32) *ConfigCellProfitRateV1Builder {
    s.proposal_create = v
    return s
}
            

func (s *ConfigCellProfitRateV1Builder) ProposalConfirm(v Uint32) *ConfigCellProfitRateV1Builder {
    s.proposal_confirm = v
    return s
}
            

func (s *ConfigCellProfitRateV1Builder) IncomeConsolidate(v Uint32) *ConfigCellProfitRateV1Builder {
    s.income_consolidate = v
    return s
}
            

func NewConfigCellProfitRateV1Builder() *ConfigCellProfitRateV1Builder {
	return &ConfigCellProfitRateV1Builder{ inviter: Uint32Default(),channel: Uint32Default(),proposal_create: Uint32Default(),proposal_confirm: Uint32Default(),income_consolidate: Uint32Default() }
}
    

type ConfigCellProfitRateV1 struct {
    inner []byte
}
        

func ConfigCellProfitRateV1FromSliceUnchecked(slice []byte) *ConfigCellProfitRateV1 {
    return &ConfigCellProfitRateV1{inner: slice}
}
func (s *ConfigCellProfitRateV1) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellProfitRateV1Default() ConfigCellProfitRateV1 {
    return *ConfigCellProfitRateV1FromSliceUnchecked([]byte{ 44,0,0,0,24,0,0,0,28,0,0,0,32,0,0,0,36,0,0,0,40,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellProfitRateV1FromSlice(slice []byte, compatible bool) (*ConfigCellProfitRateV1, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellProfitRateV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellProfitRateV1", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellProfitRateV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellProfitRateV1", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellProfitRateV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 5 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 5 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellProfitRateV1{inner: slice}, nil
}
            

func (s *ConfigCellProfitRateV1) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellProfitRateV1) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellProfitRateV1) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellProfitRateV1) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellProfitRateV1) CountExtraFields() uint {
    return s.FieldCount() - 5
}

func (s *ConfigCellProfitRateV1) HasExtraFields() bool {
    return 5 != s.FieldCount()
}
            

func (s *ConfigCellProfitRateV1) Inviter() *Uint32 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProfitRateV1) Channel() *Uint32 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProfitRateV1) ProposalCreate() *Uint32 {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProfitRateV1) ProposalConfirm() *Uint32 {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProfitRateV1) IncomeConsolidate() *Uint32 {
    var ret *Uint32
    start := unpackNumber(s.inner[20:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[24:])
        ret = Uint32FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint32FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellProfitRateV1) AsBuilder() ConfigCellProfitRateV1Builder {
    ret := NewConfigCellProfitRateV1Builder().Inviter(*s.Inviter()).Channel(*s.Channel()).ProposalCreate(*s.ProposalCreate()).ProposalConfirm(*s.ProposalConfirm()).IncomeConsolidate(*s.IncomeConsolidate())
    return *ret
}
        

type ConfigCellProfitRateV2Builder struct {
    inviter Uint32
channel Uint32
proposal_create Uint32
proposal_confirm Uint32
income_consolidate Uint32
sale_inviter Uint32
sale_channel Uint32
sale_das Uint32
}
        

func (s *ConfigCellProfitRateV2Builder) Build() ConfigCellProfitRateV2 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (8 + 1)
    offsets := make([]uint32, 0, 8)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.inviter.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.channel.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_create.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_confirm.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.income_consolidate.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.sale_inviter.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.sale_channel.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.sale_das.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.inviter.AsSlice())
b.Write(s.channel.AsSlice())
b.Write(s.proposal_create.AsSlice())
b.Write(s.proposal_confirm.AsSlice())
b.Write(s.income_consolidate.AsSlice())
b.Write(s.sale_inviter.AsSlice())
b.Write(s.sale_channel.AsSlice())
b.Write(s.sale_das.AsSlice())
    return ConfigCellProfitRateV2{inner: b.Bytes()}
}
                

func (s *ConfigCellProfitRateV2Builder) Inviter(v Uint32) *ConfigCellProfitRateV2Builder {
    s.inviter = v
    return s
}
            

func (s *ConfigCellProfitRateV2Builder) Channel(v Uint32) *ConfigCellProfitRateV2Builder {
    s.channel = v
    return s
}
            

func (s *ConfigCellProfitRateV2Builder) ProposalCreate(v Uint32) *ConfigCellProfitRateV2Builder {
    s.proposal_create = v
    return s
}
            

func (s *ConfigCellProfitRateV2Builder) ProposalConfirm(v Uint32) *ConfigCellProfitRateV2Builder {
    s.proposal_confirm = v
    return s
}
            

func (s *ConfigCellProfitRateV2Builder) IncomeConsolidate(v Uint32) *ConfigCellProfitRateV2Builder {
    s.income_consolidate = v
    return s
}
            

func (s *ConfigCellProfitRateV2Builder) SaleInviter(v Uint32) *ConfigCellProfitRateV2Builder {
    s.sale_inviter = v
    return s
}
            

func (s *ConfigCellProfitRateV2Builder) SaleChannel(v Uint32) *ConfigCellProfitRateV2Builder {
    s.sale_channel = v
    return s
}
            

func (s *ConfigCellProfitRateV2Builder) SaleDas(v Uint32) *ConfigCellProfitRateV2Builder {
    s.sale_das = v
    return s
}
            

func NewConfigCellProfitRateV2Builder() *ConfigCellProfitRateV2Builder {
	return &ConfigCellProfitRateV2Builder{ inviter: Uint32Default(),channel: Uint32Default(),proposal_create: Uint32Default(),proposal_confirm: Uint32Default(),income_consolidate: Uint32Default(),sale_inviter: Uint32Default(),sale_channel: Uint32Default(),sale_das: Uint32Default() }
}
    

type ConfigCellProfitRateV2 struct {
    inner []byte
}
        

func ConfigCellProfitRateV2FromSliceUnchecked(slice []byte) *ConfigCellProfitRateV2 {
    return &ConfigCellProfitRateV2{inner: slice}
}
func (s *ConfigCellProfitRateV2) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellProfitRateV2Default() ConfigCellProfitRateV2 {
    return *ConfigCellProfitRateV2FromSliceUnchecked([]byte{ 68,0,0,0,36,0,0,0,40,0,0,0,44,0,0,0,48,0,0,0,52,0,0,0,56,0,0,0,60,0,0,0,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellProfitRateV2FromSlice(slice []byte, compatible bool) (*ConfigCellProfitRateV2, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellProfitRateV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellProfitRateV2", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellProfitRateV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellProfitRateV2", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellProfitRateV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 8 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 8 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellProfitRateV2{inner: slice}, nil
}
            

func (s *ConfigCellProfitRateV2) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellProfitRateV2) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellProfitRateV2) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellProfitRateV2) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellProfitRateV2) CountExtraFields() uint {
    return s.FieldCount() - 8
}

func (s *ConfigCellProfitRateV2) HasExtraFields() bool {
    return 8 != s.FieldCount()
}
            

func (s *ConfigCellProfitRateV2) Inviter() *Uint32 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProfitRateV2) Channel() *Uint32 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProfitRateV2) ProposalCreate() *Uint32 {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProfitRateV2) ProposalConfirm() *Uint32 {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProfitRateV2) IncomeConsolidate() *Uint32 {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProfitRateV2) SaleInviter() *Uint32 {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProfitRateV2) SaleChannel() *Uint32 {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProfitRateV2) SaleDas() *Uint32 {
    var ret *Uint32
    start := unpackNumber(s.inner[32:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[36:])
        ret = Uint32FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint32FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellProfitRateV2) AsBuilder() ConfigCellProfitRateV2Builder {
    ret := NewConfigCellProfitRateV2Builder().Inviter(*s.Inviter()).Channel(*s.Channel()).ProposalCreate(*s.ProposalCreate()).ProposalConfirm(*s.ProposalConfirm()).IncomeConsolidate(*s.IncomeConsolidate()).SaleInviter(*s.SaleInviter()).SaleChannel(*s.SaleChannel()).SaleDas(*s.SaleDas())
    return *ret
}
        

type ConfigCellSecondaryMarketV1Builder struct {
    min_sale_price Uint64
sale_expiration_limit Uint64
sale_description_bytes_limit Uint32
}
        

func (s *ConfigCellSecondaryMarketV1Builder) Build() ConfigCellSecondaryMarketV1 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (3 + 1)
    offsets := make([]uint32, 0, 3)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.min_sale_price.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.sale_expiration_limit.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.sale_description_bytes_limit.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.min_sale_price.AsSlice())
b.Write(s.sale_expiration_limit.AsSlice())
b.Write(s.sale_description_bytes_limit.AsSlice())
    return ConfigCellSecondaryMarketV1{inner: b.Bytes()}
}
                

func (s *ConfigCellSecondaryMarketV1Builder) MinSalePrice(v Uint64) *ConfigCellSecondaryMarketV1Builder {
    s.min_sale_price = v
    return s
}
            

func (s *ConfigCellSecondaryMarketV1Builder) SaleExpirationLimit(v Uint64) *ConfigCellSecondaryMarketV1Builder {
    s.sale_expiration_limit = v
    return s
}
            

func (s *ConfigCellSecondaryMarketV1Builder) SaleDescriptionBytesLimit(v Uint32) *ConfigCellSecondaryMarketV1Builder {
    s.sale_description_bytes_limit = v
    return s
}
            

func NewConfigCellSecondaryMarketV1Builder() *ConfigCellSecondaryMarketV1Builder {
	return &ConfigCellSecondaryMarketV1Builder{ min_sale_price: Uint64Default(),sale_expiration_limit: Uint64Default(),sale_description_bytes_limit: Uint32Default() }
}
    

type ConfigCellSecondaryMarketV1 struct {
    inner []byte
}
        

func ConfigCellSecondaryMarketV1FromSliceUnchecked(slice []byte) *ConfigCellSecondaryMarketV1 {
    return &ConfigCellSecondaryMarketV1{inner: slice}
}
func (s *ConfigCellSecondaryMarketV1) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellSecondaryMarketV1Default() ConfigCellSecondaryMarketV1 {
    return *ConfigCellSecondaryMarketV1FromSliceUnchecked([]byte{ 36,0,0,0,16,0,0,0,24,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellSecondaryMarketV1FromSlice(slice []byte, compatible bool) (*ConfigCellSecondaryMarketV1, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellSecondaryMarketV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellSecondaryMarketV1", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellSecondaryMarketV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellSecondaryMarketV1", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellSecondaryMarketV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 3 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 3 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint64FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellSecondaryMarketV1{inner: slice}, nil
}
            

func (s *ConfigCellSecondaryMarketV1) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellSecondaryMarketV1) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellSecondaryMarketV1) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellSecondaryMarketV1) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellSecondaryMarketV1) CountExtraFields() uint {
    return s.FieldCount() - 3
}

func (s *ConfigCellSecondaryMarketV1) HasExtraFields() bool {
    return 3 != s.FieldCount()
}
            

func (s *ConfigCellSecondaryMarketV1) MinSalePrice() *Uint64 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarketV1) SaleExpirationLimit() *Uint64 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarketV1) SaleDescriptionBytesLimit() *Uint32 {
    var ret *Uint32
    start := unpackNumber(s.inner[12:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[16:])
        ret = Uint32FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint32FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellSecondaryMarketV1) AsBuilder() ConfigCellSecondaryMarketV1Builder {
    ret := NewConfigCellSecondaryMarketV1Builder().MinSalePrice(*s.MinSalePrice()).SaleExpirationLimit(*s.SaleExpirationLimit()).SaleDescriptionBytesLimit(*s.SaleDescriptionBytesLimit())
    return *ret
}
        

type ConfigCellSecondaryMarketV2Builder struct {
    sale_min_price Uint64
sale_expiration_limit Uint32
sale_description_bytes_limit Uint32
auction_max_extendable_duration Uint32
auction_duration_increment_each_bid Uint32
auction_min_opening_price Uint64
auction_min_increment_rate_each_bid Uint32
auction_description_bytes_limit Uint32
}
        

func (s *ConfigCellSecondaryMarketV2Builder) Build() ConfigCellSecondaryMarketV2 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (8 + 1)
    offsets := make([]uint32, 0, 8)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.sale_min_price.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.sale_expiration_limit.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.sale_description_bytes_limit.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.auction_max_extendable_duration.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.auction_duration_increment_each_bid.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.auction_min_opening_price.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.auction_min_increment_rate_each_bid.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.auction_description_bytes_limit.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.sale_min_price.AsSlice())
b.Write(s.sale_expiration_limit.AsSlice())
b.Write(s.sale_description_bytes_limit.AsSlice())
b.Write(s.auction_max_extendable_duration.AsSlice())
b.Write(s.auction_duration_increment_each_bid.AsSlice())
b.Write(s.auction_min_opening_price.AsSlice())
b.Write(s.auction_min_increment_rate_each_bid.AsSlice())
b.Write(s.auction_description_bytes_limit.AsSlice())
    return ConfigCellSecondaryMarketV2{inner: b.Bytes()}
}
                

func (s *ConfigCellSecondaryMarketV2Builder) SaleMinPrice(v Uint64) *ConfigCellSecondaryMarketV2Builder {
    s.sale_min_price = v
    return s
}
            

func (s *ConfigCellSecondaryMarketV2Builder) SaleExpirationLimit(v Uint32) *ConfigCellSecondaryMarketV2Builder {
    s.sale_expiration_limit = v
    return s
}
            

func (s *ConfigCellSecondaryMarketV2Builder) SaleDescriptionBytesLimit(v Uint32) *ConfigCellSecondaryMarketV2Builder {
    s.sale_description_bytes_limit = v
    return s
}
            

func (s *ConfigCellSecondaryMarketV2Builder) AuctionMaxExtendableDuration(v Uint32) *ConfigCellSecondaryMarketV2Builder {
    s.auction_max_extendable_duration = v
    return s
}
            

func (s *ConfigCellSecondaryMarketV2Builder) AuctionDurationIncrementEachBid(v Uint32) *ConfigCellSecondaryMarketV2Builder {
    s.auction_duration_increment_each_bid = v
    return s
}
            

func (s *ConfigCellSecondaryMarketV2Builder) AuctionMinOpeningPrice(v Uint64) *ConfigCellSecondaryMarketV2Builder {
    s.auction_min_opening_price = v
    return s
}
            

func (s *ConfigCellSecondaryMarketV2Builder) AuctionMinIncrementRateEachBid(v Uint32) *ConfigCellSecondaryMarketV2Builder {
    s.auction_min_increment_rate_each_bid = v
    return s
}
            

func (s *ConfigCellSecondaryMarketV2Builder) AuctionDescriptionBytesLimit(v Uint32) *ConfigCellSecondaryMarketV2Builder {
    s.auction_description_bytes_limit = v
    return s
}
            

func NewConfigCellSecondaryMarketV2Builder() *ConfigCellSecondaryMarketV2Builder {
	return &ConfigCellSecondaryMarketV2Builder{ sale_min_price: Uint64Default(),sale_expiration_limit: Uint32Default(),sale_description_bytes_limit: Uint32Default(),auction_max_extendable_duration: Uint32Default(),auction_duration_increment_each_bid: Uint32Default(),auction_min_opening_price: Uint64Default(),auction_min_increment_rate_each_bid: Uint32Default(),auction_description_bytes_limit: Uint32Default() }
}
    

type ConfigCellSecondaryMarketV2 struct {
    inner []byte
}
        

func ConfigCellSecondaryMarketV2FromSliceUnchecked(slice []byte) *ConfigCellSecondaryMarketV2 {
    return &ConfigCellSecondaryMarketV2{inner: slice}
}
func (s *ConfigCellSecondaryMarketV2) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellSecondaryMarketV2Default() ConfigCellSecondaryMarketV2 {
    return *ConfigCellSecondaryMarketV2FromSliceUnchecked([]byte{ 76,0,0,0,36,0,0,0,44,0,0,0,48,0,0,0,52,0,0,0,56,0,0,0,60,0,0,0,68,0,0,0,72,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellSecondaryMarketV2FromSlice(slice []byte, compatible bool) (*ConfigCellSecondaryMarketV2, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellSecondaryMarketV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellSecondaryMarketV2", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellSecondaryMarketV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellSecondaryMarketV2", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellSecondaryMarketV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 8 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 8 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint64FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellSecondaryMarketV2{inner: slice}, nil
}
            

func (s *ConfigCellSecondaryMarketV2) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellSecondaryMarketV2) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellSecondaryMarketV2) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellSecondaryMarketV2) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellSecondaryMarketV2) CountExtraFields() uint {
    return s.FieldCount() - 8
}

func (s *ConfigCellSecondaryMarketV2) HasExtraFields() bool {
    return 8 != s.FieldCount()
}
            

func (s *ConfigCellSecondaryMarketV2) SaleMinPrice() *Uint64 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarketV2) SaleExpirationLimit() *Uint32 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarketV2) SaleDescriptionBytesLimit() *Uint32 {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarketV2) AuctionMaxExtendableDuration() *Uint32 {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarketV2) AuctionDurationIncrementEachBid() *Uint32 {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarketV2) AuctionMinOpeningPrice() *Uint64 {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarketV2) AuctionMinIncrementRateEachBid() *Uint32 {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarketV2) AuctionDescriptionBytesLimit() *Uint32 {
    var ret *Uint32
    start := unpackNumber(s.inner[32:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[36:])
        ret = Uint32FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint32FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellSecondaryMarketV2) AsBuilder() ConfigCellSecondaryMarketV2Builder {
    ret := NewConfigCellSecondaryMarketV2Builder().SaleMinPrice(*s.SaleMinPrice()).SaleExpirationLimit(*s.SaleExpirationLimit()).SaleDescriptionBytesLimit(*s.SaleDescriptionBytesLimit()).AuctionMaxExtendableDuration(*s.AuctionMaxExtendableDuration()).AuctionDurationIncrementEachBid(*s.AuctionDurationIncrementEachBid()).AuctionMinOpeningPrice(*s.AuctionMinOpeningPrice()).AuctionMinIncrementRateEachBid(*s.AuctionMinIncrementRateEachBid()).AuctionDescriptionBytesLimit(*s.AuctionDescriptionBytesLimit())
    return *ret
}
        

type ConfigCellSubAccountV1Builder struct {
    basic_capacity Uint64
prepared_fee_capacity Uint64
new_sub_account_price Uint64
renew_sub_account_price Uint64
common_fee Uint64
create_fee Uint64
edit_fee Uint64
renew_fee Uint64
recycle_fee Uint64
}
        

func (s *ConfigCellSubAccountV1Builder) Build() ConfigCellSubAccountV1 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (9 + 1)
    offsets := make([]uint32, 0, 9)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.basic_capacity.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.prepared_fee_capacity.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.new_sub_account_price.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.renew_sub_account_price.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.common_fee.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.create_fee.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.edit_fee.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.renew_fee.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.recycle_fee.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.basic_capacity.AsSlice())
b.Write(s.prepared_fee_capacity.AsSlice())
b.Write(s.new_sub_account_price.AsSlice())
b.Write(s.renew_sub_account_price.AsSlice())
b.Write(s.common_fee.AsSlice())
b.Write(s.create_fee.AsSlice())
b.Write(s.edit_fee.AsSlice())
b.Write(s.renew_fee.AsSlice())
b.Write(s.recycle_fee.AsSlice())
    return ConfigCellSubAccountV1{inner: b.Bytes()}
}
                

func (s *ConfigCellSubAccountV1Builder) BasicCapacity(v Uint64) *ConfigCellSubAccountV1Builder {
    s.basic_capacity = v
    return s
}
            

func (s *ConfigCellSubAccountV1Builder) PreparedFeeCapacity(v Uint64) *ConfigCellSubAccountV1Builder {
    s.prepared_fee_capacity = v
    return s
}
            

func (s *ConfigCellSubAccountV1Builder) NewSubAccountPrice(v Uint64) *ConfigCellSubAccountV1Builder {
    s.new_sub_account_price = v
    return s
}
            

func (s *ConfigCellSubAccountV1Builder) RenewSubAccountPrice(v Uint64) *ConfigCellSubAccountV1Builder {
    s.renew_sub_account_price = v
    return s
}
            

func (s *ConfigCellSubAccountV1Builder) CommonFee(v Uint64) *ConfigCellSubAccountV1Builder {
    s.common_fee = v
    return s
}
            

func (s *ConfigCellSubAccountV1Builder) CreateFee(v Uint64) *ConfigCellSubAccountV1Builder {
    s.create_fee = v
    return s
}
            

func (s *ConfigCellSubAccountV1Builder) EditFee(v Uint64) *ConfigCellSubAccountV1Builder {
    s.edit_fee = v
    return s
}
            

func (s *ConfigCellSubAccountV1Builder) RenewFee(v Uint64) *ConfigCellSubAccountV1Builder {
    s.renew_fee = v
    return s
}
            

func (s *ConfigCellSubAccountV1Builder) RecycleFee(v Uint64) *ConfigCellSubAccountV1Builder {
    s.recycle_fee = v
    return s
}
            

func NewConfigCellSubAccountV1Builder() *ConfigCellSubAccountV1Builder {
	return &ConfigCellSubAccountV1Builder{ basic_capacity: Uint64Default(),prepared_fee_capacity: Uint64Default(),new_sub_account_price: Uint64Default(),renew_sub_account_price: Uint64Default(),common_fee: Uint64Default(),create_fee: Uint64Default(),edit_fee: Uint64Default(),renew_fee: Uint64Default(),recycle_fee: Uint64Default() }
}
    

type ConfigCellSubAccountV1 struct {
    inner []byte
}
        

func ConfigCellSubAccountV1FromSliceUnchecked(slice []byte) *ConfigCellSubAccountV1 {
    return &ConfigCellSubAccountV1{inner: slice}
}
func (s *ConfigCellSubAccountV1) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellSubAccountV1Default() ConfigCellSubAccountV1 {
    return *ConfigCellSubAccountV1FromSliceUnchecked([]byte{ 112,0,0,0,40,0,0,0,48,0,0,0,56,0,0,0,64,0,0,0,72,0,0,0,80,0,0,0,88,0,0,0,96,0,0,0,104,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellSubAccountV1FromSlice(slice []byte, compatible bool) (*ConfigCellSubAccountV1, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellSubAccountV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellSubAccountV1", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellSubAccountV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellSubAccountV1", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellSubAccountV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 9 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 9 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint64FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[8]:offsets[9]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellSubAccountV1{inner: slice}, nil
}
            

func (s *ConfigCellSubAccountV1) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellSubAccountV1) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellSubAccountV1) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellSubAccountV1) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellSubAccountV1) CountExtraFields() uint {
    return s.FieldCount() - 9
}

func (s *ConfigCellSubAccountV1) HasExtraFields() bool {
    return 9 != s.FieldCount()
}
            

func (s *ConfigCellSubAccountV1) BasicCapacity() *Uint64 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSubAccountV1) PreparedFeeCapacity() *Uint64 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSubAccountV1) NewSubAccountPrice() *Uint64 {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSubAccountV1) RenewSubAccountPrice() *Uint64 {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSubAccountV1) CommonFee() *Uint64 {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSubAccountV1) CreateFee() *Uint64 {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSubAccountV1) EditFee() *Uint64 {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSubAccountV1) RenewFee() *Uint64 {
    start := unpackNumber(s.inner[32:])
    end := unpackNumber(s.inner[36:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSubAccountV1) RecycleFee() *Uint64 {
    var ret *Uint64
    start := unpackNumber(s.inner[36:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[40:])
        ret = Uint64FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint64FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellSubAccountV1) AsBuilder() ConfigCellSubAccountV1Builder {
    ret := NewConfigCellSubAccountV1Builder().BasicCapacity(*s.BasicCapacity()).PreparedFeeCapacity(*s.PreparedFeeCapacity()).NewSubAccountPrice(*s.NewSubAccountPrice()).RenewSubAccountPrice(*s.RenewSubAccountPrice()).CommonFee(*s.CommonFee()).CreateFee(*s.CreateFee()).EditFee(*s.EditFee()).RenewFee(*s.RenewFee()).RecycleFee(*s.RecycleFee())
    return *ret
}
        
