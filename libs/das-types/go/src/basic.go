// Generated by Molecule 0.7.5
// Generated by Moleculec-Go 0.1.11

package basic
import (
    "bytes"
    "encoding/binary"
    "errors"
    "strconv"
    "strings"
       )

type Number uint32
const HeaderSizeUint uint32 = 4
// Byte is the primitive type
type Byte [1]byte
func NewByte(b byte) Byte {
    return Byte([1]byte{b})
}
func ByteDefault() Byte {
    return Byte([1]byte{0})
}
func ByteFromSliceUnchecked(slice []byte) *Byte {
    b := new(Byte)
    b[0] = slice[0]
    return b
}
func (b *Byte) AsSlice() []byte {
    return b[:]
}
func ByteFromSlice(slice []byte, _compatible bool) (*Byte, error) {
    if len(slice) != 1 {
        return nil, errors.New("TotalSizeNotMatch")
    }
    b := new(Byte)
    b[0] = slice[0]
    return b, nil
}
func unpackNumber(b []byte) Number {
    bytesBuffer := bytes.NewBuffer(b)
    var x Number
    binary.Read(bytesBuffer, binary.LittleEndian, &x)
    return x
}
func packNumber(num Number) []byte {
    b := make([]byte, 4)
    binary.LittleEndian.PutUint32(b, uint32(num))
    return b
}
                    

type Uint8Builder struct {
	inner [1]Byte
}

func NewUint8Builder() *Uint8Builder {
	return &Uint8Builder{inner: [1]Byte{ByteDefault()}}
}

func (s *Uint8Builder) Build() Uint8 {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Uint8{inner: b.Bytes()}
}
        

func (s *Uint8Builder) Set(v [1]Byte) *Uint8Builder {
	s.inner = v
	return s
}
        

func (s *Uint8Builder) Nth0(v Byte) *Uint8Builder {
	s.inner[0] = v
	return s
}
                

type Uint8 struct {
    inner []byte
}
        

func Uint8FromSliceUnchecked(slice []byte) *Uint8 {
    return &Uint8{inner: slice}
}
func (s *Uint8) AsSlice() []byte {
    return s.inner
}
            

func Uint8Default() Uint8 {
    return *Uint8FromSliceUnchecked([]byte{ 0 })
}
            

func Uint8FromSlice(slice []byte, _compatible bool) (*Uint8, error) {
    sliceLen := len(slice)
    if sliceLen != 1 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "Uint8", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(1)}, " ")
        return nil, errors.New(errMsg)
    }
    return &Uint8{inner: slice}, nil
}
        

func (s *Uint8) RawData() []byte {
    return s.inner
}
            

func (s *Uint8) Nth0() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[0:1])
    return ret
}
            

func (s *Uint8) AsBuilder() Uint8Builder {
	t := NewUint8Builder()
	t.Nth0(*s.Nth0())
	return *t
}
        

type Uint32Builder struct {
	inner [4]Byte
}

func NewUint32Builder() *Uint32Builder {
	return &Uint32Builder{inner: [4]Byte{ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault()}}
}

func (s *Uint32Builder) Build() Uint32 {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Uint32{inner: b.Bytes()}
}
        

func (s *Uint32Builder) Set(v [4]Byte) *Uint32Builder {
	s.inner = v
	return s
}
        

func (s *Uint32Builder) Nth0(v Byte) *Uint32Builder {
	s.inner[0] = v
	return s
}
                

func (s *Uint32Builder) Nth1(v Byte) *Uint32Builder {
	s.inner[1] = v
	return s
}
                

func (s *Uint32Builder) Nth2(v Byte) *Uint32Builder {
	s.inner[2] = v
	return s
}
                

func (s *Uint32Builder) Nth3(v Byte) *Uint32Builder {
	s.inner[3] = v
	return s
}
                

type Uint32 struct {
    inner []byte
}
        

func Uint32FromSliceUnchecked(slice []byte) *Uint32 {
    return &Uint32{inner: slice}
}
func (s *Uint32) AsSlice() []byte {
    return s.inner
}
            

func Uint32Default() Uint32 {
    return *Uint32FromSliceUnchecked([]byte{ 0,0,0,0 })
}
            

func Uint32FromSlice(slice []byte, _compatible bool) (*Uint32, error) {
    sliceLen := len(slice)
    if sliceLen != 4 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "Uint32", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(4)}, " ")
        return nil, errors.New(errMsg)
    }
    return &Uint32{inner: slice}, nil
}
        

func (s *Uint32) RawData() []byte {
    return s.inner
}
            

func (s *Uint32) Nth0() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[0:1])
    return ret
}
            

func (s *Uint32) Nth1() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[1:2])
    return ret
}
            

func (s *Uint32) Nth2() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[2:3])
    return ret
}
            

func (s *Uint32) Nth3() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[3:4])
    return ret
}
            

func (s *Uint32) AsBuilder() Uint32Builder {
	t := NewUint32Builder()
	t.Nth0(*s.Nth0())
t.Nth1(*s.Nth1())
t.Nth2(*s.Nth2())
t.Nth3(*s.Nth3())
	return *t
}
        

type Uint64Builder struct {
	inner [8]Byte
}

func NewUint64Builder() *Uint64Builder {
	return &Uint64Builder{inner: [8]Byte{ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault()}}
}

func (s *Uint64Builder) Build() Uint64 {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Uint64{inner: b.Bytes()}
}
        

func (s *Uint64Builder) Set(v [8]Byte) *Uint64Builder {
	s.inner = v
	return s
}
        

func (s *Uint64Builder) Nth0(v Byte) *Uint64Builder {
	s.inner[0] = v
	return s
}
                

func (s *Uint64Builder) Nth1(v Byte) *Uint64Builder {
	s.inner[1] = v
	return s
}
                

func (s *Uint64Builder) Nth2(v Byte) *Uint64Builder {
	s.inner[2] = v
	return s
}
                

func (s *Uint64Builder) Nth3(v Byte) *Uint64Builder {
	s.inner[3] = v
	return s
}
                

func (s *Uint64Builder) Nth4(v Byte) *Uint64Builder {
	s.inner[4] = v
	return s
}
                

func (s *Uint64Builder) Nth5(v Byte) *Uint64Builder {
	s.inner[5] = v
	return s
}
                

func (s *Uint64Builder) Nth6(v Byte) *Uint64Builder {
	s.inner[6] = v
	return s
}
                

func (s *Uint64Builder) Nth7(v Byte) *Uint64Builder {
	s.inner[7] = v
	return s
}
                

type Uint64 struct {
    inner []byte
}
        

func Uint64FromSliceUnchecked(slice []byte) *Uint64 {
    return &Uint64{inner: slice}
}
func (s *Uint64) AsSlice() []byte {
    return s.inner
}
            

func Uint64Default() Uint64 {
    return *Uint64FromSliceUnchecked([]byte{ 0,0,0,0,0,0,0,0 })
}
            

func Uint64FromSlice(slice []byte, _compatible bool) (*Uint64, error) {
    sliceLen := len(slice)
    if sliceLen != 8 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "Uint64", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(8)}, " ")
        return nil, errors.New(errMsg)
    }
    return &Uint64{inner: slice}, nil
}
        

func (s *Uint64) RawData() []byte {
    return s.inner
}
            

func (s *Uint64) Nth0() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[0:1])
    return ret
}
            

func (s *Uint64) Nth1() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[1:2])
    return ret
}
            

func (s *Uint64) Nth2() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[2:3])
    return ret
}
            

func (s *Uint64) Nth3() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[3:4])
    return ret
}
            

func (s *Uint64) Nth4() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[4:5])
    return ret
}
            

func (s *Uint64) Nth5() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[5:6])
    return ret
}
            

func (s *Uint64) Nth6() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[6:7])
    return ret
}
            

func (s *Uint64) Nth7() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[7:8])
    return ret
}
            

func (s *Uint64) AsBuilder() Uint64Builder {
	t := NewUint64Builder()
	t.Nth0(*s.Nth0())
t.Nth1(*s.Nth1())
t.Nth2(*s.Nth2())
t.Nth3(*s.Nth3())
t.Nth4(*s.Nth4())
t.Nth5(*s.Nth5())
t.Nth6(*s.Nth6())
t.Nth7(*s.Nth7())
	return *t
}
        

type Byte10Builder struct {
	inner [10]Byte
}

func NewByte10Builder() *Byte10Builder {
	return &Byte10Builder{inner: [10]Byte{ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault()}}
}

func (s *Byte10Builder) Build() Byte10 {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Byte10{inner: b.Bytes()}
}
        

func (s *Byte10Builder) Set(v [10]Byte) *Byte10Builder {
	s.inner = v
	return s
}
        

func (s *Byte10Builder) Nth0(v Byte) *Byte10Builder {
	s.inner[0] = v
	return s
}
                

func (s *Byte10Builder) Nth1(v Byte) *Byte10Builder {
	s.inner[1] = v
	return s
}
                

func (s *Byte10Builder) Nth2(v Byte) *Byte10Builder {
	s.inner[2] = v
	return s
}
                

func (s *Byte10Builder) Nth3(v Byte) *Byte10Builder {
	s.inner[3] = v
	return s
}
                

func (s *Byte10Builder) Nth4(v Byte) *Byte10Builder {
	s.inner[4] = v
	return s
}
                

func (s *Byte10Builder) Nth5(v Byte) *Byte10Builder {
	s.inner[5] = v
	return s
}
                

func (s *Byte10Builder) Nth6(v Byte) *Byte10Builder {
	s.inner[6] = v
	return s
}
                

func (s *Byte10Builder) Nth7(v Byte) *Byte10Builder {
	s.inner[7] = v
	return s
}
                

func (s *Byte10Builder) Nth8(v Byte) *Byte10Builder {
	s.inner[8] = v
	return s
}
                

func (s *Byte10Builder) Nth9(v Byte) *Byte10Builder {
	s.inner[9] = v
	return s
}
                

type Byte10 struct {
    inner []byte
}
        

func Byte10FromSliceUnchecked(slice []byte) *Byte10 {
    return &Byte10{inner: slice}
}
func (s *Byte10) AsSlice() []byte {
    return s.inner
}
            

func Byte10Default() Byte10 {
    return *Byte10FromSliceUnchecked([]byte{ 0,0,0,0,0,0,0,0,0,0 })
}
            

func Byte10FromSlice(slice []byte, _compatible bool) (*Byte10, error) {
    sliceLen := len(slice)
    if sliceLen != 10 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "Byte10", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(10)}, " ")
        return nil, errors.New(errMsg)
    }
    return &Byte10{inner: slice}, nil
}
        

func (s *Byte10) RawData() []byte {
    return s.inner
}
            

func (s *Byte10) Nth0() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[0:1])
    return ret
}
            

func (s *Byte10) Nth1() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[1:2])
    return ret
}
            

func (s *Byte10) Nth2() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[2:3])
    return ret
}
            

func (s *Byte10) Nth3() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[3:4])
    return ret
}
            

func (s *Byte10) Nth4() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[4:5])
    return ret
}
            

func (s *Byte10) Nth5() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[5:6])
    return ret
}
            

func (s *Byte10) Nth6() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[6:7])
    return ret
}
            

func (s *Byte10) Nth7() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[7:8])
    return ret
}
            

func (s *Byte10) Nth8() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[8:9])
    return ret
}
            

func (s *Byte10) Nth9() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[9:10])
    return ret
}
            

func (s *Byte10) AsBuilder() Byte10Builder {
	t := NewByte10Builder()
	t.Nth0(*s.Nth0())
t.Nth1(*s.Nth1())
t.Nth2(*s.Nth2())
t.Nth3(*s.Nth3())
t.Nth4(*s.Nth4())
t.Nth5(*s.Nth5())
t.Nth6(*s.Nth6())
t.Nth7(*s.Nth7())
t.Nth8(*s.Nth8())
t.Nth9(*s.Nth9())
	return *t
}
        

type BytesBuilder struct {
    inner []Byte
}
    

func (s *BytesBuilder) Build() Bytes {
    size := packNumber(Number(len(s.inner)))

    b := new(bytes.Buffer)

    b.Write(size)
    len := len(s.inner)
    for i := 0; i < len; i++ {
        b.Write(s.inner[i].AsSlice())
    }

    sb := Bytes{inner: b.Bytes()}

    return sb
}
            

func (s *BytesBuilder) Set(v []Byte) *BytesBuilder {
    s.inner = v
    return s
}
func (s *BytesBuilder) Push(v Byte) *BytesBuilder {
    s.inner = append(s.inner, v)
    return s
}
func (s *BytesBuilder) Extend(iter []Byte) *BytesBuilder {
    for i:=0; i < len(iter); i++ {
        s.inner = append(s.inner, iter[i])
    }
    return s
}
func (s *BytesBuilder) Replace(index uint, v Byte) *Byte {
    if uint(len(s.inner)) > index {
        a := s.inner[index]
        s.inner[index] = v
        return &a
    }
    return nil
}
    

func NewBytesBuilder() *BytesBuilder {
	return &BytesBuilder{ []Byte{} }
}
        

type Bytes struct {
    inner []byte
}
        

func BytesFromSliceUnchecked(slice []byte) *Bytes {
    return &Bytes{inner: slice}
}
func (s *Bytes) AsSlice() []byte {
    return s.inner
}
            

func BytesDefault() Bytes {
    return *BytesFromSliceUnchecked([]byte{ 0,0,0,0 })
}
            

func BytesFromSlice(slice []byte, _compatible bool) (*Bytes, error) {
    sliceLen := len(slice)
    if sliceLen < int(HeaderSizeUint) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "Bytes", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }
    itemCount := unpackNumber(slice)
    if itemCount == 0 {
        if sliceLen != int(HeaderSizeUint) {
            errMsg := strings.Join([]string{"TotalSizeNotMatch", "Bytes", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
            return nil, errors.New(errMsg)
        }
        return &Bytes{inner: slice}, nil
    }
    totalSize := int(HeaderSizeUint) + int(1*itemCount)
    if sliceLen != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "Bytes", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }
    return &Bytes{inner: slice}, nil
}
            

func (s *Bytes) TotalSize() uint {
    return uint(HeaderSizeUint) + 1 * s.ItemCount()
}
func (s *Bytes) ItemCount() uint {
    number := uint(unpackNumber(s.inner))
    return number
}
func (s *Bytes) Len() uint {
    return s.ItemCount()
}
func (s *Bytes) IsEmpty() bool {
    return s.Len() == 0
}
// if *Byte is nil, index is out of bounds
func (s *Bytes) Get(index uint) *Byte {
    var re *Byte
    if index < s.Len() {
        start := uint(HeaderSizeUint) + 1*index
        end := start + 1
        re = ByteFromSliceUnchecked(s.inner[start:end])
    }
    return re
}
        

func (s *Bytes) RawData() []byte {
    return s.inner[HeaderSizeUint:]
}
            

func (s *Bytes) AsBuilder() BytesBuilder {
    size := s.ItemCount()
    t := NewBytesBuilder()
    for i:=uint(0); i < size; i++ {
        t.Push(*s.Get(i))
    }
    return *t
}
        

type BytesVecBuilder struct {
    inner []Bytes
}
    

func (s *BytesVecBuilder) Build() BytesVec {
    itemCount := len(s.inner)

    b := new(bytes.Buffer)

    // Empty dyn vector, just return size's bytes
    if itemCount == 0 {
        b.Write(packNumber(Number(HeaderSizeUint)))
        return BytesVec{inner: b.Bytes()}
    }

    // Calculate first offset then loop for rest items offsets
    totalSize := HeaderSizeUint * uint32(itemCount+1)
    offsets := make([]uint32, 0, itemCount)
    offsets = append(offsets, totalSize)
    for i := 1; i < itemCount; i++ {
        totalSize += uint32(len(s.inner[i-1].AsSlice()))
        offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
    }
    totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < itemCount; i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    for i := 0; i < itemCount; i++ {
        b.Write(s.inner[i].AsSlice())
    }

    return BytesVec{inner: b.Bytes()}
}
          

func (s *BytesVecBuilder) Set(v []Bytes) *BytesVecBuilder {
    s.inner = v
    return s
}
func (s *BytesVecBuilder) Push(v Bytes) *BytesVecBuilder {
    s.inner = append(s.inner, v)
    return s
}
func (s *BytesVecBuilder) Extend(iter []Bytes) *BytesVecBuilder {
    for i:=0; i < len(iter); i++ {
        s.inner = append(s.inner, iter[i])
    }
    return s
}
func (s *BytesVecBuilder) Replace(index uint, v Bytes) *Bytes {
    if uint(len(s.inner)) > index {
        a := s.inner[index]
        s.inner[index] = v
        return &a
    }
    return nil
}
    

func NewBytesVecBuilder() *BytesVecBuilder {
	return &BytesVecBuilder{ []Bytes{} }
}
        

type BytesVec struct {
    inner []byte
}
        

func BytesVecFromSliceUnchecked(slice []byte) *BytesVec {
    return &BytesVec{inner: slice}
}
func (s *BytesVec) AsSlice() []byte {
    return s.inner
}
            

func BytesVecDefault() BytesVec {
    return *BytesVecFromSliceUnchecked([]byte{ 4,0,0,0 })
}
            

func BytesVecFromSlice(slice []byte, compatible bool) (*BytesVec, error) {
    sliceLen := len(slice)

    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "BytesVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "BytesVec", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint {
        return &BytesVec{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "BytesVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "BytesVec", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "BytesVec", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }
    itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

    offsets := make([]uint32, itemCount)

    for i := 0; i < int(itemCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }

    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            errMsg := strings.Join([]string{"OffsetsNotMatch", "BytesVec"}, " ")
            return nil, errors.New(errMsg)
        }
    }

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 {
            start := offsets[i-1]
            end := offsets[i]
            _, err := BytesFromSlice(slice[start:end], compatible)

            if err != nil {
                return nil, err
            }
        }
    }

    return &BytesVec{inner: slice}, nil
}
            

func (s *BytesVec) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *BytesVec) ItemCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *BytesVec) Len() uint {
    return s.ItemCount()
}
func (s *BytesVec) IsEmpty() bool {
    return s.Len() == 0
}
// if *Bytes is nil, index is out of bounds
func (s *BytesVec) Get(index uint) *Bytes {
    var b *Bytes
    if index < s.Len() {
        start_index := uint(HeaderSizeUint) * (1 + index)
        start := unpackNumber(s.inner[start_index:])

        if index == s.Len()-1 {
            b = BytesFromSliceUnchecked(s.inner[start:])
        } else {
            end_index := start_index + uint(HeaderSizeUint)
            end := unpackNumber(s.inner[end_index:])
            b = BytesFromSliceUnchecked(s.inner[start:end])
        }
    }
    return b
}
            

func (s *BytesVec) AsBuilder() BytesVecBuilder {
    size := s.ItemCount()
    t := NewBytesVecBuilder()
    for i:=uint(0); i < size; i++ {
        t.Push(*s.Get(i))
    }
    return *t
}
        

type HashBuilder struct {
	inner [32]Byte
}

func NewHashBuilder() *HashBuilder {
	return &HashBuilder{inner: [32]Byte{ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault()}}
}

func (s *HashBuilder) Build() Hash {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Hash{inner: b.Bytes()}
}
        

func (s *HashBuilder) Set(v [32]Byte) *HashBuilder {
	s.inner = v
	return s
}
        

func (s *HashBuilder) Nth0(v Byte) *HashBuilder {
	s.inner[0] = v
	return s
}
                

func (s *HashBuilder) Nth1(v Byte) *HashBuilder {
	s.inner[1] = v
	return s
}
                

func (s *HashBuilder) Nth2(v Byte) *HashBuilder {
	s.inner[2] = v
	return s
}
                

func (s *HashBuilder) Nth3(v Byte) *HashBuilder {
	s.inner[3] = v
	return s
}
                

func (s *HashBuilder) Nth4(v Byte) *HashBuilder {
	s.inner[4] = v
	return s
}
                

func (s *HashBuilder) Nth5(v Byte) *HashBuilder {
	s.inner[5] = v
	return s
}
                

func (s *HashBuilder) Nth6(v Byte) *HashBuilder {
	s.inner[6] = v
	return s
}
                

func (s *HashBuilder) Nth7(v Byte) *HashBuilder {
	s.inner[7] = v
	return s
}
                

func (s *HashBuilder) Nth8(v Byte) *HashBuilder {
	s.inner[8] = v
	return s
}
                

func (s *HashBuilder) Nth9(v Byte) *HashBuilder {
	s.inner[9] = v
	return s
}
                

func (s *HashBuilder) Nth10(v Byte) *HashBuilder {
	s.inner[10] = v
	return s
}
                

func (s *HashBuilder) Nth11(v Byte) *HashBuilder {
	s.inner[11] = v
	return s
}
                

func (s *HashBuilder) Nth12(v Byte) *HashBuilder {
	s.inner[12] = v
	return s
}
                

func (s *HashBuilder) Nth13(v Byte) *HashBuilder {
	s.inner[13] = v
	return s
}
                

func (s *HashBuilder) Nth14(v Byte) *HashBuilder {
	s.inner[14] = v
	return s
}
                

func (s *HashBuilder) Nth15(v Byte) *HashBuilder {
	s.inner[15] = v
	return s
}
                

func (s *HashBuilder) Nth16(v Byte) *HashBuilder {
	s.inner[16] = v
	return s
}
                

func (s *HashBuilder) Nth17(v Byte) *HashBuilder {
	s.inner[17] = v
	return s
}
                

func (s *HashBuilder) Nth18(v Byte) *HashBuilder {
	s.inner[18] = v
	return s
}
                

func (s *HashBuilder) Nth19(v Byte) *HashBuilder {
	s.inner[19] = v
	return s
}
                

func (s *HashBuilder) Nth20(v Byte) *HashBuilder {
	s.inner[20] = v
	return s
}
                

func (s *HashBuilder) Nth21(v Byte) *HashBuilder {
	s.inner[21] = v
	return s
}
                

func (s *HashBuilder) Nth22(v Byte) *HashBuilder {
	s.inner[22] = v
	return s
}
                

func (s *HashBuilder) Nth23(v Byte) *HashBuilder {
	s.inner[23] = v
	return s
}
                

func (s *HashBuilder) Nth24(v Byte) *HashBuilder {
	s.inner[24] = v
	return s
}
                

func (s *HashBuilder) Nth25(v Byte) *HashBuilder {
	s.inner[25] = v
	return s
}
                

func (s *HashBuilder) Nth26(v Byte) *HashBuilder {
	s.inner[26] = v
	return s
}
                

func (s *HashBuilder) Nth27(v Byte) *HashBuilder {
	s.inner[27] = v
	return s
}
                

func (s *HashBuilder) Nth28(v Byte) *HashBuilder {
	s.inner[28] = v
	return s
}
                

func (s *HashBuilder) Nth29(v Byte) *HashBuilder {
	s.inner[29] = v
	return s
}
                

func (s *HashBuilder) Nth30(v Byte) *HashBuilder {
	s.inner[30] = v
	return s
}
                

func (s *HashBuilder) Nth31(v Byte) *HashBuilder {
	s.inner[31] = v
	return s
}
                

type Hash struct {
    inner []byte
}
        

func HashFromSliceUnchecked(slice []byte) *Hash {
    return &Hash{inner: slice}
}
func (s *Hash) AsSlice() []byte {
    return s.inner
}
            

func HashDefault() Hash {
    return *HashFromSliceUnchecked([]byte{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func HashFromSlice(slice []byte, _compatible bool) (*Hash, error) {
    sliceLen := len(slice)
    if sliceLen != 32 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "Hash", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(32)}, " ")
        return nil, errors.New(errMsg)
    }
    return &Hash{inner: slice}, nil
}
        

func (s *Hash) RawData() []byte {
    return s.inner
}
            

func (s *Hash) Nth0() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[0:1])
    return ret
}
            

func (s *Hash) Nth1() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[1:2])
    return ret
}
            

func (s *Hash) Nth2() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[2:3])
    return ret
}
            

func (s *Hash) Nth3() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[3:4])
    return ret
}
            

func (s *Hash) Nth4() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[4:5])
    return ret
}
            

func (s *Hash) Nth5() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[5:6])
    return ret
}
            

func (s *Hash) Nth6() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[6:7])
    return ret
}
            

func (s *Hash) Nth7() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[7:8])
    return ret
}
            

func (s *Hash) Nth8() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[8:9])
    return ret
}
            

func (s *Hash) Nth9() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[9:10])
    return ret
}
            

func (s *Hash) Nth10() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[10:11])
    return ret
}
            

func (s *Hash) Nth11() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[11:12])
    return ret
}
            

func (s *Hash) Nth12() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[12:13])
    return ret
}
            

func (s *Hash) Nth13() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[13:14])
    return ret
}
            

func (s *Hash) Nth14() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[14:15])
    return ret
}
            

func (s *Hash) Nth15() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[15:16])
    return ret
}
            

func (s *Hash) Nth16() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[16:17])
    return ret
}
            

func (s *Hash) Nth17() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[17:18])
    return ret
}
            

func (s *Hash) Nth18() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[18:19])
    return ret
}
            

func (s *Hash) Nth19() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[19:20])
    return ret
}
            

func (s *Hash) Nth20() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[20:21])
    return ret
}
            

func (s *Hash) Nth21() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[21:22])
    return ret
}
            

func (s *Hash) Nth22() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[22:23])
    return ret
}
            

func (s *Hash) Nth23() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[23:24])
    return ret
}
            

func (s *Hash) Nth24() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[24:25])
    return ret
}
            

func (s *Hash) Nth25() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[25:26])
    return ret
}
            

func (s *Hash) Nth26() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[26:27])
    return ret
}
            

func (s *Hash) Nth27() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[27:28])
    return ret
}
            

func (s *Hash) Nth28() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[28:29])
    return ret
}
            

func (s *Hash) Nth29() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[29:30])
    return ret
}
            

func (s *Hash) Nth30() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[30:31])
    return ret
}
            

func (s *Hash) Nth31() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[31:32])
    return ret
}
            

func (s *Hash) AsBuilder() HashBuilder {
	t := NewHashBuilder()
	t.Nth0(*s.Nth0())
t.Nth1(*s.Nth1())
t.Nth2(*s.Nth2())
t.Nth3(*s.Nth3())
t.Nth4(*s.Nth4())
t.Nth5(*s.Nth5())
t.Nth6(*s.Nth6())
t.Nth7(*s.Nth7())
t.Nth8(*s.Nth8())
t.Nth9(*s.Nth9())
t.Nth10(*s.Nth10())
t.Nth11(*s.Nth11())
t.Nth12(*s.Nth12())
t.Nth13(*s.Nth13())
t.Nth14(*s.Nth14())
t.Nth15(*s.Nth15())
t.Nth16(*s.Nth16())
t.Nth17(*s.Nth17())
t.Nth18(*s.Nth18())
t.Nth19(*s.Nth19())
t.Nth20(*s.Nth20())
t.Nth21(*s.Nth21())
t.Nth22(*s.Nth22())
t.Nth23(*s.Nth23())
t.Nth24(*s.Nth24())
t.Nth25(*s.Nth25())
t.Nth26(*s.Nth26())
t.Nth27(*s.Nth27())
t.Nth28(*s.Nth28())
t.Nth29(*s.Nth29())
t.Nth30(*s.Nth30())
t.Nth31(*s.Nth31())
	return *t
}
        

type ScriptBuilder struct {
    code_hash Hash
hash_type Byte
args Bytes
}
        

func (s *ScriptBuilder) Build() Script {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (3 + 1)
    offsets := make([]uint32, 0, 3)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.code_hash.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.hash_type.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.args.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.code_hash.AsSlice())
b.Write(s.hash_type.AsSlice())
b.Write(s.args.AsSlice())
    return Script{inner: b.Bytes()}
}
                

func (s *ScriptBuilder) CodeHash(v Hash) *ScriptBuilder {
    s.code_hash = v
    return s
}
            

func (s *ScriptBuilder) HashType(v Byte) *ScriptBuilder {
    s.hash_type = v
    return s
}
            

func (s *ScriptBuilder) Args(v Bytes) *ScriptBuilder {
    s.args = v
    return s
}
            

func NewScriptBuilder() *ScriptBuilder {
	return &ScriptBuilder{ code_hash: HashDefault(),hash_type: ByteDefault(),args: BytesDefault() }
}
    

type Script struct {
    inner []byte
}
        

func ScriptFromSliceUnchecked(slice []byte) *Script {
    return &Script{inner: slice}
}
func (s *Script) AsSlice() []byte {
    return s.inner
}
            

func ScriptDefault() Script {
    return *ScriptFromSliceUnchecked([]byte{ 53,0,0,0,16,0,0,0,48,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ScriptFromSlice(slice []byte, compatible bool) (*Script, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "Script", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "Script", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "Script", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "Script", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "Script", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 3 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 3 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = HashFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ByteFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

    return &Script{inner: slice}, nil
}
            

func (s *Script) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *Script) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *Script) Len() uint {
    return s.FieldCount()
}
func (s *Script) IsEmpty() bool {
    return s.Len() == 0
}
func (s *Script) CountExtraFields() uint {
    return s.FieldCount() - 3
}

func (s *Script) HasExtraFields() bool {
    return 3 != s.FieldCount()
}
            

func (s *Script) CodeHash() *Hash {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *Script) HashType() *Byte {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return ByteFromSliceUnchecked(s.inner[start:end])
}
               

func (s *Script) Args() *Bytes {
    var ret *Bytes
    start := unpackNumber(s.inner[12:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[16:])
        ret = BytesFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = BytesFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *Script) AsBuilder() ScriptBuilder {
    ret := NewScriptBuilder().CodeHash(*s.CodeHash()).HashType(*s.HashType()).Args(*s.Args())
    return *ret
}
        

type ScriptOptBuilder struct {
	isNone bool
	inner  Script
}
func NewScriptOptBuilder() *ScriptOptBuilder {
	return &ScriptOptBuilder{isNone: true, inner: ScriptDefault()}
}
func (s *ScriptOptBuilder) Set(v Script) *ScriptOptBuilder {
	s.isNone = false
	s.inner = v
	return s
}
func (s *ScriptOptBuilder) Build() ScriptOpt {
	var ret ScriptOpt
	if s.isNone {
		ret = ScriptOpt{inner: []byte{}}
	} else {
		ret = ScriptOpt{inner: s.inner.AsSlice()}
	}
	return ret
}
            

type ScriptOpt struct {
    inner []byte
}
        

func ScriptOptFromSliceUnchecked(slice []byte) *ScriptOpt {
    return &ScriptOpt{inner: slice}
}
func (s *ScriptOpt) AsSlice() []byte {
    return s.inner
}
            

func ScriptOptDefault() ScriptOpt {
    return *ScriptOptFromSliceUnchecked([]byte{  })
}
            

func ScriptOptFromSlice(slice []byte, compatible bool) (*ScriptOpt, error) {
    if len(slice) == 0 {
        return &ScriptOpt{inner: slice}, nil
    }

    _, err := ScriptFromSlice(slice, compatible)
    if err != nil {
        return nil, err
    }
    return &ScriptOpt{inner: slice}, nil
}
            

func (s *ScriptOpt) IntoScript() (*Script, error) {
	if s.IsNone() {
		return nil, errors.New("No data")
	}
	return ScriptFromSliceUnchecked(s.AsSlice()), nil
}
func (s *ScriptOpt) IsSome() bool {
    return len(s.inner) != 0
}
func (s *ScriptOpt) IsNone() bool {
    return len(s.inner) == 0
}
func (s *ScriptOpt) AsBuilder() ScriptOptBuilder {
    var ret = NewScriptOptBuilder()
    if s.IsSome() {
        ret.Set(*ScriptFromSliceUnchecked(s.AsSlice()))
    }
    return *ret
}
            

type OutPointBuilder struct {
    tx_hash Hash
index Uint32
}
        

func (s *OutPointBuilder) Build() OutPoint {
    b := new(bytes.Buffer)
    b.Write(s.tx_hash.AsSlice())
b.Write(s.index.AsSlice())
    return OutPoint{inner: b.Bytes()}
}
            

func (s *OutPointBuilder) TxHash(v Hash) *OutPointBuilder {
    s.tx_hash = v
    return s
}
            

func (s *OutPointBuilder) Index(v Uint32) *OutPointBuilder {
    s.index = v
    return s
}
            

func NewOutPointBuilder() *OutPointBuilder {
	return &OutPointBuilder{ tx_hash: HashDefault(),index: Uint32Default() }
}
    

type OutPoint struct {
    inner []byte
}
        

func OutPointFromSliceUnchecked(slice []byte) *OutPoint {
    return &OutPoint{inner: slice}
}
func (s *OutPoint) AsSlice() []byte {
    return s.inner
}
            

func OutPointDefault() OutPoint {
    return *OutPointFromSliceUnchecked([]byte{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func OutPointFromSlice(slice []byte, _compatible bool) (*OutPoint, error) {
    sliceLen := len(slice)
    if sliceLen != 36 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "OutPoint", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(36)}, " ")
        return nil, errors.New(errMsg)
    }
    return &OutPoint{inner: slice}, nil
}
        

func (s *OutPoint) TxHash() *Hash {
    ret := HashFromSliceUnchecked(s.inner[0:32])
    return ret
}
                

func (s *OutPoint) Index() *Uint32 {
    ret := Uint32FromSliceUnchecked(s.inner[32:36])
    return ret
}
                

func (s *OutPoint) AsBuilder() OutPointBuilder {
    ret := NewOutPointBuilder().TxHash(*s.TxHash()).Index(*s.Index())
    return *ret
}
        

type DataBuilder struct {
    dep DataEntityOpt
old DataEntityOpt
new DataEntityOpt
}
        

func (s *DataBuilder) Build() Data {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (3 + 1)
    offsets := make([]uint32, 0, 3)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.dep.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.old.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.new.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.dep.AsSlice())
b.Write(s.old.AsSlice())
b.Write(s.new.AsSlice())
    return Data{inner: b.Bytes()}
}
                

func (s *DataBuilder) Dep(v DataEntityOpt) *DataBuilder {
    s.dep = v
    return s
}
            

func (s *DataBuilder) Old(v DataEntityOpt) *DataBuilder {
    s.old = v
    return s
}
            

func (s *DataBuilder) New(v DataEntityOpt) *DataBuilder {
    s.new = v
    return s
}
            

func NewDataBuilder() *DataBuilder {
	return &DataBuilder{ dep: DataEntityOptDefault(),old: DataEntityOptDefault(),new: DataEntityOptDefault() }
}
    

type Data struct {
    inner []byte
}
        

func DataFromSliceUnchecked(slice []byte) *Data {
    return &Data{inner: slice}
}
func (s *Data) AsSlice() []byte {
    return s.inner
}
            

func DataDefault() Data {
    return *DataFromSliceUnchecked([]byte{ 16,0,0,0,16,0,0,0,16,0,0,0,16,0,0,0 })
}
            

func DataFromSlice(slice []byte, compatible bool) (*Data, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "Data", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "Data", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "Data", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "Data", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "Data", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 3 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 3 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = DataEntityOptFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = DataEntityOptFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = DataEntityOptFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

    return &Data{inner: slice}, nil
}
            

func (s *Data) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *Data) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *Data) Len() uint {
    return s.FieldCount()
}
func (s *Data) IsEmpty() bool {
    return s.Len() == 0
}
func (s *Data) CountExtraFields() uint {
    return s.FieldCount() - 3
}

func (s *Data) HasExtraFields() bool {
    return 3 != s.FieldCount()
}
            

func (s *Data) Dep() *DataEntityOpt {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return DataEntityOptFromSliceUnchecked(s.inner[start:end])
}
               

func (s *Data) Old() *DataEntityOpt {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return DataEntityOptFromSliceUnchecked(s.inner[start:end])
}
               

func (s *Data) New() *DataEntityOpt {
    var ret *DataEntityOpt
    start := unpackNumber(s.inner[12:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[16:])
        ret = DataEntityOptFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = DataEntityOptFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *Data) AsBuilder() DataBuilder {
    ret := NewDataBuilder().Dep(*s.Dep()).Old(*s.Old()).New(*s.New())
    return *ret
}
        

type DataEntityBuilder struct {
    index Uint32
version Uint32
entity Bytes
}
        

func (s *DataEntityBuilder) Build() DataEntity {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (3 + 1)
    offsets := make([]uint32, 0, 3)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.index.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.version.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.entity.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.index.AsSlice())
b.Write(s.version.AsSlice())
b.Write(s.entity.AsSlice())
    return DataEntity{inner: b.Bytes()}
}
                

func (s *DataEntityBuilder) Index(v Uint32) *DataEntityBuilder {
    s.index = v
    return s
}
            

func (s *DataEntityBuilder) Version(v Uint32) *DataEntityBuilder {
    s.version = v
    return s
}
            

func (s *DataEntityBuilder) Entity(v Bytes) *DataEntityBuilder {
    s.entity = v
    return s
}
            

func NewDataEntityBuilder() *DataEntityBuilder {
	return &DataEntityBuilder{ index: Uint32Default(),version: Uint32Default(),entity: BytesDefault() }
}
    

type DataEntity struct {
    inner []byte
}
        

func DataEntityFromSliceUnchecked(slice []byte) *DataEntity {
    return &DataEntity{inner: slice}
}
func (s *DataEntity) AsSlice() []byte {
    return s.inner
}
            

func DataEntityDefault() DataEntity {
    return *DataEntityFromSliceUnchecked([]byte{ 28,0,0,0,16,0,0,0,20,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func DataEntityFromSlice(slice []byte, compatible bool) (*DataEntity, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "DataEntity", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "DataEntity", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "DataEntity", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "DataEntity", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "DataEntity", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 3 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 3 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

    return &DataEntity{inner: slice}, nil
}
            

func (s *DataEntity) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *DataEntity) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *DataEntity) Len() uint {
    return s.FieldCount()
}
func (s *DataEntity) IsEmpty() bool {
    return s.Len() == 0
}
func (s *DataEntity) CountExtraFields() uint {
    return s.FieldCount() - 3
}

func (s *DataEntity) HasExtraFields() bool {
    return 3 != s.FieldCount()
}
            

func (s *DataEntity) Index() *Uint32 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *DataEntity) Version() *Uint32 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *DataEntity) Entity() *Bytes {
    var ret *Bytes
    start := unpackNumber(s.inner[12:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[16:])
        ret = BytesFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = BytesFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *DataEntity) AsBuilder() DataEntityBuilder {
    ret := NewDataEntityBuilder().Index(*s.Index()).Version(*s.Version()).Entity(*s.Entity())
    return *ret
}
        

type DataEntityOptBuilder struct {
	isNone bool
	inner  DataEntity
}
func NewDataEntityOptBuilder() *DataEntityOptBuilder {
	return &DataEntityOptBuilder{isNone: true, inner: DataEntityDefault()}
}
func (s *DataEntityOptBuilder) Set(v DataEntity) *DataEntityOptBuilder {
	s.isNone = false
	s.inner = v
	return s
}
func (s *DataEntityOptBuilder) Build() DataEntityOpt {
	var ret DataEntityOpt
	if s.isNone {
		ret = DataEntityOpt{inner: []byte{}}
	} else {
		ret = DataEntityOpt{inner: s.inner.AsSlice()}
	}
	return ret
}
            

type DataEntityOpt struct {
    inner []byte
}
        

func DataEntityOptFromSliceUnchecked(slice []byte) *DataEntityOpt {
    return &DataEntityOpt{inner: slice}
}
func (s *DataEntityOpt) AsSlice() []byte {
    return s.inner
}
            

func DataEntityOptDefault() DataEntityOpt {
    return *DataEntityOptFromSliceUnchecked([]byte{  })
}
            

func DataEntityOptFromSlice(slice []byte, compatible bool) (*DataEntityOpt, error) {
    if len(slice) == 0 {
        return &DataEntityOpt{inner: slice}, nil
    }

    _, err := DataEntityFromSlice(slice, compatible)
    if err != nil {
        return nil, err
    }
    return &DataEntityOpt{inner: slice}, nil
}
            

func (s *DataEntityOpt) IntoDataEntity() (*DataEntity, error) {
	if s.IsNone() {
		return nil, errors.New("No data")
	}
	return DataEntityFromSliceUnchecked(s.AsSlice()), nil
}
func (s *DataEntityOpt) IsSome() bool {
    return len(s.inner) != 0
}
func (s *DataEntityOpt) IsNone() bool {
    return len(s.inner) == 0
}
func (s *DataEntityOpt) AsBuilder() DataEntityOptBuilder {
    var ret = NewDataEntityOptBuilder()
    if s.IsSome() {
        ret.Set(*DataEntityFromSliceUnchecked(s.AsSlice()))
    }
    return *ret
}
            
