// Generated by Molecule 0.7.5
// Generated by Moleculec-Go 0.1.11

package cell
import (
    "bytes"
    "encoding/binary"
    "errors"
    "strconv"
    "strings"
       )

type ActionDataBuilder struct {
    action Bytes
params Bytes
}
        

func (s *ActionDataBuilder) Build() ActionData {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (2 + 1)
    offsets := make([]uint32, 0, 2)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.action.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.params.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.action.AsSlice())
b.Write(s.params.AsSlice())
    return ActionData{inner: b.Bytes()}
}
                

func (s *ActionDataBuilder) Action(v Bytes) *ActionDataBuilder {
    s.action = v
    return s
}
            

func (s *ActionDataBuilder) Params(v Bytes) *ActionDataBuilder {
    s.params = v
    return s
}
            

func NewActionDataBuilder() *ActionDataBuilder {
	return &ActionDataBuilder{ action: BytesDefault(),params: BytesDefault() }
}
    

type ActionData struct {
    inner []byte
}
        

func ActionDataFromSliceUnchecked(slice []byte) *ActionData {
    return &ActionData{inner: slice}
}
func (s *ActionData) AsSlice() []byte {
    return s.inner
}
            

func ActionDataDefault() ActionData {
    return *ActionDataFromSliceUnchecked([]byte{ 20,0,0,0,12,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ActionDataFromSlice(slice []byte, compatible bool) (*ActionData, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ActionData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ActionData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ActionData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ActionData", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ActionData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 2 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 2 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = BytesFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

    return &ActionData{inner: slice}, nil
}
            

func (s *ActionData) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ActionData) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ActionData) Len() uint {
    return s.FieldCount()
}
func (s *ActionData) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ActionData) CountExtraFields() uint {
    return s.FieldCount() - 2
}

func (s *ActionData) HasExtraFields() bool {
    return 2 != s.FieldCount()
}
            

func (s *ActionData) Action() *Bytes {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ActionData) Params() *Bytes {
    var ret *Bytes
    start := unpackNumber(s.inner[8:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[12:])
        ret = BytesFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = BytesFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ActionData) AsBuilder() ActionDataBuilder {
    ret := NewActionDataBuilder().Action(*s.Action()).Params(*s.Params())
    return *ret
}
        

type ConfigCellMainBuilder struct {
    status Uint8
type_id_table TypeIdTable
das_lock_out_point_table DasLockOutPointTable
das_lock_type_id_table DasLockTypeIdTable
}
        

func (s *ConfigCellMainBuilder) Build() ConfigCellMain {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (4 + 1)
    offsets := make([]uint32, 0, 4)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.status.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.type_id_table.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.das_lock_out_point_table.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.das_lock_type_id_table.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.status.AsSlice())
b.Write(s.type_id_table.AsSlice())
b.Write(s.das_lock_out_point_table.AsSlice())
b.Write(s.das_lock_type_id_table.AsSlice())
    return ConfigCellMain{inner: b.Bytes()}
}
                

func (s *ConfigCellMainBuilder) Status(v Uint8) *ConfigCellMainBuilder {
    s.status = v
    return s
}
            

func (s *ConfigCellMainBuilder) TypeIdTable(v TypeIdTable) *ConfigCellMainBuilder {
    s.type_id_table = v
    return s
}
            

func (s *ConfigCellMainBuilder) DasLockOutPointTable(v DasLockOutPointTable) *ConfigCellMainBuilder {
    s.das_lock_out_point_table = v
    return s
}
            

func (s *ConfigCellMainBuilder) DasLockTypeIdTable(v DasLockTypeIdTable) *ConfigCellMainBuilder {
    s.das_lock_type_id_table = v
    return s
}
            

func NewConfigCellMainBuilder() *ConfigCellMainBuilder {
	return &ConfigCellMainBuilder{ status: Uint8Default(),type_id_table: TypeIdTableDefault(),das_lock_out_point_table: DasLockOutPointTableDefault(),das_lock_type_id_table: DasLockTypeIdTableDefault() }
}
    

type ConfigCellMain struct {
    inner []byte
}
        

func ConfigCellMainFromSliceUnchecked(slice []byte) *ConfigCellMain {
    return &ConfigCellMain{inner: slice}
}
func (s *ConfigCellMain) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellMainDefault() ConfigCellMain {
    return *ConfigCellMainFromSliceUnchecked([]byte{ 45,4,0,0,20,0,0,0,21,0,0,0,17,2,0,0,45,3,0,0,0,252,1,0,0,60,0,0,0,92,0,0,0,124,0,0,0,156,0,0,0,188,0,0,0,220,0,0,0,252,0,0,0,28,1,0,0,60,1,0,0,92,1,0,0,124,1,0,0,156,1,0,0,188,1,0,0,220,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,1,0,0,32,0,0,0,68,0,0,0,104,0,0,0,140,0,0,0,176,0,0,0,212,0,0,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,32,0,0,0,64,0,0,0,96,0,0,0,128,0,0,0,160,0,0,0,192,0,0,0,224,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellMainFromSlice(slice []byte, compatible bool) (*ConfigCellMain, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMain", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMain", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellMain", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellMain", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellMain", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 4 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 4 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = TypeIdTableFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = DasLockOutPointTableFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = DasLockTypeIdTableFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellMain{inner: slice}, nil
}
            

func (s *ConfigCellMain) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellMain) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellMain) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellMain) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellMain) CountExtraFields() uint {
    return s.FieldCount() - 4
}

func (s *ConfigCellMain) HasExtraFields() bool {
    return 4 != s.FieldCount()
}
            

func (s *ConfigCellMain) Status() *Uint8 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellMain) TypeIdTable() *TypeIdTable {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return TypeIdTableFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellMain) DasLockOutPointTable() *DasLockOutPointTable {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return DasLockOutPointTableFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellMain) DasLockTypeIdTable() *DasLockTypeIdTable {
    var ret *DasLockTypeIdTable
    start := unpackNumber(s.inner[16:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[20:])
        ret = DasLockTypeIdTableFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = DasLockTypeIdTableFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellMain) AsBuilder() ConfigCellMainBuilder {
    ret := NewConfigCellMainBuilder().Status(*s.Status()).TypeIdTable(*s.TypeIdTable()).DasLockOutPointTable(*s.DasLockOutPointTable()).DasLockTypeIdTable(*s.DasLockTypeIdTable())
    return *ret
}
        

type TypeIdTableBuilder struct {
    account_cell Hash
apply_register_cell Hash
balance_cell Hash
income_cell Hash
pre_account_cell Hash
proposal_cell Hash
account_sale_cell Hash
account_auction_cell Hash
offer_cell Hash
reverse_record_cell Hash
sub_account_cell Hash
eip712_lib Hash
reverse_record_root_cell Hash
key_list_config_cell Hash
}
        

func (s *TypeIdTableBuilder) Build() TypeIdTable {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (14 + 1)
    offsets := make([]uint32, 0, 14)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.apply_register_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.balance_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.income_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.pre_account_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_sale_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_auction_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.offer_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.reverse_record_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.sub_account_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.eip712_lib.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.reverse_record_root_cell.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.key_list_config_cell.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.account_cell.AsSlice())
b.Write(s.apply_register_cell.AsSlice())
b.Write(s.balance_cell.AsSlice())
b.Write(s.income_cell.AsSlice())
b.Write(s.pre_account_cell.AsSlice())
b.Write(s.proposal_cell.AsSlice())
b.Write(s.account_sale_cell.AsSlice())
b.Write(s.account_auction_cell.AsSlice())
b.Write(s.offer_cell.AsSlice())
b.Write(s.reverse_record_cell.AsSlice())
b.Write(s.sub_account_cell.AsSlice())
b.Write(s.eip712_lib.AsSlice())
b.Write(s.reverse_record_root_cell.AsSlice())
b.Write(s.key_list_config_cell.AsSlice())
    return TypeIdTable{inner: b.Bytes()}
}
                

func (s *TypeIdTableBuilder) AccountCell(v Hash) *TypeIdTableBuilder {
    s.account_cell = v
    return s
}
            

func (s *TypeIdTableBuilder) ApplyRegisterCell(v Hash) *TypeIdTableBuilder {
    s.apply_register_cell = v
    return s
}
            

func (s *TypeIdTableBuilder) BalanceCell(v Hash) *TypeIdTableBuilder {
    s.balance_cell = v
    return s
}
            

func (s *TypeIdTableBuilder) IncomeCell(v Hash) *TypeIdTableBuilder {
    s.income_cell = v
    return s
}
            

func (s *TypeIdTableBuilder) PreAccountCell(v Hash) *TypeIdTableBuilder {
    s.pre_account_cell = v
    return s
}
            

func (s *TypeIdTableBuilder) ProposalCell(v Hash) *TypeIdTableBuilder {
    s.proposal_cell = v
    return s
}
            

func (s *TypeIdTableBuilder) AccountSaleCell(v Hash) *TypeIdTableBuilder {
    s.account_sale_cell = v
    return s
}
            

func (s *TypeIdTableBuilder) AccountAuctionCell(v Hash) *TypeIdTableBuilder {
    s.account_auction_cell = v
    return s
}
            

func (s *TypeIdTableBuilder) OfferCell(v Hash) *TypeIdTableBuilder {
    s.offer_cell = v
    return s
}
            

func (s *TypeIdTableBuilder) ReverseRecordCell(v Hash) *TypeIdTableBuilder {
    s.reverse_record_cell = v
    return s
}
            

func (s *TypeIdTableBuilder) SubAccountCell(v Hash) *TypeIdTableBuilder {
    s.sub_account_cell = v
    return s
}
            

func (s *TypeIdTableBuilder) Eip712Lib(v Hash) *TypeIdTableBuilder {
    s.eip712_lib = v
    return s
}
            

func (s *TypeIdTableBuilder) ReverseRecordRootCell(v Hash) *TypeIdTableBuilder {
    s.reverse_record_root_cell = v
    return s
}
            

func (s *TypeIdTableBuilder) KeyListConfigCell(v Hash) *TypeIdTableBuilder {
    s.key_list_config_cell = v
    return s
}
            

func NewTypeIdTableBuilder() *TypeIdTableBuilder {
	return &TypeIdTableBuilder{ account_cell: HashDefault(),apply_register_cell: HashDefault(),balance_cell: HashDefault(),income_cell: HashDefault(),pre_account_cell: HashDefault(),proposal_cell: HashDefault(),account_sale_cell: HashDefault(),account_auction_cell: HashDefault(),offer_cell: HashDefault(),reverse_record_cell: HashDefault(),sub_account_cell: HashDefault(),eip712_lib: HashDefault(),reverse_record_root_cell: HashDefault(),key_list_config_cell: HashDefault() }
}
    

type TypeIdTable struct {
    inner []byte
}
        

func TypeIdTableFromSliceUnchecked(slice []byte) *TypeIdTable {
    return &TypeIdTable{inner: slice}
}
func (s *TypeIdTable) AsSlice() []byte {
    return s.inner
}
            

func TypeIdTableDefault() TypeIdTable {
    return *TypeIdTableFromSliceUnchecked([]byte{ 252,1,0,0,60,0,0,0,92,0,0,0,124,0,0,0,156,0,0,0,188,0,0,0,220,0,0,0,252,0,0,0,28,1,0,0,60,1,0,0,92,1,0,0,124,1,0,0,156,1,0,0,188,1,0,0,220,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func TypeIdTableFromSlice(slice []byte, compatible bool) (*TypeIdTable, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTable", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "TypeIdTable", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 14 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 14 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = HashFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[8]:offsets[9]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[9]:offsets[10]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[10]:offsets[11]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[11]:offsets[12]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[12]:offsets[13]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[13]:offsets[14]], compatible)
if err != nil {
    return nil, err
}
                

    return &TypeIdTable{inner: slice}, nil
}
            

func (s *TypeIdTable) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *TypeIdTable) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *TypeIdTable) Len() uint {
    return s.FieldCount()
}
func (s *TypeIdTable) IsEmpty() bool {
    return s.Len() == 0
}
func (s *TypeIdTable) CountExtraFields() uint {
    return s.FieldCount() - 14
}

func (s *TypeIdTable) HasExtraFields() bool {
    return 14 != s.FieldCount()
}
            

func (s *TypeIdTable) AccountCell() *Hash {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTable) ApplyRegisterCell() *Hash {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTable) BalanceCell() *Hash {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTable) IncomeCell() *Hash {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTable) PreAccountCell() *Hash {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTable) ProposalCell() *Hash {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTable) AccountSaleCell() *Hash {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTable) AccountAuctionCell() *Hash {
    start := unpackNumber(s.inner[32:])
    end := unpackNumber(s.inner[36:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTable) OfferCell() *Hash {
    start := unpackNumber(s.inner[36:])
    end := unpackNumber(s.inner[40:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTable) ReverseRecordCell() *Hash {
    start := unpackNumber(s.inner[40:])
    end := unpackNumber(s.inner[44:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTable) SubAccountCell() *Hash {
    start := unpackNumber(s.inner[44:])
    end := unpackNumber(s.inner[48:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTable) Eip712Lib() *Hash {
    start := unpackNumber(s.inner[48:])
    end := unpackNumber(s.inner[52:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTable) ReverseRecordRootCell() *Hash {
    start := unpackNumber(s.inner[52:])
    end := unpackNumber(s.inner[56:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *TypeIdTable) KeyListConfigCell() *Hash {
    var ret *Hash
    start := unpackNumber(s.inner[56:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[60:])
        ret = HashFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = HashFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *TypeIdTable) AsBuilder() TypeIdTableBuilder {
    ret := NewTypeIdTableBuilder().AccountCell(*s.AccountCell()).ApplyRegisterCell(*s.ApplyRegisterCell()).BalanceCell(*s.BalanceCell()).IncomeCell(*s.IncomeCell()).PreAccountCell(*s.PreAccountCell()).ProposalCell(*s.ProposalCell()).AccountSaleCell(*s.AccountSaleCell()).AccountAuctionCell(*s.AccountAuctionCell()).OfferCell(*s.OfferCell()).ReverseRecordCell(*s.ReverseRecordCell()).SubAccountCell(*s.SubAccountCell()).Eip712Lib(*s.Eip712Lib()).ReverseRecordRootCell(*s.ReverseRecordRootCell()).KeyListConfigCell(*s.KeyListConfigCell())
    return *ret
}
        

type DasLockOutPointTableBuilder struct {
    ckb_signall OutPoint
ckb_multisign OutPoint
ckb_anyone_can_pay OutPoint
eth OutPoint
tron OutPoint
ed25519 OutPoint
web_authn OutPoint
}
        

func (s *DasLockOutPointTableBuilder) Build() DasLockOutPointTable {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (7 + 1)
    offsets := make([]uint32, 0, 7)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.ckb_signall.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.ckb_multisign.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.ckb_anyone_can_pay.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.eth.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.tron.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.ed25519.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.web_authn.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.ckb_signall.AsSlice())
b.Write(s.ckb_multisign.AsSlice())
b.Write(s.ckb_anyone_can_pay.AsSlice())
b.Write(s.eth.AsSlice())
b.Write(s.tron.AsSlice())
b.Write(s.ed25519.AsSlice())
b.Write(s.web_authn.AsSlice())
    return DasLockOutPointTable{inner: b.Bytes()}
}
                

func (s *DasLockOutPointTableBuilder) CkbSignall(v OutPoint) *DasLockOutPointTableBuilder {
    s.ckb_signall = v
    return s
}
            

func (s *DasLockOutPointTableBuilder) CkbMultisign(v OutPoint) *DasLockOutPointTableBuilder {
    s.ckb_multisign = v
    return s
}
            

func (s *DasLockOutPointTableBuilder) CkbAnyoneCanPay(v OutPoint) *DasLockOutPointTableBuilder {
    s.ckb_anyone_can_pay = v
    return s
}
            

func (s *DasLockOutPointTableBuilder) Eth(v OutPoint) *DasLockOutPointTableBuilder {
    s.eth = v
    return s
}
            

func (s *DasLockOutPointTableBuilder) Tron(v OutPoint) *DasLockOutPointTableBuilder {
    s.tron = v
    return s
}
            

func (s *DasLockOutPointTableBuilder) Ed25519(v OutPoint) *DasLockOutPointTableBuilder {
    s.ed25519 = v
    return s
}
            

func (s *DasLockOutPointTableBuilder) WebAuthn(v OutPoint) *DasLockOutPointTableBuilder {
    s.web_authn = v
    return s
}
            

func NewDasLockOutPointTableBuilder() *DasLockOutPointTableBuilder {
	return &DasLockOutPointTableBuilder{ ckb_signall: OutPointDefault(),ckb_multisign: OutPointDefault(),ckb_anyone_can_pay: OutPointDefault(),eth: OutPointDefault(),tron: OutPointDefault(),ed25519: OutPointDefault(),web_authn: OutPointDefault() }
}
    

type DasLockOutPointTable struct {
    inner []byte
}
        

func DasLockOutPointTableFromSliceUnchecked(slice []byte) *DasLockOutPointTable {
    return &DasLockOutPointTable{inner: slice}
}
func (s *DasLockOutPointTable) AsSlice() []byte {
    return s.inner
}
            

func DasLockOutPointTableDefault() DasLockOutPointTable {
    return *DasLockOutPointTableFromSliceUnchecked([]byte{ 28,1,0,0,32,0,0,0,68,0,0,0,104,0,0,0,140,0,0,0,176,0,0,0,212,0,0,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func DasLockOutPointTableFromSlice(slice []byte, compatible bool) (*DasLockOutPointTable, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "DasLockOutPointTable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "DasLockOutPointTable", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "DasLockOutPointTable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "DasLockOutPointTable", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "DasLockOutPointTable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 7 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 7 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = OutPointFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = OutPointFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = OutPointFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = OutPointFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = OutPointFromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = OutPointFromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = OutPointFromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

    return &DasLockOutPointTable{inner: slice}, nil
}
            

func (s *DasLockOutPointTable) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *DasLockOutPointTable) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *DasLockOutPointTable) Len() uint {
    return s.FieldCount()
}
func (s *DasLockOutPointTable) IsEmpty() bool {
    return s.Len() == 0
}
func (s *DasLockOutPointTable) CountExtraFields() uint {
    return s.FieldCount() - 7
}

func (s *DasLockOutPointTable) HasExtraFields() bool {
    return 7 != s.FieldCount()
}
            

func (s *DasLockOutPointTable) CkbSignall() *OutPoint {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return OutPointFromSliceUnchecked(s.inner[start:end])
}
               

func (s *DasLockOutPointTable) CkbMultisign() *OutPoint {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return OutPointFromSliceUnchecked(s.inner[start:end])
}
               

func (s *DasLockOutPointTable) CkbAnyoneCanPay() *OutPoint {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return OutPointFromSliceUnchecked(s.inner[start:end])
}
               

func (s *DasLockOutPointTable) Eth() *OutPoint {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return OutPointFromSliceUnchecked(s.inner[start:end])
}
               

func (s *DasLockOutPointTable) Tron() *OutPoint {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return OutPointFromSliceUnchecked(s.inner[start:end])
}
               

func (s *DasLockOutPointTable) Ed25519() *OutPoint {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return OutPointFromSliceUnchecked(s.inner[start:end])
}
               

func (s *DasLockOutPointTable) WebAuthn() *OutPoint {
    var ret *OutPoint
    start := unpackNumber(s.inner[28:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[32:])
        ret = OutPointFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = OutPointFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *DasLockOutPointTable) AsBuilder() DasLockOutPointTableBuilder {
    ret := NewDasLockOutPointTableBuilder().CkbSignall(*s.CkbSignall()).CkbMultisign(*s.CkbMultisign()).CkbAnyoneCanPay(*s.CkbAnyoneCanPay()).Eth(*s.Eth()).Tron(*s.Tron()).Ed25519(*s.Ed25519()).WebAuthn(*s.WebAuthn())
    return *ret
}
        

type DasLockTypeIdTableBuilder struct {
    ckb_signhash Hash
ckb_multisig Hash
ed25519 Hash
eth Hash
tron Hash
doge Hash
web_authn Hash
}
        

func (s *DasLockTypeIdTableBuilder) Build() DasLockTypeIdTable {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (7 + 1)
    offsets := make([]uint32, 0, 7)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.ckb_signhash.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.ckb_multisig.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.ed25519.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.eth.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.tron.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.doge.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.web_authn.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.ckb_signhash.AsSlice())
b.Write(s.ckb_multisig.AsSlice())
b.Write(s.ed25519.AsSlice())
b.Write(s.eth.AsSlice())
b.Write(s.tron.AsSlice())
b.Write(s.doge.AsSlice())
b.Write(s.web_authn.AsSlice())
    return DasLockTypeIdTable{inner: b.Bytes()}
}
                

func (s *DasLockTypeIdTableBuilder) CkbSignhash(v Hash) *DasLockTypeIdTableBuilder {
    s.ckb_signhash = v
    return s
}
            

func (s *DasLockTypeIdTableBuilder) CkbMultisig(v Hash) *DasLockTypeIdTableBuilder {
    s.ckb_multisig = v
    return s
}
            

func (s *DasLockTypeIdTableBuilder) Ed25519(v Hash) *DasLockTypeIdTableBuilder {
    s.ed25519 = v
    return s
}
            

func (s *DasLockTypeIdTableBuilder) Eth(v Hash) *DasLockTypeIdTableBuilder {
    s.eth = v
    return s
}
            

func (s *DasLockTypeIdTableBuilder) Tron(v Hash) *DasLockTypeIdTableBuilder {
    s.tron = v
    return s
}
            

func (s *DasLockTypeIdTableBuilder) Doge(v Hash) *DasLockTypeIdTableBuilder {
    s.doge = v
    return s
}
            

func (s *DasLockTypeIdTableBuilder) WebAuthn(v Hash) *DasLockTypeIdTableBuilder {
    s.web_authn = v
    return s
}
            

func NewDasLockTypeIdTableBuilder() *DasLockTypeIdTableBuilder {
	return &DasLockTypeIdTableBuilder{ ckb_signhash: HashDefault(),ckb_multisig: HashDefault(),ed25519: HashDefault(),eth: HashDefault(),tron: HashDefault(),doge: HashDefault(),web_authn: HashDefault() }
}
    

type DasLockTypeIdTable struct {
    inner []byte
}
        

func DasLockTypeIdTableFromSliceUnchecked(slice []byte) *DasLockTypeIdTable {
    return &DasLockTypeIdTable{inner: slice}
}
func (s *DasLockTypeIdTable) AsSlice() []byte {
    return s.inner
}
            

func DasLockTypeIdTableDefault() DasLockTypeIdTable {
    return *DasLockTypeIdTableFromSliceUnchecked([]byte{ 0,1,0,0,32,0,0,0,64,0,0,0,96,0,0,0,128,0,0,0,160,0,0,0,192,0,0,0,224,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func DasLockTypeIdTableFromSlice(slice []byte, compatible bool) (*DasLockTypeIdTable, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "DasLockTypeIdTable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "DasLockTypeIdTable", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "DasLockTypeIdTable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "DasLockTypeIdTable", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "DasLockTypeIdTable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 7 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 7 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = HashFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = HashFromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

    return &DasLockTypeIdTable{inner: slice}, nil
}
            

func (s *DasLockTypeIdTable) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *DasLockTypeIdTable) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *DasLockTypeIdTable) Len() uint {
    return s.FieldCount()
}
func (s *DasLockTypeIdTable) IsEmpty() bool {
    return s.Len() == 0
}
func (s *DasLockTypeIdTable) CountExtraFields() uint {
    return s.FieldCount() - 7
}

func (s *DasLockTypeIdTable) HasExtraFields() bool {
    return 7 != s.FieldCount()
}
            

func (s *DasLockTypeIdTable) CkbSignhash() *Hash {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *DasLockTypeIdTable) CkbMultisig() *Hash {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *DasLockTypeIdTable) Ed25519() *Hash {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *DasLockTypeIdTable) Eth() *Hash {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *DasLockTypeIdTable) Tron() *Hash {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *DasLockTypeIdTable) Doge() *Hash {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return HashFromSliceUnchecked(s.inner[start:end])
}
               

func (s *DasLockTypeIdTable) WebAuthn() *Hash {
    var ret *Hash
    start := unpackNumber(s.inner[28:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[32:])
        ret = HashFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = HashFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *DasLockTypeIdTable) AsBuilder() DasLockTypeIdTableBuilder {
    ret := NewDasLockTypeIdTableBuilder().CkbSignhash(*s.CkbSignhash()).CkbMultisig(*s.CkbMultisig()).Ed25519(*s.Ed25519()).Eth(*s.Eth()).Tron(*s.Tron()).Doge(*s.Doge()).WebAuthn(*s.WebAuthn())
    return *ret
}
        

type ConfigCellAccountBuilder struct {
    max_length Uint32
basic_capacity Uint64
prepared_fee_capacity Uint64
expiration_grace_period Uint32
record_min_ttl Uint32
record_size_limit Uint32
transfer_account_fee Uint64
edit_manager_fee Uint64
edit_records_fee Uint64
common_fee Uint64
transfer_account_throttle Uint32
edit_manager_throttle Uint32
edit_records_throttle Uint32
common_throttle Uint32
}
        

func (s *ConfigCellAccountBuilder) Build() ConfigCellAccount {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (14 + 1)
    offsets := make([]uint32, 0, 14)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.max_length.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.basic_capacity.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.prepared_fee_capacity.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.expiration_grace_period.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.record_min_ttl.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.record_size_limit.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.transfer_account_fee.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.edit_manager_fee.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.edit_records_fee.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.common_fee.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.transfer_account_throttle.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.edit_manager_throttle.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.edit_records_throttle.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.common_throttle.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.max_length.AsSlice())
b.Write(s.basic_capacity.AsSlice())
b.Write(s.prepared_fee_capacity.AsSlice())
b.Write(s.expiration_grace_period.AsSlice())
b.Write(s.record_min_ttl.AsSlice())
b.Write(s.record_size_limit.AsSlice())
b.Write(s.transfer_account_fee.AsSlice())
b.Write(s.edit_manager_fee.AsSlice())
b.Write(s.edit_records_fee.AsSlice())
b.Write(s.common_fee.AsSlice())
b.Write(s.transfer_account_throttle.AsSlice())
b.Write(s.edit_manager_throttle.AsSlice())
b.Write(s.edit_records_throttle.AsSlice())
b.Write(s.common_throttle.AsSlice())
    return ConfigCellAccount{inner: b.Bytes()}
}
                

func (s *ConfigCellAccountBuilder) MaxLength(v Uint32) *ConfigCellAccountBuilder {
    s.max_length = v
    return s
}
            

func (s *ConfigCellAccountBuilder) BasicCapacity(v Uint64) *ConfigCellAccountBuilder {
    s.basic_capacity = v
    return s
}
            

func (s *ConfigCellAccountBuilder) PreparedFeeCapacity(v Uint64) *ConfigCellAccountBuilder {
    s.prepared_fee_capacity = v
    return s
}
            

func (s *ConfigCellAccountBuilder) ExpirationGracePeriod(v Uint32) *ConfigCellAccountBuilder {
    s.expiration_grace_period = v
    return s
}
            

func (s *ConfigCellAccountBuilder) RecordMinTtl(v Uint32) *ConfigCellAccountBuilder {
    s.record_min_ttl = v
    return s
}
            

func (s *ConfigCellAccountBuilder) RecordSizeLimit(v Uint32) *ConfigCellAccountBuilder {
    s.record_size_limit = v
    return s
}
            

func (s *ConfigCellAccountBuilder) TransferAccountFee(v Uint64) *ConfigCellAccountBuilder {
    s.transfer_account_fee = v
    return s
}
            

func (s *ConfigCellAccountBuilder) EditManagerFee(v Uint64) *ConfigCellAccountBuilder {
    s.edit_manager_fee = v
    return s
}
            

func (s *ConfigCellAccountBuilder) EditRecordsFee(v Uint64) *ConfigCellAccountBuilder {
    s.edit_records_fee = v
    return s
}
            

func (s *ConfigCellAccountBuilder) CommonFee(v Uint64) *ConfigCellAccountBuilder {
    s.common_fee = v
    return s
}
            

func (s *ConfigCellAccountBuilder) TransferAccountThrottle(v Uint32) *ConfigCellAccountBuilder {
    s.transfer_account_throttle = v
    return s
}
            

func (s *ConfigCellAccountBuilder) EditManagerThrottle(v Uint32) *ConfigCellAccountBuilder {
    s.edit_manager_throttle = v
    return s
}
            

func (s *ConfigCellAccountBuilder) EditRecordsThrottle(v Uint32) *ConfigCellAccountBuilder {
    s.edit_records_throttle = v
    return s
}
            

func (s *ConfigCellAccountBuilder) CommonThrottle(v Uint32) *ConfigCellAccountBuilder {
    s.common_throttle = v
    return s
}
            

func NewConfigCellAccountBuilder() *ConfigCellAccountBuilder {
	return &ConfigCellAccountBuilder{ max_length: Uint32Default(),basic_capacity: Uint64Default(),prepared_fee_capacity: Uint64Default(),expiration_grace_period: Uint32Default(),record_min_ttl: Uint32Default(),record_size_limit: Uint32Default(),transfer_account_fee: Uint64Default(),edit_manager_fee: Uint64Default(),edit_records_fee: Uint64Default(),common_fee: Uint64Default(),transfer_account_throttle: Uint32Default(),edit_manager_throttle: Uint32Default(),edit_records_throttle: Uint32Default(),common_throttle: Uint32Default() }
}
    

type ConfigCellAccount struct {
    inner []byte
}
        

func ConfigCellAccountFromSliceUnchecked(slice []byte) *ConfigCellAccount {
    return &ConfigCellAccount{inner: slice}
}
func (s *ConfigCellAccount) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellAccountDefault() ConfigCellAccount {
    return *ConfigCellAccountFromSliceUnchecked([]byte{ 140,0,0,0,60,0,0,0,64,0,0,0,72,0,0,0,80,0,0,0,84,0,0,0,88,0,0,0,92,0,0,0,100,0,0,0,108,0,0,0,116,0,0,0,124,0,0,0,128,0,0,0,132,0,0,0,136,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellAccountFromSlice(slice []byte, compatible bool) (*ConfigCellAccount, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellAccount", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellAccount", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellAccount", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellAccount", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellAccount", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 14 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 14 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[8]:offsets[9]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[9]:offsets[10]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[10]:offsets[11]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[11]:offsets[12]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[12]:offsets[13]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[13]:offsets[14]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellAccount{inner: slice}, nil
}
            

func (s *ConfigCellAccount) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellAccount) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellAccount) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellAccount) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellAccount) CountExtraFields() uint {
    return s.FieldCount() - 14
}

func (s *ConfigCellAccount) HasExtraFields() bool {
    return 14 != s.FieldCount()
}
            

func (s *ConfigCellAccount) MaxLength() *Uint32 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccount) BasicCapacity() *Uint64 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccount) PreparedFeeCapacity() *Uint64 {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccount) ExpirationGracePeriod() *Uint32 {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccount) RecordMinTtl() *Uint32 {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccount) RecordSizeLimit() *Uint32 {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccount) TransferAccountFee() *Uint64 {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccount) EditManagerFee() *Uint64 {
    start := unpackNumber(s.inner[32:])
    end := unpackNumber(s.inner[36:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccount) EditRecordsFee() *Uint64 {
    start := unpackNumber(s.inner[36:])
    end := unpackNumber(s.inner[40:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccount) CommonFee() *Uint64 {
    start := unpackNumber(s.inner[40:])
    end := unpackNumber(s.inner[44:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccount) TransferAccountThrottle() *Uint32 {
    start := unpackNumber(s.inner[44:])
    end := unpackNumber(s.inner[48:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccount) EditManagerThrottle() *Uint32 {
    start := unpackNumber(s.inner[48:])
    end := unpackNumber(s.inner[52:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccount) EditRecordsThrottle() *Uint32 {
    start := unpackNumber(s.inner[52:])
    end := unpackNumber(s.inner[56:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellAccount) CommonThrottle() *Uint32 {
    var ret *Uint32
    start := unpackNumber(s.inner[56:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[60:])
        ret = Uint32FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint32FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellAccount) AsBuilder() ConfigCellAccountBuilder {
    ret := NewConfigCellAccountBuilder().MaxLength(*s.MaxLength()).BasicCapacity(*s.BasicCapacity()).PreparedFeeCapacity(*s.PreparedFeeCapacity()).ExpirationGracePeriod(*s.ExpirationGracePeriod()).RecordMinTtl(*s.RecordMinTtl()).RecordSizeLimit(*s.RecordSizeLimit()).TransferAccountFee(*s.TransferAccountFee()).EditManagerFee(*s.EditManagerFee()).EditRecordsFee(*s.EditRecordsFee()).CommonFee(*s.CommonFee()).TransferAccountThrottle(*s.TransferAccountThrottle()).EditManagerThrottle(*s.EditManagerThrottle()).EditRecordsThrottle(*s.EditRecordsThrottle()).CommonThrottle(*s.CommonThrottle())
    return *ret
}
        

type ConfigCellApplyBuilder struct {
    apply_min_waiting_block_number Uint32
apply_max_waiting_block_number Uint32
}
        

func (s *ConfigCellApplyBuilder) Build() ConfigCellApply {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (2 + 1)
    offsets := make([]uint32, 0, 2)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.apply_min_waiting_block_number.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.apply_max_waiting_block_number.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.apply_min_waiting_block_number.AsSlice())
b.Write(s.apply_max_waiting_block_number.AsSlice())
    return ConfigCellApply{inner: b.Bytes()}
}
                

func (s *ConfigCellApplyBuilder) ApplyMinWaitingBlockNumber(v Uint32) *ConfigCellApplyBuilder {
    s.apply_min_waiting_block_number = v
    return s
}
            

func (s *ConfigCellApplyBuilder) ApplyMaxWaitingBlockNumber(v Uint32) *ConfigCellApplyBuilder {
    s.apply_max_waiting_block_number = v
    return s
}
            

func NewConfigCellApplyBuilder() *ConfigCellApplyBuilder {
	return &ConfigCellApplyBuilder{ apply_min_waiting_block_number: Uint32Default(),apply_max_waiting_block_number: Uint32Default() }
}
    

type ConfigCellApply struct {
    inner []byte
}
        

func ConfigCellApplyFromSliceUnchecked(slice []byte) *ConfigCellApply {
    return &ConfigCellApply{inner: slice}
}
func (s *ConfigCellApply) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellApplyDefault() ConfigCellApply {
    return *ConfigCellApplyFromSliceUnchecked([]byte{ 20,0,0,0,12,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellApplyFromSlice(slice []byte, compatible bool) (*ConfigCellApply, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellApply", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellApply", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellApply", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellApply", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellApply", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 2 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 2 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellApply{inner: slice}, nil
}
            

func (s *ConfigCellApply) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellApply) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellApply) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellApply) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellApply) CountExtraFields() uint {
    return s.FieldCount() - 2
}

func (s *ConfigCellApply) HasExtraFields() bool {
    return 2 != s.FieldCount()
}
            

func (s *ConfigCellApply) ApplyMinWaitingBlockNumber() *Uint32 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellApply) ApplyMaxWaitingBlockNumber() *Uint32 {
    var ret *Uint32
    start := unpackNumber(s.inner[8:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[12:])
        ret = Uint32FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint32FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellApply) AsBuilder() ConfigCellApplyBuilder {
    ret := NewConfigCellApplyBuilder().ApplyMinWaitingBlockNumber(*s.ApplyMinWaitingBlockNumber()).ApplyMaxWaitingBlockNumber(*s.ApplyMaxWaitingBlockNumber())
    return *ret
}
        

type CharsBuilder struct {
    inner []Bytes
}
    

func (s *CharsBuilder) Build() Chars {
    itemCount := len(s.inner)

    b := new(bytes.Buffer)

    // Empty dyn vector, just return size's bytes
    if itemCount == 0 {
        b.Write(packNumber(Number(HeaderSizeUint)))
        return Chars{inner: b.Bytes()}
    }

    // Calculate first offset then loop for rest items offsets
    totalSize := HeaderSizeUint * uint32(itemCount+1)
    offsets := make([]uint32, 0, itemCount)
    offsets = append(offsets, totalSize)
    for i := 1; i < itemCount; i++ {
        totalSize += uint32(len(s.inner[i-1].AsSlice()))
        offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
    }
    totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < itemCount; i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    for i := 0; i < itemCount; i++ {
        b.Write(s.inner[i].AsSlice())
    }

    return Chars{inner: b.Bytes()}
}
          

func (s *CharsBuilder) Set(v []Bytes) *CharsBuilder {
    s.inner = v
    return s
}
func (s *CharsBuilder) Push(v Bytes) *CharsBuilder {
    s.inner = append(s.inner, v)
    return s
}
func (s *CharsBuilder) Extend(iter []Bytes) *CharsBuilder {
    for i:=0; i < len(iter); i++ {
        s.inner = append(s.inner, iter[i])
    }
    return s
}
func (s *CharsBuilder) Replace(index uint, v Bytes) *Bytes {
    if uint(len(s.inner)) > index {
        a := s.inner[index]
        s.inner[index] = v
        return &a
    }
    return nil
}
    

func NewCharsBuilder() *CharsBuilder {
	return &CharsBuilder{ []Bytes{} }
}
        

type Chars struct {
    inner []byte
}
        

func CharsFromSliceUnchecked(slice []byte) *Chars {
    return &Chars{inner: slice}
}
func (s *Chars) AsSlice() []byte {
    return s.inner
}
            

func CharsDefault() Chars {
    return *CharsFromSliceUnchecked([]byte{ 4,0,0,0 })
}
            

func CharsFromSlice(slice []byte, compatible bool) (*Chars, error) {
    sliceLen := len(slice)

    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "Chars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "Chars", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint {
        return &Chars{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "Chars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "Chars", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "Chars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }
    itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

    offsets := make([]uint32, itemCount)

    for i := 0; i < int(itemCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }

    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            errMsg := strings.Join([]string{"OffsetsNotMatch", "Chars"}, " ")
            return nil, errors.New(errMsg)
        }
    }

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 {
            start := offsets[i-1]
            end := offsets[i]
            _, err := BytesFromSlice(slice[start:end], compatible)

            if err != nil {
                return nil, err
            }
        }
    }

    return &Chars{inner: slice}, nil
}
            

func (s *Chars) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *Chars) ItemCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *Chars) Len() uint {
    return s.ItemCount()
}
func (s *Chars) IsEmpty() bool {
    return s.Len() == 0
}
// if *Bytes is nil, index is out of bounds
func (s *Chars) Get(index uint) *Bytes {
    var b *Bytes
    if index < s.Len() {
        start_index := uint(HeaderSizeUint) * (1 + index)
        start := unpackNumber(s.inner[start_index:])

        if index == s.Len()-1 {
            b = BytesFromSliceUnchecked(s.inner[start:])
        } else {
            end_index := start_index + uint(HeaderSizeUint)
            end := unpackNumber(s.inner[end_index:])
            b = BytesFromSliceUnchecked(s.inner[start:end])
        }
    }
    return b
}
            

func (s *Chars) AsBuilder() CharsBuilder {
    size := s.ItemCount()
    t := NewCharsBuilder()
    for i:=uint(0); i < size; i++ {
        t.Push(*s.Get(i))
    }
    return *t
}
        

type ConfigCellPriceBuilder struct {
    discount DiscountConfig
prices PriceConfigList
}
        

func (s *ConfigCellPriceBuilder) Build() ConfigCellPrice {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (2 + 1)
    offsets := make([]uint32, 0, 2)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.discount.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.prices.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.discount.AsSlice())
b.Write(s.prices.AsSlice())
    return ConfigCellPrice{inner: b.Bytes()}
}
                

func (s *ConfigCellPriceBuilder) Discount(v DiscountConfig) *ConfigCellPriceBuilder {
    s.discount = v
    return s
}
            

func (s *ConfigCellPriceBuilder) Prices(v PriceConfigList) *ConfigCellPriceBuilder {
    s.prices = v
    return s
}
            

func NewConfigCellPriceBuilder() *ConfigCellPriceBuilder {
	return &ConfigCellPriceBuilder{ discount: DiscountConfigDefault(),prices: PriceConfigListDefault() }
}
    

type ConfigCellPrice struct {
    inner []byte
}
        

func ConfigCellPriceFromSliceUnchecked(slice []byte) *ConfigCellPrice {
    return &ConfigCellPrice{inner: slice}
}
func (s *ConfigCellPrice) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellPriceDefault() ConfigCellPrice {
    return *ConfigCellPriceFromSliceUnchecked([]byte{ 28,0,0,0,12,0,0,0,24,0,0,0,12,0,0,0,8,0,0,0,0,0,0,0,4,0,0,0 })
}
            

func ConfigCellPriceFromSlice(slice []byte, compatible bool) (*ConfigCellPrice, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellPrice", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellPrice", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellPrice", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellPrice", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellPrice", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 2 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 2 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = DiscountConfigFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = PriceConfigListFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellPrice{inner: slice}, nil
}
            

func (s *ConfigCellPrice) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellPrice) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellPrice) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellPrice) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellPrice) CountExtraFields() uint {
    return s.FieldCount() - 2
}

func (s *ConfigCellPrice) HasExtraFields() bool {
    return 2 != s.FieldCount()
}
            

func (s *ConfigCellPrice) Discount() *DiscountConfig {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return DiscountConfigFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellPrice) Prices() *PriceConfigList {
    var ret *PriceConfigList
    start := unpackNumber(s.inner[8:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[12:])
        ret = PriceConfigListFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = PriceConfigListFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellPrice) AsBuilder() ConfigCellPriceBuilder {
    ret := NewConfigCellPriceBuilder().Discount(*s.Discount()).Prices(*s.Prices())
    return *ret
}
        

type DiscountConfigBuilder struct {
    invited_discount Uint32
}
        

func (s *DiscountConfigBuilder) Build() DiscountConfig {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (1 + 1)
    offsets := make([]uint32, 0, 1)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.invited_discount.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.invited_discount.AsSlice())
    return DiscountConfig{inner: b.Bytes()}
}
                

func (s *DiscountConfigBuilder) InvitedDiscount(v Uint32) *DiscountConfigBuilder {
    s.invited_discount = v
    return s
}
            

func NewDiscountConfigBuilder() *DiscountConfigBuilder {
	return &DiscountConfigBuilder{ invited_discount: Uint32Default() }
}
    

type DiscountConfig struct {
    inner []byte
}
        

func DiscountConfigFromSliceUnchecked(slice []byte) *DiscountConfig {
    return &DiscountConfig{inner: slice}
}
func (s *DiscountConfig) AsSlice() []byte {
    return s.inner
}
            

func DiscountConfigDefault() DiscountConfig {
    return *DiscountConfigFromSliceUnchecked([]byte{ 12,0,0,0,8,0,0,0,0,0,0,0 })
}
            

func DiscountConfigFromSlice(slice []byte, compatible bool) (*DiscountConfig, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "DiscountConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "DiscountConfig", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "DiscountConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "DiscountConfig", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "DiscountConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 1 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 1 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

    return &DiscountConfig{inner: slice}, nil
}
            

func (s *DiscountConfig) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *DiscountConfig) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *DiscountConfig) Len() uint {
    return s.FieldCount()
}
func (s *DiscountConfig) IsEmpty() bool {
    return s.Len() == 0
}
func (s *DiscountConfig) CountExtraFields() uint {
    return s.FieldCount() - 1
}

func (s *DiscountConfig) HasExtraFields() bool {
    return 1 != s.FieldCount()
}
            

func (s *DiscountConfig) InvitedDiscount() *Uint32 {
    var ret *Uint32
    start := unpackNumber(s.inner[4:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[8:])
        ret = Uint32FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint32FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *DiscountConfig) AsBuilder() DiscountConfigBuilder {
    ret := NewDiscountConfigBuilder().InvitedDiscount(*s.InvitedDiscount())
    return *ret
}
        

type PriceConfigListBuilder struct {
    inner []PriceConfig
}
    

func (s *PriceConfigListBuilder) Build() PriceConfigList {
    itemCount := len(s.inner)

    b := new(bytes.Buffer)

    // Empty dyn vector, just return size's bytes
    if itemCount == 0 {
        b.Write(packNumber(Number(HeaderSizeUint)))
        return PriceConfigList{inner: b.Bytes()}
    }

    // Calculate first offset then loop for rest items offsets
    totalSize := HeaderSizeUint * uint32(itemCount+1)
    offsets := make([]uint32, 0, itemCount)
    offsets = append(offsets, totalSize)
    for i := 1; i < itemCount; i++ {
        totalSize += uint32(len(s.inner[i-1].AsSlice()))
        offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
    }
    totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < itemCount; i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    for i := 0; i < itemCount; i++ {
        b.Write(s.inner[i].AsSlice())
    }

    return PriceConfigList{inner: b.Bytes()}
}
          

func (s *PriceConfigListBuilder) Set(v []PriceConfig) *PriceConfigListBuilder {
    s.inner = v
    return s
}
func (s *PriceConfigListBuilder) Push(v PriceConfig) *PriceConfigListBuilder {
    s.inner = append(s.inner, v)
    return s
}
func (s *PriceConfigListBuilder) Extend(iter []PriceConfig) *PriceConfigListBuilder {
    for i:=0; i < len(iter); i++ {
        s.inner = append(s.inner, iter[i])
    }
    return s
}
func (s *PriceConfigListBuilder) Replace(index uint, v PriceConfig) *PriceConfig {
    if uint(len(s.inner)) > index {
        a := s.inner[index]
        s.inner[index] = v
        return &a
    }
    return nil
}
    

func NewPriceConfigListBuilder() *PriceConfigListBuilder {
	return &PriceConfigListBuilder{ []PriceConfig{} }
}
        

type PriceConfigList struct {
    inner []byte
}
        

func PriceConfigListFromSliceUnchecked(slice []byte) *PriceConfigList {
    return &PriceConfigList{inner: slice}
}
func (s *PriceConfigList) AsSlice() []byte {
    return s.inner
}
            

func PriceConfigListDefault() PriceConfigList {
    return *PriceConfigListFromSliceUnchecked([]byte{ 4,0,0,0 })
}
            

func PriceConfigListFromSlice(slice []byte, compatible bool) (*PriceConfigList, error) {
    sliceLen := len(slice)

    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "PriceConfigList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "PriceConfigList", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint {
        return &PriceConfigList{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "PriceConfigList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "PriceConfigList", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "PriceConfigList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }
    itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

    offsets := make([]uint32, itemCount)

    for i := 0; i < int(itemCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }

    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            errMsg := strings.Join([]string{"OffsetsNotMatch", "PriceConfigList"}, " ")
            return nil, errors.New(errMsg)
        }
    }

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 {
            start := offsets[i-1]
            end := offsets[i]
            _, err := PriceConfigFromSlice(slice[start:end], compatible)

            if err != nil {
                return nil, err
            }
        }
    }

    return &PriceConfigList{inner: slice}, nil
}
            

func (s *PriceConfigList) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *PriceConfigList) ItemCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *PriceConfigList) Len() uint {
    return s.ItemCount()
}
func (s *PriceConfigList) IsEmpty() bool {
    return s.Len() == 0
}
// if *PriceConfig is nil, index is out of bounds
func (s *PriceConfigList) Get(index uint) *PriceConfig {
    var b *PriceConfig
    if index < s.Len() {
        start_index := uint(HeaderSizeUint) * (1 + index)
        start := unpackNumber(s.inner[start_index:])

        if index == s.Len()-1 {
            b = PriceConfigFromSliceUnchecked(s.inner[start:])
        } else {
            end_index := start_index + uint(HeaderSizeUint)
            end := unpackNumber(s.inner[end_index:])
            b = PriceConfigFromSliceUnchecked(s.inner[start:end])
        }
    }
    return b
}
            

func (s *PriceConfigList) AsBuilder() PriceConfigListBuilder {
    size := s.ItemCount()
    t := NewPriceConfigListBuilder()
    for i:=uint(0); i < size; i++ {
        t.Push(*s.Get(i))
    }
    return *t
}
        

type PriceConfigBuilder struct {
    length Uint8
new Uint64
renew Uint64
}
        

func (s *PriceConfigBuilder) Build() PriceConfig {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (3 + 1)
    offsets := make([]uint32, 0, 3)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.length.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.new.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.renew.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.length.AsSlice())
b.Write(s.new.AsSlice())
b.Write(s.renew.AsSlice())
    return PriceConfig{inner: b.Bytes()}
}
                

func (s *PriceConfigBuilder) Length(v Uint8) *PriceConfigBuilder {
    s.length = v
    return s
}
            

func (s *PriceConfigBuilder) New(v Uint64) *PriceConfigBuilder {
    s.new = v
    return s
}
            

func (s *PriceConfigBuilder) Renew(v Uint64) *PriceConfigBuilder {
    s.renew = v
    return s
}
            

func NewPriceConfigBuilder() *PriceConfigBuilder {
	return &PriceConfigBuilder{ length: Uint8Default(),new: Uint64Default(),renew: Uint64Default() }
}
    

type PriceConfig struct {
    inner []byte
}
        

func PriceConfigFromSliceUnchecked(slice []byte) *PriceConfig {
    return &PriceConfig{inner: slice}
}
func (s *PriceConfig) AsSlice() []byte {
    return s.inner
}
            

func PriceConfigDefault() PriceConfig {
    return *PriceConfigFromSliceUnchecked([]byte{ 33,0,0,0,16,0,0,0,17,0,0,0,25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func PriceConfigFromSlice(slice []byte, compatible bool) (*PriceConfig, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "PriceConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "PriceConfig", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "PriceConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "PriceConfig", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "PriceConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 3 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 3 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

    return &PriceConfig{inner: slice}, nil
}
            

func (s *PriceConfig) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *PriceConfig) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *PriceConfig) Len() uint {
    return s.FieldCount()
}
func (s *PriceConfig) IsEmpty() bool {
    return s.Len() == 0
}
func (s *PriceConfig) CountExtraFields() uint {
    return s.FieldCount() - 3
}

func (s *PriceConfig) HasExtraFields() bool {
    return 3 != s.FieldCount()
}
            

func (s *PriceConfig) Length() *Uint8 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *PriceConfig) New() *Uint64 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *PriceConfig) Renew() *Uint64 {
    var ret *Uint64
    start := unpackNumber(s.inner[12:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[16:])
        ret = Uint64FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint64FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *PriceConfig) AsBuilder() PriceConfigBuilder {
    ret := NewPriceConfigBuilder().Length(*s.Length()).New(*s.New()).Renew(*s.Renew())
    return *ret
}
        

type ConfigCellProposalBuilder struct {
    proposal_min_confirm_interval Uint8
proposal_min_extend_interval Uint8
proposal_min_recycle_interval Uint8
proposal_max_account_affect Uint32
proposal_max_pre_account_contain Uint32
}
        

func (s *ConfigCellProposalBuilder) Build() ConfigCellProposal {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (5 + 1)
    offsets := make([]uint32, 0, 5)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_min_confirm_interval.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_min_extend_interval.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_min_recycle_interval.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_max_account_affect.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_max_pre_account_contain.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.proposal_min_confirm_interval.AsSlice())
b.Write(s.proposal_min_extend_interval.AsSlice())
b.Write(s.proposal_min_recycle_interval.AsSlice())
b.Write(s.proposal_max_account_affect.AsSlice())
b.Write(s.proposal_max_pre_account_contain.AsSlice())
    return ConfigCellProposal{inner: b.Bytes()}
}
                

func (s *ConfigCellProposalBuilder) ProposalMinConfirmInterval(v Uint8) *ConfigCellProposalBuilder {
    s.proposal_min_confirm_interval = v
    return s
}
            

func (s *ConfigCellProposalBuilder) ProposalMinExtendInterval(v Uint8) *ConfigCellProposalBuilder {
    s.proposal_min_extend_interval = v
    return s
}
            

func (s *ConfigCellProposalBuilder) ProposalMinRecycleInterval(v Uint8) *ConfigCellProposalBuilder {
    s.proposal_min_recycle_interval = v
    return s
}
            

func (s *ConfigCellProposalBuilder) ProposalMaxAccountAffect(v Uint32) *ConfigCellProposalBuilder {
    s.proposal_max_account_affect = v
    return s
}
            

func (s *ConfigCellProposalBuilder) ProposalMaxPreAccountContain(v Uint32) *ConfigCellProposalBuilder {
    s.proposal_max_pre_account_contain = v
    return s
}
            

func NewConfigCellProposalBuilder() *ConfigCellProposalBuilder {
	return &ConfigCellProposalBuilder{ proposal_min_confirm_interval: Uint8Default(),proposal_min_extend_interval: Uint8Default(),proposal_min_recycle_interval: Uint8Default(),proposal_max_account_affect: Uint32Default(),proposal_max_pre_account_contain: Uint32Default() }
}
    

type ConfigCellProposal struct {
    inner []byte
}
        

func ConfigCellProposalFromSliceUnchecked(slice []byte) *ConfigCellProposal {
    return &ConfigCellProposal{inner: slice}
}
func (s *ConfigCellProposal) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellProposalDefault() ConfigCellProposal {
    return *ConfigCellProposalFromSliceUnchecked([]byte{ 35,0,0,0,24,0,0,0,25,0,0,0,26,0,0,0,27,0,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellProposalFromSlice(slice []byte, compatible bool) (*ConfigCellProposal, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellProposal", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellProposal", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellProposal", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellProposal", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellProposal", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 5 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 5 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint8FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint8FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellProposal{inner: slice}, nil
}
            

func (s *ConfigCellProposal) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellProposal) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellProposal) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellProposal) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellProposal) CountExtraFields() uint {
    return s.FieldCount() - 5
}

func (s *ConfigCellProposal) HasExtraFields() bool {
    return 5 != s.FieldCount()
}
            

func (s *ConfigCellProposal) ProposalMinConfirmInterval() *Uint8 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProposal) ProposalMinExtendInterval() *Uint8 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProposal) ProposalMinRecycleInterval() *Uint8 {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProposal) ProposalMaxAccountAffect() *Uint32 {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProposal) ProposalMaxPreAccountContain() *Uint32 {
    var ret *Uint32
    start := unpackNumber(s.inner[20:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[24:])
        ret = Uint32FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint32FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellProposal) AsBuilder() ConfigCellProposalBuilder {
    ret := NewConfigCellProposalBuilder().ProposalMinConfirmInterval(*s.ProposalMinConfirmInterval()).ProposalMinExtendInterval(*s.ProposalMinExtendInterval()).ProposalMinRecycleInterval(*s.ProposalMinRecycleInterval()).ProposalMaxAccountAffect(*s.ProposalMaxAccountAffect()).ProposalMaxPreAccountContain(*s.ProposalMaxPreAccountContain())
    return *ret
}
        

type ConfigCellProfitRateBuilder struct {
    inviter Uint32
channel Uint32
proposal_create Uint32
proposal_confirm Uint32
income_consolidate Uint32
sale_buyer_inviter Uint32
sale_buyer_channel Uint32
sale_das Uint32
auction_bidder_inviter Uint32
auction_bidder_channel Uint32
auction_das Uint32
auction_prev_bidder Uint32
}
        

func (s *ConfigCellProfitRateBuilder) Build() ConfigCellProfitRate {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (12 + 1)
    offsets := make([]uint32, 0, 12)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.inviter.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.channel.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_create.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_confirm.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.income_consolidate.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.sale_buyer_inviter.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.sale_buyer_channel.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.sale_das.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.auction_bidder_inviter.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.auction_bidder_channel.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.auction_das.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.auction_prev_bidder.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.inviter.AsSlice())
b.Write(s.channel.AsSlice())
b.Write(s.proposal_create.AsSlice())
b.Write(s.proposal_confirm.AsSlice())
b.Write(s.income_consolidate.AsSlice())
b.Write(s.sale_buyer_inviter.AsSlice())
b.Write(s.sale_buyer_channel.AsSlice())
b.Write(s.sale_das.AsSlice())
b.Write(s.auction_bidder_inviter.AsSlice())
b.Write(s.auction_bidder_channel.AsSlice())
b.Write(s.auction_das.AsSlice())
b.Write(s.auction_prev_bidder.AsSlice())
    return ConfigCellProfitRate{inner: b.Bytes()}
}
                

func (s *ConfigCellProfitRateBuilder) Inviter(v Uint32) *ConfigCellProfitRateBuilder {
    s.inviter = v
    return s
}
            

func (s *ConfigCellProfitRateBuilder) Channel(v Uint32) *ConfigCellProfitRateBuilder {
    s.channel = v
    return s
}
            

func (s *ConfigCellProfitRateBuilder) ProposalCreate(v Uint32) *ConfigCellProfitRateBuilder {
    s.proposal_create = v
    return s
}
            

func (s *ConfigCellProfitRateBuilder) ProposalConfirm(v Uint32) *ConfigCellProfitRateBuilder {
    s.proposal_confirm = v
    return s
}
            

func (s *ConfigCellProfitRateBuilder) IncomeConsolidate(v Uint32) *ConfigCellProfitRateBuilder {
    s.income_consolidate = v
    return s
}
            

func (s *ConfigCellProfitRateBuilder) SaleBuyerInviter(v Uint32) *ConfigCellProfitRateBuilder {
    s.sale_buyer_inviter = v
    return s
}
            

func (s *ConfigCellProfitRateBuilder) SaleBuyerChannel(v Uint32) *ConfigCellProfitRateBuilder {
    s.sale_buyer_channel = v
    return s
}
            

func (s *ConfigCellProfitRateBuilder) SaleDas(v Uint32) *ConfigCellProfitRateBuilder {
    s.sale_das = v
    return s
}
            

func (s *ConfigCellProfitRateBuilder) AuctionBidderInviter(v Uint32) *ConfigCellProfitRateBuilder {
    s.auction_bidder_inviter = v
    return s
}
            

func (s *ConfigCellProfitRateBuilder) AuctionBidderChannel(v Uint32) *ConfigCellProfitRateBuilder {
    s.auction_bidder_channel = v
    return s
}
            

func (s *ConfigCellProfitRateBuilder) AuctionDas(v Uint32) *ConfigCellProfitRateBuilder {
    s.auction_das = v
    return s
}
            

func (s *ConfigCellProfitRateBuilder) AuctionPrevBidder(v Uint32) *ConfigCellProfitRateBuilder {
    s.auction_prev_bidder = v
    return s
}
            

func NewConfigCellProfitRateBuilder() *ConfigCellProfitRateBuilder {
	return &ConfigCellProfitRateBuilder{ inviter: Uint32Default(),channel: Uint32Default(),proposal_create: Uint32Default(),proposal_confirm: Uint32Default(),income_consolidate: Uint32Default(),sale_buyer_inviter: Uint32Default(),sale_buyer_channel: Uint32Default(),sale_das: Uint32Default(),auction_bidder_inviter: Uint32Default(),auction_bidder_channel: Uint32Default(),auction_das: Uint32Default(),auction_prev_bidder: Uint32Default() }
}
    

type ConfigCellProfitRate struct {
    inner []byte
}
        

func ConfigCellProfitRateFromSliceUnchecked(slice []byte) *ConfigCellProfitRate {
    return &ConfigCellProfitRate{inner: slice}
}
func (s *ConfigCellProfitRate) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellProfitRateDefault() ConfigCellProfitRate {
    return *ConfigCellProfitRateFromSliceUnchecked([]byte{ 100,0,0,0,52,0,0,0,56,0,0,0,60,0,0,0,64,0,0,0,68,0,0,0,72,0,0,0,76,0,0,0,80,0,0,0,84,0,0,0,88,0,0,0,92,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellProfitRateFromSlice(slice []byte, compatible bool) (*ConfigCellProfitRate, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellProfitRate", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellProfitRate", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellProfitRate", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellProfitRate", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellProfitRate", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 12 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 12 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[8]:offsets[9]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[9]:offsets[10]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[10]:offsets[11]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[11]:offsets[12]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellProfitRate{inner: slice}, nil
}
            

func (s *ConfigCellProfitRate) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellProfitRate) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellProfitRate) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellProfitRate) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellProfitRate) CountExtraFields() uint {
    return s.FieldCount() - 12
}

func (s *ConfigCellProfitRate) HasExtraFields() bool {
    return 12 != s.FieldCount()
}
            

func (s *ConfigCellProfitRate) Inviter() *Uint32 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProfitRate) Channel() *Uint32 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProfitRate) ProposalCreate() *Uint32 {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProfitRate) ProposalConfirm() *Uint32 {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProfitRate) IncomeConsolidate() *Uint32 {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProfitRate) SaleBuyerInviter() *Uint32 {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProfitRate) SaleBuyerChannel() *Uint32 {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProfitRate) SaleDas() *Uint32 {
    start := unpackNumber(s.inner[32:])
    end := unpackNumber(s.inner[36:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProfitRate) AuctionBidderInviter() *Uint32 {
    start := unpackNumber(s.inner[36:])
    end := unpackNumber(s.inner[40:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProfitRate) AuctionBidderChannel() *Uint32 {
    start := unpackNumber(s.inner[40:])
    end := unpackNumber(s.inner[44:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProfitRate) AuctionDas() *Uint32 {
    start := unpackNumber(s.inner[44:])
    end := unpackNumber(s.inner[48:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellProfitRate) AuctionPrevBidder() *Uint32 {
    var ret *Uint32
    start := unpackNumber(s.inner[48:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[52:])
        ret = Uint32FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint32FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellProfitRate) AsBuilder() ConfigCellProfitRateBuilder {
    ret := NewConfigCellProfitRateBuilder().Inviter(*s.Inviter()).Channel(*s.Channel()).ProposalCreate(*s.ProposalCreate()).ProposalConfirm(*s.ProposalConfirm()).IncomeConsolidate(*s.IncomeConsolidate()).SaleBuyerInviter(*s.SaleBuyerInviter()).SaleBuyerChannel(*s.SaleBuyerChannel()).SaleDas(*s.SaleDas()).AuctionBidderInviter(*s.AuctionBidderInviter()).AuctionBidderChannel(*s.AuctionBidderChannel()).AuctionDas(*s.AuctionDas()).AuctionPrevBidder(*s.AuctionPrevBidder())
    return *ret
}
        

type ConfigCellIncomeBuilder struct {
    basic_capacity Uint64
max_records Uint32
min_transfer_capacity Uint64
}
        

func (s *ConfigCellIncomeBuilder) Build() ConfigCellIncome {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (3 + 1)
    offsets := make([]uint32, 0, 3)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.basic_capacity.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.max_records.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.min_transfer_capacity.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.basic_capacity.AsSlice())
b.Write(s.max_records.AsSlice())
b.Write(s.min_transfer_capacity.AsSlice())
    return ConfigCellIncome{inner: b.Bytes()}
}
                

func (s *ConfigCellIncomeBuilder) BasicCapacity(v Uint64) *ConfigCellIncomeBuilder {
    s.basic_capacity = v
    return s
}
            

func (s *ConfigCellIncomeBuilder) MaxRecords(v Uint32) *ConfigCellIncomeBuilder {
    s.max_records = v
    return s
}
            

func (s *ConfigCellIncomeBuilder) MinTransferCapacity(v Uint64) *ConfigCellIncomeBuilder {
    s.min_transfer_capacity = v
    return s
}
            

func NewConfigCellIncomeBuilder() *ConfigCellIncomeBuilder {
	return &ConfigCellIncomeBuilder{ basic_capacity: Uint64Default(),max_records: Uint32Default(),min_transfer_capacity: Uint64Default() }
}
    

type ConfigCellIncome struct {
    inner []byte
}
        

func ConfigCellIncomeFromSliceUnchecked(slice []byte) *ConfigCellIncome {
    return &ConfigCellIncome{inner: slice}
}
func (s *ConfigCellIncome) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellIncomeDefault() ConfigCellIncome {
    return *ConfigCellIncomeFromSliceUnchecked([]byte{ 36,0,0,0,16,0,0,0,24,0,0,0,28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellIncomeFromSlice(slice []byte, compatible bool) (*ConfigCellIncome, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellIncome", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellIncome", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellIncome", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellIncome", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellIncome", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 3 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 3 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint64FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellIncome{inner: slice}, nil
}
            

func (s *ConfigCellIncome) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellIncome) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellIncome) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellIncome) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellIncome) CountExtraFields() uint {
    return s.FieldCount() - 3
}

func (s *ConfigCellIncome) HasExtraFields() bool {
    return 3 != s.FieldCount()
}
            

func (s *ConfigCellIncome) BasicCapacity() *Uint64 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellIncome) MaxRecords() *Uint32 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellIncome) MinTransferCapacity() *Uint64 {
    var ret *Uint64
    start := unpackNumber(s.inner[12:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[16:])
        ret = Uint64FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint64FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellIncome) AsBuilder() ConfigCellIncomeBuilder {
    ret := NewConfigCellIncomeBuilder().BasicCapacity(*s.BasicCapacity()).MaxRecords(*s.MaxRecords()).MinTransferCapacity(*s.MinTransferCapacity())
    return *ret
}
        

type ConfigCellReleaseBuilder struct {
    lucky_number Uint32
}
        

func (s *ConfigCellReleaseBuilder) Build() ConfigCellRelease {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (1 + 1)
    offsets := make([]uint32, 0, 1)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.lucky_number.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.lucky_number.AsSlice())
    return ConfigCellRelease{inner: b.Bytes()}
}
                

func (s *ConfigCellReleaseBuilder) LuckyNumber(v Uint32) *ConfigCellReleaseBuilder {
    s.lucky_number = v
    return s
}
            

func NewConfigCellReleaseBuilder() *ConfigCellReleaseBuilder {
	return &ConfigCellReleaseBuilder{ lucky_number: Uint32Default() }
}
    

type ConfigCellRelease struct {
    inner []byte
}
        

func ConfigCellReleaseFromSliceUnchecked(slice []byte) *ConfigCellRelease {
    return &ConfigCellRelease{inner: slice}
}
func (s *ConfigCellRelease) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellReleaseDefault() ConfigCellRelease {
    return *ConfigCellReleaseFromSliceUnchecked([]byte{ 12,0,0,0,8,0,0,0,0,0,0,0 })
}
            

func ConfigCellReleaseFromSlice(slice []byte, compatible bool) (*ConfigCellRelease, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellRelease", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellRelease", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellRelease", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellRelease", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellRelease", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 1 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 1 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellRelease{inner: slice}, nil
}
            

func (s *ConfigCellRelease) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellRelease) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellRelease) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellRelease) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellRelease) CountExtraFields() uint {
    return s.FieldCount() - 1
}

func (s *ConfigCellRelease) HasExtraFields() bool {
    return 1 != s.FieldCount()
}
            

func (s *ConfigCellRelease) LuckyNumber() *Uint32 {
    var ret *Uint32
    start := unpackNumber(s.inner[4:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[8:])
        ret = Uint32FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint32FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellRelease) AsBuilder() ConfigCellReleaseBuilder {
    ret := NewConfigCellReleaseBuilder().LuckyNumber(*s.LuckyNumber())
    return *ret
}
        

type ConfigCellSecondaryMarketBuilder struct {
    common_fee Uint64
sale_min_price Uint64
sale_expiration_limit Uint32
sale_description_bytes_limit Uint32
sale_cell_basic_capacity Uint64
sale_cell_prepared_fee_capacity Uint64
auction_max_extendable_duration Uint32
auction_duration_increment_each_bid Uint32
auction_min_opening_price Uint64
auction_min_increment_rate_each_bid Uint32
auction_description_bytes_limit Uint32
auction_cell_basic_capacity Uint64
auction_cell_prepared_fee_capacity Uint64
offer_min_price Uint64
offer_cell_basic_capacity Uint64
offer_cell_prepared_fee_capacity Uint64
offer_message_bytes_limit Uint32
}
        

func (s *ConfigCellSecondaryMarketBuilder) Build() ConfigCellSecondaryMarket {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (17 + 1)
    offsets := make([]uint32, 0, 17)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.common_fee.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.sale_min_price.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.sale_expiration_limit.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.sale_description_bytes_limit.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.sale_cell_basic_capacity.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.sale_cell_prepared_fee_capacity.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.auction_max_extendable_duration.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.auction_duration_increment_each_bid.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.auction_min_opening_price.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.auction_min_increment_rate_each_bid.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.auction_description_bytes_limit.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.auction_cell_basic_capacity.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.auction_cell_prepared_fee_capacity.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.offer_min_price.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.offer_cell_basic_capacity.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.offer_cell_prepared_fee_capacity.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.offer_message_bytes_limit.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.common_fee.AsSlice())
b.Write(s.sale_min_price.AsSlice())
b.Write(s.sale_expiration_limit.AsSlice())
b.Write(s.sale_description_bytes_limit.AsSlice())
b.Write(s.sale_cell_basic_capacity.AsSlice())
b.Write(s.sale_cell_prepared_fee_capacity.AsSlice())
b.Write(s.auction_max_extendable_duration.AsSlice())
b.Write(s.auction_duration_increment_each_bid.AsSlice())
b.Write(s.auction_min_opening_price.AsSlice())
b.Write(s.auction_min_increment_rate_each_bid.AsSlice())
b.Write(s.auction_description_bytes_limit.AsSlice())
b.Write(s.auction_cell_basic_capacity.AsSlice())
b.Write(s.auction_cell_prepared_fee_capacity.AsSlice())
b.Write(s.offer_min_price.AsSlice())
b.Write(s.offer_cell_basic_capacity.AsSlice())
b.Write(s.offer_cell_prepared_fee_capacity.AsSlice())
b.Write(s.offer_message_bytes_limit.AsSlice())
    return ConfigCellSecondaryMarket{inner: b.Bytes()}
}
                

func (s *ConfigCellSecondaryMarketBuilder) CommonFee(v Uint64) *ConfigCellSecondaryMarketBuilder {
    s.common_fee = v
    return s
}
            

func (s *ConfigCellSecondaryMarketBuilder) SaleMinPrice(v Uint64) *ConfigCellSecondaryMarketBuilder {
    s.sale_min_price = v
    return s
}
            

func (s *ConfigCellSecondaryMarketBuilder) SaleExpirationLimit(v Uint32) *ConfigCellSecondaryMarketBuilder {
    s.sale_expiration_limit = v
    return s
}
            

func (s *ConfigCellSecondaryMarketBuilder) SaleDescriptionBytesLimit(v Uint32) *ConfigCellSecondaryMarketBuilder {
    s.sale_description_bytes_limit = v
    return s
}
            

func (s *ConfigCellSecondaryMarketBuilder) SaleCellBasicCapacity(v Uint64) *ConfigCellSecondaryMarketBuilder {
    s.sale_cell_basic_capacity = v
    return s
}
            

func (s *ConfigCellSecondaryMarketBuilder) SaleCellPreparedFeeCapacity(v Uint64) *ConfigCellSecondaryMarketBuilder {
    s.sale_cell_prepared_fee_capacity = v
    return s
}
            

func (s *ConfigCellSecondaryMarketBuilder) AuctionMaxExtendableDuration(v Uint32) *ConfigCellSecondaryMarketBuilder {
    s.auction_max_extendable_duration = v
    return s
}
            

func (s *ConfigCellSecondaryMarketBuilder) AuctionDurationIncrementEachBid(v Uint32) *ConfigCellSecondaryMarketBuilder {
    s.auction_duration_increment_each_bid = v
    return s
}
            

func (s *ConfigCellSecondaryMarketBuilder) AuctionMinOpeningPrice(v Uint64) *ConfigCellSecondaryMarketBuilder {
    s.auction_min_opening_price = v
    return s
}
            

func (s *ConfigCellSecondaryMarketBuilder) AuctionMinIncrementRateEachBid(v Uint32) *ConfigCellSecondaryMarketBuilder {
    s.auction_min_increment_rate_each_bid = v
    return s
}
            

func (s *ConfigCellSecondaryMarketBuilder) AuctionDescriptionBytesLimit(v Uint32) *ConfigCellSecondaryMarketBuilder {
    s.auction_description_bytes_limit = v
    return s
}
            

func (s *ConfigCellSecondaryMarketBuilder) AuctionCellBasicCapacity(v Uint64) *ConfigCellSecondaryMarketBuilder {
    s.auction_cell_basic_capacity = v
    return s
}
            

func (s *ConfigCellSecondaryMarketBuilder) AuctionCellPreparedFeeCapacity(v Uint64) *ConfigCellSecondaryMarketBuilder {
    s.auction_cell_prepared_fee_capacity = v
    return s
}
            

func (s *ConfigCellSecondaryMarketBuilder) OfferMinPrice(v Uint64) *ConfigCellSecondaryMarketBuilder {
    s.offer_min_price = v
    return s
}
            

func (s *ConfigCellSecondaryMarketBuilder) OfferCellBasicCapacity(v Uint64) *ConfigCellSecondaryMarketBuilder {
    s.offer_cell_basic_capacity = v
    return s
}
            

func (s *ConfigCellSecondaryMarketBuilder) OfferCellPreparedFeeCapacity(v Uint64) *ConfigCellSecondaryMarketBuilder {
    s.offer_cell_prepared_fee_capacity = v
    return s
}
            

func (s *ConfigCellSecondaryMarketBuilder) OfferMessageBytesLimit(v Uint32) *ConfigCellSecondaryMarketBuilder {
    s.offer_message_bytes_limit = v
    return s
}
            

func NewConfigCellSecondaryMarketBuilder() *ConfigCellSecondaryMarketBuilder {
	return &ConfigCellSecondaryMarketBuilder{ common_fee: Uint64Default(),sale_min_price: Uint64Default(),sale_expiration_limit: Uint32Default(),sale_description_bytes_limit: Uint32Default(),sale_cell_basic_capacity: Uint64Default(),sale_cell_prepared_fee_capacity: Uint64Default(),auction_max_extendable_duration: Uint32Default(),auction_duration_increment_each_bid: Uint32Default(),auction_min_opening_price: Uint64Default(),auction_min_increment_rate_each_bid: Uint32Default(),auction_description_bytes_limit: Uint32Default(),auction_cell_basic_capacity: Uint64Default(),auction_cell_prepared_fee_capacity: Uint64Default(),offer_min_price: Uint64Default(),offer_cell_basic_capacity: Uint64Default(),offer_cell_prepared_fee_capacity: Uint64Default(),offer_message_bytes_limit: Uint32Default() }
}
    

type ConfigCellSecondaryMarket struct {
    inner []byte
}
        

func ConfigCellSecondaryMarketFromSliceUnchecked(slice []byte) *ConfigCellSecondaryMarket {
    return &ConfigCellSecondaryMarket{inner: slice}
}
func (s *ConfigCellSecondaryMarket) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellSecondaryMarketDefault() ConfigCellSecondaryMarket {
    return *ConfigCellSecondaryMarketFromSliceUnchecked([]byte{ 180,0,0,0,72,0,0,0,80,0,0,0,88,0,0,0,92,0,0,0,96,0,0,0,104,0,0,0,112,0,0,0,116,0,0,0,120,0,0,0,128,0,0,0,132,0,0,0,136,0,0,0,144,0,0,0,152,0,0,0,160,0,0,0,168,0,0,0,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellSecondaryMarketFromSlice(slice []byte, compatible bool) (*ConfigCellSecondaryMarket, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellSecondaryMarket", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellSecondaryMarket", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellSecondaryMarket", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellSecondaryMarket", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellSecondaryMarket", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 17 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 17 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint64FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[8]:offsets[9]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[9]:offsets[10]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[10]:offsets[11]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[11]:offsets[12]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[12]:offsets[13]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[13]:offsets[14]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[14]:offsets[15]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[15]:offsets[16]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[16]:offsets[17]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellSecondaryMarket{inner: slice}, nil
}
            

func (s *ConfigCellSecondaryMarket) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellSecondaryMarket) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellSecondaryMarket) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellSecondaryMarket) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellSecondaryMarket) CountExtraFields() uint {
    return s.FieldCount() - 17
}

func (s *ConfigCellSecondaryMarket) HasExtraFields() bool {
    return 17 != s.FieldCount()
}
            

func (s *ConfigCellSecondaryMarket) CommonFee() *Uint64 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarket) SaleMinPrice() *Uint64 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarket) SaleExpirationLimit() *Uint32 {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarket) SaleDescriptionBytesLimit() *Uint32 {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarket) SaleCellBasicCapacity() *Uint64 {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarket) SaleCellPreparedFeeCapacity() *Uint64 {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarket) AuctionMaxExtendableDuration() *Uint32 {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarket) AuctionDurationIncrementEachBid() *Uint32 {
    start := unpackNumber(s.inner[32:])
    end := unpackNumber(s.inner[36:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarket) AuctionMinOpeningPrice() *Uint64 {
    start := unpackNumber(s.inner[36:])
    end := unpackNumber(s.inner[40:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarket) AuctionMinIncrementRateEachBid() *Uint32 {
    start := unpackNumber(s.inner[40:])
    end := unpackNumber(s.inner[44:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarket) AuctionDescriptionBytesLimit() *Uint32 {
    start := unpackNumber(s.inner[44:])
    end := unpackNumber(s.inner[48:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarket) AuctionCellBasicCapacity() *Uint64 {
    start := unpackNumber(s.inner[48:])
    end := unpackNumber(s.inner[52:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarket) AuctionCellPreparedFeeCapacity() *Uint64 {
    start := unpackNumber(s.inner[52:])
    end := unpackNumber(s.inner[56:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarket) OfferMinPrice() *Uint64 {
    start := unpackNumber(s.inner[56:])
    end := unpackNumber(s.inner[60:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarket) OfferCellBasicCapacity() *Uint64 {
    start := unpackNumber(s.inner[60:])
    end := unpackNumber(s.inner[64:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarket) OfferCellPreparedFeeCapacity() *Uint64 {
    start := unpackNumber(s.inner[64:])
    end := unpackNumber(s.inner[68:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSecondaryMarket) OfferMessageBytesLimit() *Uint32 {
    var ret *Uint32
    start := unpackNumber(s.inner[68:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[72:])
        ret = Uint32FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint32FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellSecondaryMarket) AsBuilder() ConfigCellSecondaryMarketBuilder {
    ret := NewConfigCellSecondaryMarketBuilder().CommonFee(*s.CommonFee()).SaleMinPrice(*s.SaleMinPrice()).SaleExpirationLimit(*s.SaleExpirationLimit()).SaleDescriptionBytesLimit(*s.SaleDescriptionBytesLimit()).SaleCellBasicCapacity(*s.SaleCellBasicCapacity()).SaleCellPreparedFeeCapacity(*s.SaleCellPreparedFeeCapacity()).AuctionMaxExtendableDuration(*s.AuctionMaxExtendableDuration()).AuctionDurationIncrementEachBid(*s.AuctionDurationIncrementEachBid()).AuctionMinOpeningPrice(*s.AuctionMinOpeningPrice()).AuctionMinIncrementRateEachBid(*s.AuctionMinIncrementRateEachBid()).AuctionDescriptionBytesLimit(*s.AuctionDescriptionBytesLimit()).AuctionCellBasicCapacity(*s.AuctionCellBasicCapacity()).AuctionCellPreparedFeeCapacity(*s.AuctionCellPreparedFeeCapacity()).OfferMinPrice(*s.OfferMinPrice()).OfferCellBasicCapacity(*s.OfferCellBasicCapacity()).OfferCellPreparedFeeCapacity(*s.OfferCellPreparedFeeCapacity()).OfferMessageBytesLimit(*s.OfferMessageBytesLimit())
    return *ret
}
        

type ConfigCellReverseResolutionBuilder struct {
    record_basic_capacity Uint64
record_prepared_fee_capacity Uint64
common_fee Uint64
}
        

func (s *ConfigCellReverseResolutionBuilder) Build() ConfigCellReverseResolution {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (3 + 1)
    offsets := make([]uint32, 0, 3)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.record_basic_capacity.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.record_prepared_fee_capacity.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.common_fee.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.record_basic_capacity.AsSlice())
b.Write(s.record_prepared_fee_capacity.AsSlice())
b.Write(s.common_fee.AsSlice())
    return ConfigCellReverseResolution{inner: b.Bytes()}
}
                

func (s *ConfigCellReverseResolutionBuilder) RecordBasicCapacity(v Uint64) *ConfigCellReverseResolutionBuilder {
    s.record_basic_capacity = v
    return s
}
            

func (s *ConfigCellReverseResolutionBuilder) RecordPreparedFeeCapacity(v Uint64) *ConfigCellReverseResolutionBuilder {
    s.record_prepared_fee_capacity = v
    return s
}
            

func (s *ConfigCellReverseResolutionBuilder) CommonFee(v Uint64) *ConfigCellReverseResolutionBuilder {
    s.common_fee = v
    return s
}
            

func NewConfigCellReverseResolutionBuilder() *ConfigCellReverseResolutionBuilder {
	return &ConfigCellReverseResolutionBuilder{ record_basic_capacity: Uint64Default(),record_prepared_fee_capacity: Uint64Default(),common_fee: Uint64Default() }
}
    

type ConfigCellReverseResolution struct {
    inner []byte
}
        

func ConfigCellReverseResolutionFromSliceUnchecked(slice []byte) *ConfigCellReverseResolution {
    return &ConfigCellReverseResolution{inner: slice}
}
func (s *ConfigCellReverseResolution) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellReverseResolutionDefault() ConfigCellReverseResolution {
    return *ConfigCellReverseResolutionFromSliceUnchecked([]byte{ 40,0,0,0,16,0,0,0,24,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellReverseResolutionFromSlice(slice []byte, compatible bool) (*ConfigCellReverseResolution, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellReverseResolution", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellReverseResolution", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellReverseResolution", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellReverseResolution", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellReverseResolution", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 3 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 3 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint64FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellReverseResolution{inner: slice}, nil
}
            

func (s *ConfigCellReverseResolution) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellReverseResolution) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellReverseResolution) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellReverseResolution) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellReverseResolution) CountExtraFields() uint {
    return s.FieldCount() - 3
}

func (s *ConfigCellReverseResolution) HasExtraFields() bool {
    return 3 != s.FieldCount()
}
            

func (s *ConfigCellReverseResolution) RecordBasicCapacity() *Uint64 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellReverseResolution) RecordPreparedFeeCapacity() *Uint64 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellReverseResolution) CommonFee() *Uint64 {
    var ret *Uint64
    start := unpackNumber(s.inner[12:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[16:])
        ret = Uint64FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint64FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellReverseResolution) AsBuilder() ConfigCellReverseResolutionBuilder {
    ret := NewConfigCellReverseResolutionBuilder().RecordBasicCapacity(*s.RecordBasicCapacity()).RecordPreparedFeeCapacity(*s.RecordPreparedFeeCapacity()).CommonFee(*s.CommonFee())
    return *ret
}
        

type ConfigCellSubAccountBuilder struct {
    basic_capacity Uint64
prepared_fee_capacity Uint64
new_sub_account_price Uint64
renew_sub_account_price Uint64
common_fee Uint64
create_fee Uint64
edit_fee Uint64
renew_fee Uint64
recycle_fee Uint64
new_sub_account_custom_price_das_profit_rate Uint32
renew_sub_account_custom_price_das_profit_rate Uint32
}
        

func (s *ConfigCellSubAccountBuilder) Build() ConfigCellSubAccount {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (11 + 1)
    offsets := make([]uint32, 0, 11)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.basic_capacity.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.prepared_fee_capacity.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.new_sub_account_price.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.renew_sub_account_price.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.common_fee.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.create_fee.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.edit_fee.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.renew_fee.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.recycle_fee.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.new_sub_account_custom_price_das_profit_rate.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.renew_sub_account_custom_price_das_profit_rate.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.basic_capacity.AsSlice())
b.Write(s.prepared_fee_capacity.AsSlice())
b.Write(s.new_sub_account_price.AsSlice())
b.Write(s.renew_sub_account_price.AsSlice())
b.Write(s.common_fee.AsSlice())
b.Write(s.create_fee.AsSlice())
b.Write(s.edit_fee.AsSlice())
b.Write(s.renew_fee.AsSlice())
b.Write(s.recycle_fee.AsSlice())
b.Write(s.new_sub_account_custom_price_das_profit_rate.AsSlice())
b.Write(s.renew_sub_account_custom_price_das_profit_rate.AsSlice())
    return ConfigCellSubAccount{inner: b.Bytes()}
}
                

func (s *ConfigCellSubAccountBuilder) BasicCapacity(v Uint64) *ConfigCellSubAccountBuilder {
    s.basic_capacity = v
    return s
}
            

func (s *ConfigCellSubAccountBuilder) PreparedFeeCapacity(v Uint64) *ConfigCellSubAccountBuilder {
    s.prepared_fee_capacity = v
    return s
}
            

func (s *ConfigCellSubAccountBuilder) NewSubAccountPrice(v Uint64) *ConfigCellSubAccountBuilder {
    s.new_sub_account_price = v
    return s
}
            

func (s *ConfigCellSubAccountBuilder) RenewSubAccountPrice(v Uint64) *ConfigCellSubAccountBuilder {
    s.renew_sub_account_price = v
    return s
}
            

func (s *ConfigCellSubAccountBuilder) CommonFee(v Uint64) *ConfigCellSubAccountBuilder {
    s.common_fee = v
    return s
}
            

func (s *ConfigCellSubAccountBuilder) CreateFee(v Uint64) *ConfigCellSubAccountBuilder {
    s.create_fee = v
    return s
}
            

func (s *ConfigCellSubAccountBuilder) EditFee(v Uint64) *ConfigCellSubAccountBuilder {
    s.edit_fee = v
    return s
}
            

func (s *ConfigCellSubAccountBuilder) RenewFee(v Uint64) *ConfigCellSubAccountBuilder {
    s.renew_fee = v
    return s
}
            

func (s *ConfigCellSubAccountBuilder) RecycleFee(v Uint64) *ConfigCellSubAccountBuilder {
    s.recycle_fee = v
    return s
}
            

func (s *ConfigCellSubAccountBuilder) NewSubAccountCustomPriceDasProfitRate(v Uint32) *ConfigCellSubAccountBuilder {
    s.new_sub_account_custom_price_das_profit_rate = v
    return s
}
            

func (s *ConfigCellSubAccountBuilder) RenewSubAccountCustomPriceDasProfitRate(v Uint32) *ConfigCellSubAccountBuilder {
    s.renew_sub_account_custom_price_das_profit_rate = v
    return s
}
            

func NewConfigCellSubAccountBuilder() *ConfigCellSubAccountBuilder {
	return &ConfigCellSubAccountBuilder{ basic_capacity: Uint64Default(),prepared_fee_capacity: Uint64Default(),new_sub_account_price: Uint64Default(),renew_sub_account_price: Uint64Default(),common_fee: Uint64Default(),create_fee: Uint64Default(),edit_fee: Uint64Default(),renew_fee: Uint64Default(),recycle_fee: Uint64Default(),new_sub_account_custom_price_das_profit_rate: Uint32Default(),renew_sub_account_custom_price_das_profit_rate: Uint32Default() }
}
    

type ConfigCellSubAccount struct {
    inner []byte
}
        

func ConfigCellSubAccountFromSliceUnchecked(slice []byte) *ConfigCellSubAccount {
    return &ConfigCellSubAccount{inner: slice}
}
func (s *ConfigCellSubAccount) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellSubAccountDefault() ConfigCellSubAccount {
    return *ConfigCellSubAccountFromSliceUnchecked([]byte{ 128,0,0,0,48,0,0,0,56,0,0,0,64,0,0,0,72,0,0,0,80,0,0,0,88,0,0,0,96,0,0,0,104,0,0,0,112,0,0,0,120,0,0,0,124,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellSubAccountFromSlice(slice []byte, compatible bool) (*ConfigCellSubAccount, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellSubAccount", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellSubAccount", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellSubAccount", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellSubAccount", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellSubAccount", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 11 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 11 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint64FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[8]:offsets[9]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[9]:offsets[10]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[10]:offsets[11]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellSubAccount{inner: slice}, nil
}
            

func (s *ConfigCellSubAccount) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellSubAccount) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellSubAccount) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellSubAccount) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellSubAccount) CountExtraFields() uint {
    return s.FieldCount() - 11
}

func (s *ConfigCellSubAccount) HasExtraFields() bool {
    return 11 != s.FieldCount()
}
            

func (s *ConfigCellSubAccount) BasicCapacity() *Uint64 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSubAccount) PreparedFeeCapacity() *Uint64 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSubAccount) NewSubAccountPrice() *Uint64 {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSubAccount) RenewSubAccountPrice() *Uint64 {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSubAccount) CommonFee() *Uint64 {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSubAccount) CreateFee() *Uint64 {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSubAccount) EditFee() *Uint64 {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSubAccount) RenewFee() *Uint64 {
    start := unpackNumber(s.inner[32:])
    end := unpackNumber(s.inner[36:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSubAccount) RecycleFee() *Uint64 {
    start := unpackNumber(s.inner[36:])
    end := unpackNumber(s.inner[40:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSubAccount) NewSubAccountCustomPriceDasProfitRate() *Uint32 {
    start := unpackNumber(s.inner[40:])
    end := unpackNumber(s.inner[44:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSubAccount) RenewSubAccountCustomPriceDasProfitRate() *Uint32 {
    var ret *Uint32
    start := unpackNumber(s.inner[44:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[48:])
        ret = Uint32FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint32FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellSubAccount) AsBuilder() ConfigCellSubAccountBuilder {
    ret := NewConfigCellSubAccountBuilder().BasicCapacity(*s.BasicCapacity()).PreparedFeeCapacity(*s.PreparedFeeCapacity()).NewSubAccountPrice(*s.NewSubAccountPrice()).RenewSubAccountPrice(*s.RenewSubAccountPrice()).CommonFee(*s.CommonFee()).CreateFee(*s.CreateFee()).EditFee(*s.EditFee()).RenewFee(*s.RenewFee()).RecycleFee(*s.RecycleFee()).NewSubAccountCustomPriceDasProfitRate(*s.NewSubAccountCustomPriceDasProfitRate()).RenewSubAccountCustomPriceDasProfitRate(*s.RenewSubAccountCustomPriceDasProfitRate())
    return *ret
}
        

type ConfigCellSystemStatusBuilder struct {
    apply_register_cell_type ContractStatus
pre_account_cell_type ContractStatus
proposal_cell_type ContractStatus
config_cell_type ContractStatus
account_cell_type ContractStatus
account_sale_cell_type ContractStatus
sub_account_cell_type ContractStatus
offer_cell_type ContractStatus
balance_cell_type ContractStatus
income_cell_type ContractStatus
reverse_record_cell_type ContractStatus
reverse_record_root_cell_type ContractStatus
eip712_lib ContractStatus
}
        

func (s *ConfigCellSystemStatusBuilder) Build() ConfigCellSystemStatus {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (13 + 1)
    offsets := make([]uint32, 0, 13)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.apply_register_cell_type.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.pre_account_cell_type.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposal_cell_type.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.config_cell_type.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_cell_type.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_sale_cell_type.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.sub_account_cell_type.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.offer_cell_type.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.balance_cell_type.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.income_cell_type.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.reverse_record_cell_type.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.reverse_record_root_cell_type.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.eip712_lib.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.apply_register_cell_type.AsSlice())
b.Write(s.pre_account_cell_type.AsSlice())
b.Write(s.proposal_cell_type.AsSlice())
b.Write(s.config_cell_type.AsSlice())
b.Write(s.account_cell_type.AsSlice())
b.Write(s.account_sale_cell_type.AsSlice())
b.Write(s.sub_account_cell_type.AsSlice())
b.Write(s.offer_cell_type.AsSlice())
b.Write(s.balance_cell_type.AsSlice())
b.Write(s.income_cell_type.AsSlice())
b.Write(s.reverse_record_cell_type.AsSlice())
b.Write(s.reverse_record_root_cell_type.AsSlice())
b.Write(s.eip712_lib.AsSlice())
    return ConfigCellSystemStatus{inner: b.Bytes()}
}
                

func (s *ConfigCellSystemStatusBuilder) ApplyRegisterCellType(v ContractStatus) *ConfigCellSystemStatusBuilder {
    s.apply_register_cell_type = v
    return s
}
            

func (s *ConfigCellSystemStatusBuilder) PreAccountCellType(v ContractStatus) *ConfigCellSystemStatusBuilder {
    s.pre_account_cell_type = v
    return s
}
            

func (s *ConfigCellSystemStatusBuilder) ProposalCellType(v ContractStatus) *ConfigCellSystemStatusBuilder {
    s.proposal_cell_type = v
    return s
}
            

func (s *ConfigCellSystemStatusBuilder) ConfigCellType(v ContractStatus) *ConfigCellSystemStatusBuilder {
    s.config_cell_type = v
    return s
}
            

func (s *ConfigCellSystemStatusBuilder) AccountCellType(v ContractStatus) *ConfigCellSystemStatusBuilder {
    s.account_cell_type = v
    return s
}
            

func (s *ConfigCellSystemStatusBuilder) AccountSaleCellType(v ContractStatus) *ConfigCellSystemStatusBuilder {
    s.account_sale_cell_type = v
    return s
}
            

func (s *ConfigCellSystemStatusBuilder) SubAccountCellType(v ContractStatus) *ConfigCellSystemStatusBuilder {
    s.sub_account_cell_type = v
    return s
}
            

func (s *ConfigCellSystemStatusBuilder) OfferCellType(v ContractStatus) *ConfigCellSystemStatusBuilder {
    s.offer_cell_type = v
    return s
}
            

func (s *ConfigCellSystemStatusBuilder) BalanceCellType(v ContractStatus) *ConfigCellSystemStatusBuilder {
    s.balance_cell_type = v
    return s
}
            

func (s *ConfigCellSystemStatusBuilder) IncomeCellType(v ContractStatus) *ConfigCellSystemStatusBuilder {
    s.income_cell_type = v
    return s
}
            

func (s *ConfigCellSystemStatusBuilder) ReverseRecordCellType(v ContractStatus) *ConfigCellSystemStatusBuilder {
    s.reverse_record_cell_type = v
    return s
}
            

func (s *ConfigCellSystemStatusBuilder) ReverseRecordRootCellType(v ContractStatus) *ConfigCellSystemStatusBuilder {
    s.reverse_record_root_cell_type = v
    return s
}
            

func (s *ConfigCellSystemStatusBuilder) Eip712Lib(v ContractStatus) *ConfigCellSystemStatusBuilder {
    s.eip712_lib = v
    return s
}
            

func NewConfigCellSystemStatusBuilder() *ConfigCellSystemStatusBuilder {
	return &ConfigCellSystemStatusBuilder{ apply_register_cell_type: ContractStatusDefault(),pre_account_cell_type: ContractStatusDefault(),proposal_cell_type: ContractStatusDefault(),config_cell_type: ContractStatusDefault(),account_cell_type: ContractStatusDefault(),account_sale_cell_type: ContractStatusDefault(),sub_account_cell_type: ContractStatusDefault(),offer_cell_type: ContractStatusDefault(),balance_cell_type: ContractStatusDefault(),income_cell_type: ContractStatusDefault(),reverse_record_cell_type: ContractStatusDefault(),reverse_record_root_cell_type: ContractStatusDefault(),eip712_lib: ContractStatusDefault() }
}
    

type ConfigCellSystemStatus struct {
    inner []byte
}
        

func ConfigCellSystemStatusFromSliceUnchecked(slice []byte) *ConfigCellSystemStatus {
    return &ConfigCellSystemStatus{inner: slice}
}
func (s *ConfigCellSystemStatus) AsSlice() []byte {
    return s.inner
}
            

func ConfigCellSystemStatusDefault() ConfigCellSystemStatus {
    return *ConfigCellSystemStatusFromSliceUnchecked([]byte{ 21,1,0,0,56,0,0,0,73,0,0,0,90,0,0,0,107,0,0,0,124,0,0,0,141,0,0,0,158,0,0,0,175,0,0,0,192,0,0,0,209,0,0,0,226,0,0,0,243,0,0,0,4,1,0,0,17,0,0,0,12,0,0,0,13,0,0,0,0,0,0,0,0,17,0,0,0,12,0,0,0,13,0,0,0,0,0,0,0,0,17,0,0,0,12,0,0,0,13,0,0,0,0,0,0,0,0,17,0,0,0,12,0,0,0,13,0,0,0,0,0,0,0,0,17,0,0,0,12,0,0,0,13,0,0,0,0,0,0,0,0,17,0,0,0,12,0,0,0,13,0,0,0,0,0,0,0,0,17,0,0,0,12,0,0,0,13,0,0,0,0,0,0,0,0,17,0,0,0,12,0,0,0,13,0,0,0,0,0,0,0,0,17,0,0,0,12,0,0,0,13,0,0,0,0,0,0,0,0,17,0,0,0,12,0,0,0,13,0,0,0,0,0,0,0,0,17,0,0,0,12,0,0,0,13,0,0,0,0,0,0,0,0,17,0,0,0,12,0,0,0,13,0,0,0,0,0,0,0,0,17,0,0,0,12,0,0,0,13,0,0,0,0,0,0,0,0 })
}
            

func ConfigCellSystemStatusFromSlice(slice []byte, compatible bool) (*ConfigCellSystemStatus, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellSystemStatus", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellSystemStatus", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellSystemStatus", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellSystemStatus", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellSystemStatus", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 13 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 13 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = ContractStatusFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ContractStatusFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ContractStatusFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ContractStatusFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ContractStatusFromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ContractStatusFromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ContractStatusFromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ContractStatusFromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ContractStatusFromSlice(slice[offsets[8]:offsets[9]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ContractStatusFromSlice(slice[offsets[9]:offsets[10]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ContractStatusFromSlice(slice[offsets[10]:offsets[11]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ContractStatusFromSlice(slice[offsets[11]:offsets[12]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ContractStatusFromSlice(slice[offsets[12]:offsets[13]], compatible)
if err != nil {
    return nil, err
}
                

    return &ConfigCellSystemStatus{inner: slice}, nil
}
            

func (s *ConfigCellSystemStatus) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ConfigCellSystemStatus) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ConfigCellSystemStatus) Len() uint {
    return s.FieldCount()
}
func (s *ConfigCellSystemStatus) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ConfigCellSystemStatus) CountExtraFields() uint {
    return s.FieldCount() - 13
}

func (s *ConfigCellSystemStatus) HasExtraFields() bool {
    return 13 != s.FieldCount()
}
            

func (s *ConfigCellSystemStatus) ApplyRegisterCellType() *ContractStatus {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return ContractStatusFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSystemStatus) PreAccountCellType() *ContractStatus {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return ContractStatusFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSystemStatus) ProposalCellType() *ContractStatus {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return ContractStatusFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSystemStatus) ConfigCellType() *ContractStatus {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return ContractStatusFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSystemStatus) AccountCellType() *ContractStatus {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return ContractStatusFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSystemStatus) AccountSaleCellType() *ContractStatus {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return ContractStatusFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSystemStatus) SubAccountCellType() *ContractStatus {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return ContractStatusFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSystemStatus) OfferCellType() *ContractStatus {
    start := unpackNumber(s.inner[32:])
    end := unpackNumber(s.inner[36:])
    return ContractStatusFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSystemStatus) BalanceCellType() *ContractStatus {
    start := unpackNumber(s.inner[36:])
    end := unpackNumber(s.inner[40:])
    return ContractStatusFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSystemStatus) IncomeCellType() *ContractStatus {
    start := unpackNumber(s.inner[40:])
    end := unpackNumber(s.inner[44:])
    return ContractStatusFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSystemStatus) ReverseRecordCellType() *ContractStatus {
    start := unpackNumber(s.inner[44:])
    end := unpackNumber(s.inner[48:])
    return ContractStatusFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSystemStatus) ReverseRecordRootCellType() *ContractStatus {
    start := unpackNumber(s.inner[48:])
    end := unpackNumber(s.inner[52:])
    return ContractStatusFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ConfigCellSystemStatus) Eip712Lib() *ContractStatus {
    var ret *ContractStatus
    start := unpackNumber(s.inner[52:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[56:])
        ret = ContractStatusFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = ContractStatusFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ConfigCellSystemStatus) AsBuilder() ConfigCellSystemStatusBuilder {
    ret := NewConfigCellSystemStatusBuilder().ApplyRegisterCellType(*s.ApplyRegisterCellType()).PreAccountCellType(*s.PreAccountCellType()).ProposalCellType(*s.ProposalCellType()).ConfigCellType(*s.ConfigCellType()).AccountCellType(*s.AccountCellType()).AccountSaleCellType(*s.AccountSaleCellType()).SubAccountCellType(*s.SubAccountCellType()).OfferCellType(*s.OfferCellType()).BalanceCellType(*s.BalanceCellType()).IncomeCellType(*s.IncomeCellType()).ReverseRecordCellType(*s.ReverseRecordCellType()).ReverseRecordRootCellType(*s.ReverseRecordRootCellType()).Eip712Lib(*s.Eip712Lib())
    return *ret
}
        

type ContractStatusBuilder struct {
    status Byte
version Bytes
}
        

func (s *ContractStatusBuilder) Build() ContractStatus {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (2 + 1)
    offsets := make([]uint32, 0, 2)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.status.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.version.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.status.AsSlice())
b.Write(s.version.AsSlice())
    return ContractStatus{inner: b.Bytes()}
}
                

func (s *ContractStatusBuilder) Status(v Byte) *ContractStatusBuilder {
    s.status = v
    return s
}
            

func (s *ContractStatusBuilder) Version(v Bytes) *ContractStatusBuilder {
    s.version = v
    return s
}
            

func NewContractStatusBuilder() *ContractStatusBuilder {
	return &ContractStatusBuilder{ status: ByteDefault(),version: BytesDefault() }
}
    

type ContractStatus struct {
    inner []byte
}
        

func ContractStatusFromSliceUnchecked(slice []byte) *ContractStatus {
    return &ContractStatus{inner: slice}
}
func (s *ContractStatus) AsSlice() []byte {
    return s.inner
}
            

func ContractStatusDefault() ContractStatus {
    return *ContractStatusFromSliceUnchecked([]byte{ 17,0,0,0,12,0,0,0,13,0,0,0,0,0,0,0,0 })
}
            

func ContractStatusFromSlice(slice []byte, compatible bool) (*ContractStatus, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ContractStatus", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ContractStatus", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ContractStatus", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ContractStatus", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ContractStatus", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 2 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 2 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = ByteFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

    return &ContractStatus{inner: slice}, nil
}
            

func (s *ContractStatus) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ContractStatus) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ContractStatus) Len() uint {
    return s.FieldCount()
}
func (s *ContractStatus) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ContractStatus) CountExtraFields() uint {
    return s.FieldCount() - 2
}

func (s *ContractStatus) HasExtraFields() bool {
    return 2 != s.FieldCount()
}
            

func (s *ContractStatus) Status() *Byte {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return ByteFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ContractStatus) Version() *Bytes {
    var ret *Bytes
    start := unpackNumber(s.inner[8:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[12:])
        ret = BytesFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = BytesFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ContractStatus) AsBuilder() ContractStatusBuilder {
    ret := NewContractStatusBuilder().Status(*s.Status()).Version(*s.Version())
    return *ret
}
        

type ProposalCellDataBuilder struct {
    proposer_lock Script
created_at_height Uint64
slices SliceList
}
        

func (s *ProposalCellDataBuilder) Build() ProposalCellData {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (3 + 1)
    offsets := make([]uint32, 0, 3)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.proposer_lock.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.created_at_height.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.slices.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.proposer_lock.AsSlice())
b.Write(s.created_at_height.AsSlice())
b.Write(s.slices.AsSlice())
    return ProposalCellData{inner: b.Bytes()}
}
                

func (s *ProposalCellDataBuilder) ProposerLock(v Script) *ProposalCellDataBuilder {
    s.proposer_lock = v
    return s
}
            

func (s *ProposalCellDataBuilder) CreatedAtHeight(v Uint64) *ProposalCellDataBuilder {
    s.created_at_height = v
    return s
}
            

func (s *ProposalCellDataBuilder) Slices(v SliceList) *ProposalCellDataBuilder {
    s.slices = v
    return s
}
            

func NewProposalCellDataBuilder() *ProposalCellDataBuilder {
	return &ProposalCellDataBuilder{ proposer_lock: ScriptDefault(),created_at_height: Uint64Default(),slices: SliceListDefault() }
}
    

type ProposalCellData struct {
    inner []byte
}
        

func ProposalCellDataFromSliceUnchecked(slice []byte) *ProposalCellData {
    return &ProposalCellData{inner: slice}
}
func (s *ProposalCellData) AsSlice() []byte {
    return s.inner
}
            

func ProposalCellDataDefault() ProposalCellData {
    return *ProposalCellDataFromSliceUnchecked([]byte{ 81,0,0,0,16,0,0,0,69,0,0,0,77,0,0,0,53,0,0,0,16,0,0,0,48,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0 })
}
            

func ProposalCellDataFromSlice(slice []byte, compatible bool) (*ProposalCellData, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ProposalCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ProposalCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ProposalCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ProposalCellData", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ProposalCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 3 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 3 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = ScriptFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = SliceListFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

    return &ProposalCellData{inner: slice}, nil
}
            

func (s *ProposalCellData) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ProposalCellData) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ProposalCellData) Len() uint {
    return s.FieldCount()
}
func (s *ProposalCellData) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ProposalCellData) CountExtraFields() uint {
    return s.FieldCount() - 3
}

func (s *ProposalCellData) HasExtraFields() bool {
    return 3 != s.FieldCount()
}
            

func (s *ProposalCellData) ProposerLock() *Script {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return ScriptFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ProposalCellData) CreatedAtHeight() *Uint64 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ProposalCellData) Slices() *SliceList {
    var ret *SliceList
    start := unpackNumber(s.inner[12:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[16:])
        ret = SliceListFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = SliceListFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ProposalCellData) AsBuilder() ProposalCellDataBuilder {
    ret := NewProposalCellDataBuilder().ProposerLock(*s.ProposerLock()).CreatedAtHeight(*s.CreatedAtHeight()).Slices(*s.Slices())
    return *ret
}
        

type SliceListBuilder struct {
    inner []SL
}
    

func (s *SliceListBuilder) Build() SliceList {
    itemCount := len(s.inner)

    b := new(bytes.Buffer)

    // Empty dyn vector, just return size's bytes
    if itemCount == 0 {
        b.Write(packNumber(Number(HeaderSizeUint)))
        return SliceList{inner: b.Bytes()}
    }

    // Calculate first offset then loop for rest items offsets
    totalSize := HeaderSizeUint * uint32(itemCount+1)
    offsets := make([]uint32, 0, itemCount)
    offsets = append(offsets, totalSize)
    for i := 1; i < itemCount; i++ {
        totalSize += uint32(len(s.inner[i-1].AsSlice()))
        offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
    }
    totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < itemCount; i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    for i := 0; i < itemCount; i++ {
        b.Write(s.inner[i].AsSlice())
    }

    return SliceList{inner: b.Bytes()}
}
          

func (s *SliceListBuilder) Set(v []SL) *SliceListBuilder {
    s.inner = v
    return s
}
func (s *SliceListBuilder) Push(v SL) *SliceListBuilder {
    s.inner = append(s.inner, v)
    return s
}
func (s *SliceListBuilder) Extend(iter []SL) *SliceListBuilder {
    for i:=0; i < len(iter); i++ {
        s.inner = append(s.inner, iter[i])
    }
    return s
}
func (s *SliceListBuilder) Replace(index uint, v SL) *SL {
    if uint(len(s.inner)) > index {
        a := s.inner[index]
        s.inner[index] = v
        return &a
    }
    return nil
}
    

func NewSliceListBuilder() *SliceListBuilder {
	return &SliceListBuilder{ []SL{} }
}
        

type SliceList struct {
    inner []byte
}
        

func SliceListFromSliceUnchecked(slice []byte) *SliceList {
    return &SliceList{inner: slice}
}
func (s *SliceList) AsSlice() []byte {
    return s.inner
}
            

func SliceListDefault() SliceList {
    return *SliceListFromSliceUnchecked([]byte{ 4,0,0,0 })
}
            

func SliceListFromSlice(slice []byte, compatible bool) (*SliceList, error) {
    sliceLen := len(slice)

    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "SliceList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "SliceList", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint {
        return &SliceList{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "SliceList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "SliceList", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "SliceList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }
    itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

    offsets := make([]uint32, itemCount)

    for i := 0; i < int(itemCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }

    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            errMsg := strings.Join([]string{"OffsetsNotMatch", "SliceList"}, " ")
            return nil, errors.New(errMsg)
        }
    }

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 {
            start := offsets[i-1]
            end := offsets[i]
            _, err := SLFromSlice(slice[start:end], compatible)

            if err != nil {
                return nil, err
            }
        }
    }

    return &SliceList{inner: slice}, nil
}
            

func (s *SliceList) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *SliceList) ItemCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *SliceList) Len() uint {
    return s.ItemCount()
}
func (s *SliceList) IsEmpty() bool {
    return s.Len() == 0
}
// if *SL is nil, index is out of bounds
func (s *SliceList) Get(index uint) *SL {
    var b *SL
    if index < s.Len() {
        start_index := uint(HeaderSizeUint) * (1 + index)
        start := unpackNumber(s.inner[start_index:])

        if index == s.Len()-1 {
            b = SLFromSliceUnchecked(s.inner[start:])
        } else {
            end_index := start_index + uint(HeaderSizeUint)
            end := unpackNumber(s.inner[end_index:])
            b = SLFromSliceUnchecked(s.inner[start:end])
        }
    }
    return b
}
            

func (s *SliceList) AsBuilder() SliceListBuilder {
    size := s.ItemCount()
    t := NewSliceListBuilder()
    for i:=uint(0); i < size; i++ {
        t.Push(*s.Get(i))
    }
    return *t
}
        

type SLBuilder struct {
    inner []ProposalItem
}
    

func (s *SLBuilder) Build() SL {
    itemCount := len(s.inner)

    b := new(bytes.Buffer)

    // Empty dyn vector, just return size's bytes
    if itemCount == 0 {
        b.Write(packNumber(Number(HeaderSizeUint)))
        return SL{inner: b.Bytes()}
    }

    // Calculate first offset then loop for rest items offsets
    totalSize := HeaderSizeUint * uint32(itemCount+1)
    offsets := make([]uint32, 0, itemCount)
    offsets = append(offsets, totalSize)
    for i := 1; i < itemCount; i++ {
        totalSize += uint32(len(s.inner[i-1].AsSlice()))
        offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
    }
    totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < itemCount; i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    for i := 0; i < itemCount; i++ {
        b.Write(s.inner[i].AsSlice())
    }

    return SL{inner: b.Bytes()}
}
          

func (s *SLBuilder) Set(v []ProposalItem) *SLBuilder {
    s.inner = v
    return s
}
func (s *SLBuilder) Push(v ProposalItem) *SLBuilder {
    s.inner = append(s.inner, v)
    return s
}
func (s *SLBuilder) Extend(iter []ProposalItem) *SLBuilder {
    for i:=0; i < len(iter); i++ {
        s.inner = append(s.inner, iter[i])
    }
    return s
}
func (s *SLBuilder) Replace(index uint, v ProposalItem) *ProposalItem {
    if uint(len(s.inner)) > index {
        a := s.inner[index]
        s.inner[index] = v
        return &a
    }
    return nil
}
    

func NewSLBuilder() *SLBuilder {
	return &SLBuilder{ []ProposalItem{} }
}
        

type SL struct {
    inner []byte
}
        

func SLFromSliceUnchecked(slice []byte) *SL {
    return &SL{inner: slice}
}
func (s *SL) AsSlice() []byte {
    return s.inner
}
            

func SLDefault() SL {
    return *SLFromSliceUnchecked([]byte{ 4,0,0,0 })
}
            

func SLFromSlice(slice []byte, compatible bool) (*SL, error) {
    sliceLen := len(slice)

    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "SL", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "SL", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint {
        return &SL{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "SL", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "SL", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "SL", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }
    itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

    offsets := make([]uint32, itemCount)

    for i := 0; i < int(itemCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }

    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            errMsg := strings.Join([]string{"OffsetsNotMatch", "SL"}, " ")
            return nil, errors.New(errMsg)
        }
    }

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 {
            start := offsets[i-1]
            end := offsets[i]
            _, err := ProposalItemFromSlice(slice[start:end], compatible)

            if err != nil {
                return nil, err
            }
        }
    }

    return &SL{inner: slice}, nil
}
            

func (s *SL) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *SL) ItemCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *SL) Len() uint {
    return s.ItemCount()
}
func (s *SL) IsEmpty() bool {
    return s.Len() == 0
}
// if *ProposalItem is nil, index is out of bounds
func (s *SL) Get(index uint) *ProposalItem {
    var b *ProposalItem
    if index < s.Len() {
        start_index := uint(HeaderSizeUint) * (1 + index)
        start := unpackNumber(s.inner[start_index:])

        if index == s.Len()-1 {
            b = ProposalItemFromSliceUnchecked(s.inner[start:])
        } else {
            end_index := start_index + uint(HeaderSizeUint)
            end := unpackNumber(s.inner[end_index:])
            b = ProposalItemFromSliceUnchecked(s.inner[start:end])
        }
    }
    return b
}
            

func (s *SL) AsBuilder() SLBuilder {
    size := s.ItemCount()
    t := NewSLBuilder()
    for i:=uint(0); i < size; i++ {
        t.Push(*s.Get(i))
    }
    return *t
}
        

type ProposalItemBuilder struct {
    account_id AccountId
item_type Uint8
next AccountId
}
        

func (s *ProposalItemBuilder) Build() ProposalItem {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (3 + 1)
    offsets := make([]uint32, 0, 3)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_id.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.item_type.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.next.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.account_id.AsSlice())
b.Write(s.item_type.AsSlice())
b.Write(s.next.AsSlice())
    return ProposalItem{inner: b.Bytes()}
}
                

func (s *ProposalItemBuilder) AccountId(v AccountId) *ProposalItemBuilder {
    s.account_id = v
    return s
}
            

func (s *ProposalItemBuilder) ItemType(v Uint8) *ProposalItemBuilder {
    s.item_type = v
    return s
}
            

func (s *ProposalItemBuilder) Next(v AccountId) *ProposalItemBuilder {
    s.next = v
    return s
}
            

func NewProposalItemBuilder() *ProposalItemBuilder {
	return &ProposalItemBuilder{ account_id: AccountIdDefault(),item_type: Uint8Default(),next: AccountIdDefault() }
}
    

type ProposalItem struct {
    inner []byte
}
        

func ProposalItemFromSliceUnchecked(slice []byte) *ProposalItem {
    return &ProposalItem{inner: slice}
}
func (s *ProposalItem) AsSlice() []byte {
    return s.inner
}
            

func ProposalItemDefault() ProposalItem {
    return *ProposalItemFromSliceUnchecked([]byte{ 57,0,0,0,16,0,0,0,36,0,0,0,37,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ProposalItemFromSlice(slice []byte, compatible bool) (*ProposalItem, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ProposalItem", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ProposalItem", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ProposalItem", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ProposalItem", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ProposalItem", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 3 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 3 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = AccountIdFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint8FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = AccountIdFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

    return &ProposalItem{inner: slice}, nil
}
            

func (s *ProposalItem) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ProposalItem) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ProposalItem) Len() uint {
    return s.FieldCount()
}
func (s *ProposalItem) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ProposalItem) CountExtraFields() uint {
    return s.FieldCount() - 3
}

func (s *ProposalItem) HasExtraFields() bool {
    return 3 != s.FieldCount()
}
            

func (s *ProposalItem) AccountId() *AccountId {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return AccountIdFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ProposalItem) ItemType() *Uint8 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ProposalItem) Next() *AccountId {
    var ret *AccountId
    start := unpackNumber(s.inner[12:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[16:])
        ret = AccountIdFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = AccountIdFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ProposalItem) AsBuilder() ProposalItemBuilder {
    ret := NewProposalItemBuilder().AccountId(*s.AccountId()).ItemType(*s.ItemType()).Next(*s.Next())
    return *ret
}
        

type IncomeCellDataBuilder struct {
    creator Script
records IncomeRecords
}
        

func (s *IncomeCellDataBuilder) Build() IncomeCellData {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (2 + 1)
    offsets := make([]uint32, 0, 2)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.creator.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.records.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.creator.AsSlice())
b.Write(s.records.AsSlice())
    return IncomeCellData{inner: b.Bytes()}
}
                

func (s *IncomeCellDataBuilder) Creator(v Script) *IncomeCellDataBuilder {
    s.creator = v
    return s
}
            

func (s *IncomeCellDataBuilder) Records(v IncomeRecords) *IncomeCellDataBuilder {
    s.records = v
    return s
}
            

func NewIncomeCellDataBuilder() *IncomeCellDataBuilder {
	return &IncomeCellDataBuilder{ creator: ScriptDefault(),records: IncomeRecordsDefault() }
}
    

type IncomeCellData struct {
    inner []byte
}
        

func IncomeCellDataFromSliceUnchecked(slice []byte) *IncomeCellData {
    return &IncomeCellData{inner: slice}
}
func (s *IncomeCellData) AsSlice() []byte {
    return s.inner
}
            

func IncomeCellDataDefault() IncomeCellData {
    return *IncomeCellDataFromSliceUnchecked([]byte{ 69,0,0,0,12,0,0,0,65,0,0,0,53,0,0,0,16,0,0,0,48,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0 })
}
            

func IncomeCellDataFromSlice(slice []byte, compatible bool) (*IncomeCellData, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "IncomeCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "IncomeCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "IncomeCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "IncomeCellData", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "IncomeCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 2 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 2 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = ScriptFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = IncomeRecordsFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

    return &IncomeCellData{inner: slice}, nil
}
            

func (s *IncomeCellData) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *IncomeCellData) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *IncomeCellData) Len() uint {
    return s.FieldCount()
}
func (s *IncomeCellData) IsEmpty() bool {
    return s.Len() == 0
}
func (s *IncomeCellData) CountExtraFields() uint {
    return s.FieldCount() - 2
}

func (s *IncomeCellData) HasExtraFields() bool {
    return 2 != s.FieldCount()
}
            

func (s *IncomeCellData) Creator() *Script {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return ScriptFromSliceUnchecked(s.inner[start:end])
}
               

func (s *IncomeCellData) Records() *IncomeRecords {
    var ret *IncomeRecords
    start := unpackNumber(s.inner[8:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[12:])
        ret = IncomeRecordsFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = IncomeRecordsFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *IncomeCellData) AsBuilder() IncomeCellDataBuilder {
    ret := NewIncomeCellDataBuilder().Creator(*s.Creator()).Records(*s.Records())
    return *ret
}
        

type IncomeRecordsBuilder struct {
    inner []IncomeRecord
}
    

func (s *IncomeRecordsBuilder) Build() IncomeRecords {
    itemCount := len(s.inner)

    b := new(bytes.Buffer)

    // Empty dyn vector, just return size's bytes
    if itemCount == 0 {
        b.Write(packNumber(Number(HeaderSizeUint)))
        return IncomeRecords{inner: b.Bytes()}
    }

    // Calculate first offset then loop for rest items offsets
    totalSize := HeaderSizeUint * uint32(itemCount+1)
    offsets := make([]uint32, 0, itemCount)
    offsets = append(offsets, totalSize)
    for i := 1; i < itemCount; i++ {
        totalSize += uint32(len(s.inner[i-1].AsSlice()))
        offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
    }
    totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < itemCount; i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    for i := 0; i < itemCount; i++ {
        b.Write(s.inner[i].AsSlice())
    }

    return IncomeRecords{inner: b.Bytes()}
}
          

func (s *IncomeRecordsBuilder) Set(v []IncomeRecord) *IncomeRecordsBuilder {
    s.inner = v
    return s
}
func (s *IncomeRecordsBuilder) Push(v IncomeRecord) *IncomeRecordsBuilder {
    s.inner = append(s.inner, v)
    return s
}
func (s *IncomeRecordsBuilder) Extend(iter []IncomeRecord) *IncomeRecordsBuilder {
    for i:=0; i < len(iter); i++ {
        s.inner = append(s.inner, iter[i])
    }
    return s
}
func (s *IncomeRecordsBuilder) Replace(index uint, v IncomeRecord) *IncomeRecord {
    if uint(len(s.inner)) > index {
        a := s.inner[index]
        s.inner[index] = v
        return &a
    }
    return nil
}
    

func NewIncomeRecordsBuilder() *IncomeRecordsBuilder {
	return &IncomeRecordsBuilder{ []IncomeRecord{} }
}
        

type IncomeRecords struct {
    inner []byte
}
        

func IncomeRecordsFromSliceUnchecked(slice []byte) *IncomeRecords {
    return &IncomeRecords{inner: slice}
}
func (s *IncomeRecords) AsSlice() []byte {
    return s.inner
}
            

func IncomeRecordsDefault() IncomeRecords {
    return *IncomeRecordsFromSliceUnchecked([]byte{ 4,0,0,0 })
}
            

func IncomeRecordsFromSlice(slice []byte, compatible bool) (*IncomeRecords, error) {
    sliceLen := len(slice)

    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "IncomeRecords", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "IncomeRecords", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint {
        return &IncomeRecords{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "IncomeRecords", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "IncomeRecords", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "IncomeRecords", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }
    itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

    offsets := make([]uint32, itemCount)

    for i := 0; i < int(itemCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }

    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            errMsg := strings.Join([]string{"OffsetsNotMatch", "IncomeRecords"}, " ")
            return nil, errors.New(errMsg)
        }
    }

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 {
            start := offsets[i-1]
            end := offsets[i]
            _, err := IncomeRecordFromSlice(slice[start:end], compatible)

            if err != nil {
                return nil, err
            }
        }
    }

    return &IncomeRecords{inner: slice}, nil
}
            

func (s *IncomeRecords) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *IncomeRecords) ItemCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *IncomeRecords) Len() uint {
    return s.ItemCount()
}
func (s *IncomeRecords) IsEmpty() bool {
    return s.Len() == 0
}
// if *IncomeRecord is nil, index is out of bounds
func (s *IncomeRecords) Get(index uint) *IncomeRecord {
    var b *IncomeRecord
    if index < s.Len() {
        start_index := uint(HeaderSizeUint) * (1 + index)
        start := unpackNumber(s.inner[start_index:])

        if index == s.Len()-1 {
            b = IncomeRecordFromSliceUnchecked(s.inner[start:])
        } else {
            end_index := start_index + uint(HeaderSizeUint)
            end := unpackNumber(s.inner[end_index:])
            b = IncomeRecordFromSliceUnchecked(s.inner[start:end])
        }
    }
    return b
}
            

func (s *IncomeRecords) AsBuilder() IncomeRecordsBuilder {
    size := s.ItemCount()
    t := NewIncomeRecordsBuilder()
    for i:=uint(0); i < size; i++ {
        t.Push(*s.Get(i))
    }
    return *t
}
        

type IncomeRecordBuilder struct {
    belong_to Script
capacity Uint64
}
        

func (s *IncomeRecordBuilder) Build() IncomeRecord {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (2 + 1)
    offsets := make([]uint32, 0, 2)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.belong_to.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.capacity.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.belong_to.AsSlice())
b.Write(s.capacity.AsSlice())
    return IncomeRecord{inner: b.Bytes()}
}
                

func (s *IncomeRecordBuilder) BelongTo(v Script) *IncomeRecordBuilder {
    s.belong_to = v
    return s
}
            

func (s *IncomeRecordBuilder) Capacity(v Uint64) *IncomeRecordBuilder {
    s.capacity = v
    return s
}
            

func NewIncomeRecordBuilder() *IncomeRecordBuilder {
	return &IncomeRecordBuilder{ belong_to: ScriptDefault(),capacity: Uint64Default() }
}
    

type IncomeRecord struct {
    inner []byte
}
        

func IncomeRecordFromSliceUnchecked(slice []byte) *IncomeRecord {
    return &IncomeRecord{inner: slice}
}
func (s *IncomeRecord) AsSlice() []byte {
    return s.inner
}
            

func IncomeRecordDefault() IncomeRecord {
    return *IncomeRecordFromSliceUnchecked([]byte{ 73,0,0,0,12,0,0,0,65,0,0,0,53,0,0,0,16,0,0,0,48,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func IncomeRecordFromSlice(slice []byte, compatible bool) (*IncomeRecord, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "IncomeRecord", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "IncomeRecord", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "IncomeRecord", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "IncomeRecord", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "IncomeRecord", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 2 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 2 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = ScriptFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

    return &IncomeRecord{inner: slice}, nil
}
            

func (s *IncomeRecord) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *IncomeRecord) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *IncomeRecord) Len() uint {
    return s.FieldCount()
}
func (s *IncomeRecord) IsEmpty() bool {
    return s.Len() == 0
}
func (s *IncomeRecord) CountExtraFields() uint {
    return s.FieldCount() - 2
}

func (s *IncomeRecord) HasExtraFields() bool {
    return 2 != s.FieldCount()
}
            

func (s *IncomeRecord) BelongTo() *Script {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return ScriptFromSliceUnchecked(s.inner[start:end])
}
               

func (s *IncomeRecord) Capacity() *Uint64 {
    var ret *Uint64
    start := unpackNumber(s.inner[8:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[12:])
        ret = Uint64FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint64FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *IncomeRecord) AsBuilder() IncomeRecordBuilder {
    ret := NewIncomeRecordBuilder().BelongTo(*s.BelongTo()).Capacity(*s.Capacity())
    return *ret
}
        

type AccountCellDataV2Builder struct {
    id AccountId
account AccountChars
registered_at Uint64
last_transfer_account_at Uint64
last_edit_manager_at Uint64
last_edit_records_at Uint64
status Uint8
records Records
}
        

func (s *AccountCellDataV2Builder) Build() AccountCellDataV2 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (8 + 1)
    offsets := make([]uint32, 0, 8)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.id.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.registered_at.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.last_transfer_account_at.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.last_edit_manager_at.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.last_edit_records_at.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.status.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.records.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.id.AsSlice())
b.Write(s.account.AsSlice())
b.Write(s.registered_at.AsSlice())
b.Write(s.last_transfer_account_at.AsSlice())
b.Write(s.last_edit_manager_at.AsSlice())
b.Write(s.last_edit_records_at.AsSlice())
b.Write(s.status.AsSlice())
b.Write(s.records.AsSlice())
    return AccountCellDataV2{inner: b.Bytes()}
}
                

func (s *AccountCellDataV2Builder) Id(v AccountId) *AccountCellDataV2Builder {
    s.id = v
    return s
}
            

func (s *AccountCellDataV2Builder) Account(v AccountChars) *AccountCellDataV2Builder {
    s.account = v
    return s
}
            

func (s *AccountCellDataV2Builder) RegisteredAt(v Uint64) *AccountCellDataV2Builder {
    s.registered_at = v
    return s
}
            

func (s *AccountCellDataV2Builder) LastTransferAccountAt(v Uint64) *AccountCellDataV2Builder {
    s.last_transfer_account_at = v
    return s
}
            

func (s *AccountCellDataV2Builder) LastEditManagerAt(v Uint64) *AccountCellDataV2Builder {
    s.last_edit_manager_at = v
    return s
}
            

func (s *AccountCellDataV2Builder) LastEditRecordsAt(v Uint64) *AccountCellDataV2Builder {
    s.last_edit_records_at = v
    return s
}
            

func (s *AccountCellDataV2Builder) Status(v Uint8) *AccountCellDataV2Builder {
    s.status = v
    return s
}
            

func (s *AccountCellDataV2Builder) Records(v Records) *AccountCellDataV2Builder {
    s.records = v
    return s
}
            

func NewAccountCellDataV2Builder() *AccountCellDataV2Builder {
	return &AccountCellDataV2Builder{ id: AccountIdDefault(),account: AccountCharsDefault(),registered_at: Uint64Default(),last_transfer_account_at: Uint64Default(),last_edit_manager_at: Uint64Default(),last_edit_records_at: Uint64Default(),status: Uint8Default(),records: RecordsDefault() }
}
    

type AccountCellDataV2 struct {
    inner []byte
}
        

func AccountCellDataV2FromSliceUnchecked(slice []byte) *AccountCellDataV2 {
    return &AccountCellDataV2{inner: slice}
}
func (s *AccountCellDataV2) AsSlice() []byte {
    return s.inner
}
            

func AccountCellDataV2Default() AccountCellDataV2 {
    return *AccountCellDataV2FromSliceUnchecked([]byte{ 97,0,0,0,36,0,0,0,56,0,0,0,60,0,0,0,68,0,0,0,76,0,0,0,84,0,0,0,92,0,0,0,93,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0 })
}
            

func AccountCellDataV2FromSlice(slice []byte, compatible bool) (*AccountCellDataV2, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "AccountCellDataV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountCellDataV2", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountCellDataV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountCellDataV2", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "AccountCellDataV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 8 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 8 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = AccountIdFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = AccountCharsFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint8FromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = RecordsFromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

    return &AccountCellDataV2{inner: slice}, nil
}
            

func (s *AccountCellDataV2) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *AccountCellDataV2) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *AccountCellDataV2) Len() uint {
    return s.FieldCount()
}
func (s *AccountCellDataV2) IsEmpty() bool {
    return s.Len() == 0
}
func (s *AccountCellDataV2) CountExtraFields() uint {
    return s.FieldCount() - 8
}

func (s *AccountCellDataV2) HasExtraFields() bool {
    return 8 != s.FieldCount()
}
            

func (s *AccountCellDataV2) Id() *AccountId {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return AccountIdFromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountCellDataV2) Account() *AccountChars {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return AccountCharsFromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountCellDataV2) RegisteredAt() *Uint64 {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountCellDataV2) LastTransferAccountAt() *Uint64 {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountCellDataV2) LastEditManagerAt() *Uint64 {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountCellDataV2) LastEditRecordsAt() *Uint64 {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountCellDataV2) Status() *Uint8 {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountCellDataV2) Records() *Records {
    var ret *Records
    start := unpackNumber(s.inner[32:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[36:])
        ret = RecordsFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = RecordsFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *AccountCellDataV2) AsBuilder() AccountCellDataV2Builder {
    ret := NewAccountCellDataV2Builder().Id(*s.Id()).Account(*s.Account()).RegisteredAt(*s.RegisteredAt()).LastTransferAccountAt(*s.LastTransferAccountAt()).LastEditManagerAt(*s.LastEditManagerAt()).LastEditRecordsAt(*s.LastEditRecordsAt()).Status(*s.Status()).Records(*s.Records())
    return *ret
}
        

type AccountCellDataBuilder struct {
    id AccountId
account AccountChars
registered_at Uint64
last_transfer_account_at Uint64
last_edit_manager_at Uint64
last_edit_records_at Uint64
status Uint8
records Records
enable_sub_account Uint8
renew_sub_account_price Uint64
}
        

func (s *AccountCellDataBuilder) Build() AccountCellData {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (10 + 1)
    offsets := make([]uint32, 0, 10)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.id.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.registered_at.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.last_transfer_account_at.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.last_edit_manager_at.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.last_edit_records_at.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.status.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.records.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.enable_sub_account.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.renew_sub_account_price.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.id.AsSlice())
b.Write(s.account.AsSlice())
b.Write(s.registered_at.AsSlice())
b.Write(s.last_transfer_account_at.AsSlice())
b.Write(s.last_edit_manager_at.AsSlice())
b.Write(s.last_edit_records_at.AsSlice())
b.Write(s.status.AsSlice())
b.Write(s.records.AsSlice())
b.Write(s.enable_sub_account.AsSlice())
b.Write(s.renew_sub_account_price.AsSlice())
    return AccountCellData{inner: b.Bytes()}
}
                

func (s *AccountCellDataBuilder) Id(v AccountId) *AccountCellDataBuilder {
    s.id = v
    return s
}
            

func (s *AccountCellDataBuilder) Account(v AccountChars) *AccountCellDataBuilder {
    s.account = v
    return s
}
            

func (s *AccountCellDataBuilder) RegisteredAt(v Uint64) *AccountCellDataBuilder {
    s.registered_at = v
    return s
}
            

func (s *AccountCellDataBuilder) LastTransferAccountAt(v Uint64) *AccountCellDataBuilder {
    s.last_transfer_account_at = v
    return s
}
            

func (s *AccountCellDataBuilder) LastEditManagerAt(v Uint64) *AccountCellDataBuilder {
    s.last_edit_manager_at = v
    return s
}
            

func (s *AccountCellDataBuilder) LastEditRecordsAt(v Uint64) *AccountCellDataBuilder {
    s.last_edit_records_at = v
    return s
}
            

func (s *AccountCellDataBuilder) Status(v Uint8) *AccountCellDataBuilder {
    s.status = v
    return s
}
            

func (s *AccountCellDataBuilder) Records(v Records) *AccountCellDataBuilder {
    s.records = v
    return s
}
            

func (s *AccountCellDataBuilder) EnableSubAccount(v Uint8) *AccountCellDataBuilder {
    s.enable_sub_account = v
    return s
}
            

func (s *AccountCellDataBuilder) RenewSubAccountPrice(v Uint64) *AccountCellDataBuilder {
    s.renew_sub_account_price = v
    return s
}
            

func NewAccountCellDataBuilder() *AccountCellDataBuilder {
	return &AccountCellDataBuilder{ id: AccountIdDefault(),account: AccountCharsDefault(),registered_at: Uint64Default(),last_transfer_account_at: Uint64Default(),last_edit_manager_at: Uint64Default(),last_edit_records_at: Uint64Default(),status: Uint8Default(),records: RecordsDefault(),enable_sub_account: Uint8Default(),renew_sub_account_price: Uint64Default() }
}
    

type AccountCellData struct {
    inner []byte
}
        

func AccountCellDataFromSliceUnchecked(slice []byte) *AccountCellData {
    return &AccountCellData{inner: slice}
}
func (s *AccountCellData) AsSlice() []byte {
    return s.inner
}
            

func AccountCellDataDefault() AccountCellData {
    return *AccountCellDataFromSliceUnchecked([]byte{ 114,0,0,0,44,0,0,0,64,0,0,0,68,0,0,0,76,0,0,0,84,0,0,0,92,0,0,0,100,0,0,0,101,0,0,0,105,0,0,0,106,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func AccountCellDataFromSlice(slice []byte, compatible bool) (*AccountCellData, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "AccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountCellData", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "AccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 10 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 10 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = AccountIdFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = AccountCharsFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint8FromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = RecordsFromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint8FromSlice(slice[offsets[8]:offsets[9]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[9]:offsets[10]], compatible)
if err != nil {
    return nil, err
}
                

    return &AccountCellData{inner: slice}, nil
}
            

func (s *AccountCellData) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *AccountCellData) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *AccountCellData) Len() uint {
    return s.FieldCount()
}
func (s *AccountCellData) IsEmpty() bool {
    return s.Len() == 0
}
func (s *AccountCellData) CountExtraFields() uint {
    return s.FieldCount() - 10
}

func (s *AccountCellData) HasExtraFields() bool {
    return 10 != s.FieldCount()
}
            

func (s *AccountCellData) Id() *AccountId {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return AccountIdFromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountCellData) Account() *AccountChars {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return AccountCharsFromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountCellData) RegisteredAt() *Uint64 {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountCellData) LastTransferAccountAt() *Uint64 {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountCellData) LastEditManagerAt() *Uint64 {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountCellData) LastEditRecordsAt() *Uint64 {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountCellData) Status() *Uint8 {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountCellData) Records() *Records {
    start := unpackNumber(s.inner[32:])
    end := unpackNumber(s.inner[36:])
    return RecordsFromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountCellData) EnableSubAccount() *Uint8 {
    start := unpackNumber(s.inner[36:])
    end := unpackNumber(s.inner[40:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountCellData) RenewSubAccountPrice() *Uint64 {
    var ret *Uint64
    start := unpackNumber(s.inner[40:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[44:])
        ret = Uint64FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint64FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *AccountCellData) AsBuilder() AccountCellDataBuilder {
    ret := NewAccountCellDataBuilder().Id(*s.Id()).Account(*s.Account()).RegisteredAt(*s.RegisteredAt()).LastTransferAccountAt(*s.LastTransferAccountAt()).LastEditManagerAt(*s.LastEditManagerAt()).LastEditRecordsAt(*s.LastEditRecordsAt()).Status(*s.Status()).Records(*s.Records()).EnableSubAccount(*s.EnableSubAccount()).RenewSubAccountPrice(*s.RenewSubAccountPrice())
    return *ret
}
        

type AccountIdBuilder struct {
	inner [20]Byte
}

func NewAccountIdBuilder() *AccountIdBuilder {
	return &AccountIdBuilder{inner: [20]Byte{ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault(),ByteDefault()}}
}

func (s *AccountIdBuilder) Build() AccountId {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return AccountId{inner: b.Bytes()}
}
        

func (s *AccountIdBuilder) Set(v [20]Byte) *AccountIdBuilder {
	s.inner = v
	return s
}
        

func (s *AccountIdBuilder) Nth0(v Byte) *AccountIdBuilder {
	s.inner[0] = v
	return s
}
                

func (s *AccountIdBuilder) Nth1(v Byte) *AccountIdBuilder {
	s.inner[1] = v
	return s
}
                

func (s *AccountIdBuilder) Nth2(v Byte) *AccountIdBuilder {
	s.inner[2] = v
	return s
}
                

func (s *AccountIdBuilder) Nth3(v Byte) *AccountIdBuilder {
	s.inner[3] = v
	return s
}
                

func (s *AccountIdBuilder) Nth4(v Byte) *AccountIdBuilder {
	s.inner[4] = v
	return s
}
                

func (s *AccountIdBuilder) Nth5(v Byte) *AccountIdBuilder {
	s.inner[5] = v
	return s
}
                

func (s *AccountIdBuilder) Nth6(v Byte) *AccountIdBuilder {
	s.inner[6] = v
	return s
}
                

func (s *AccountIdBuilder) Nth7(v Byte) *AccountIdBuilder {
	s.inner[7] = v
	return s
}
                

func (s *AccountIdBuilder) Nth8(v Byte) *AccountIdBuilder {
	s.inner[8] = v
	return s
}
                

func (s *AccountIdBuilder) Nth9(v Byte) *AccountIdBuilder {
	s.inner[9] = v
	return s
}
                

func (s *AccountIdBuilder) Nth10(v Byte) *AccountIdBuilder {
	s.inner[10] = v
	return s
}
                

func (s *AccountIdBuilder) Nth11(v Byte) *AccountIdBuilder {
	s.inner[11] = v
	return s
}
                

func (s *AccountIdBuilder) Nth12(v Byte) *AccountIdBuilder {
	s.inner[12] = v
	return s
}
                

func (s *AccountIdBuilder) Nth13(v Byte) *AccountIdBuilder {
	s.inner[13] = v
	return s
}
                

func (s *AccountIdBuilder) Nth14(v Byte) *AccountIdBuilder {
	s.inner[14] = v
	return s
}
                

func (s *AccountIdBuilder) Nth15(v Byte) *AccountIdBuilder {
	s.inner[15] = v
	return s
}
                

func (s *AccountIdBuilder) Nth16(v Byte) *AccountIdBuilder {
	s.inner[16] = v
	return s
}
                

func (s *AccountIdBuilder) Nth17(v Byte) *AccountIdBuilder {
	s.inner[17] = v
	return s
}
                

func (s *AccountIdBuilder) Nth18(v Byte) *AccountIdBuilder {
	s.inner[18] = v
	return s
}
                

func (s *AccountIdBuilder) Nth19(v Byte) *AccountIdBuilder {
	s.inner[19] = v
	return s
}
                

type AccountId struct {
    inner []byte
}
        

func AccountIdFromSliceUnchecked(slice []byte) *AccountId {
    return &AccountId{inner: slice}
}
func (s *AccountId) AsSlice() []byte {
    return s.inner
}
            

func AccountIdDefault() AccountId {
    return *AccountIdFromSliceUnchecked([]byte{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func AccountIdFromSlice(slice []byte, _compatible bool) (*AccountId, error) {
    sliceLen := len(slice)
    if sliceLen != 20 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountId", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(20)}, " ")
        return nil, errors.New(errMsg)
    }
    return &AccountId{inner: slice}, nil
}
        

func (s *AccountId) RawData() []byte {
    return s.inner
}
            

func (s *AccountId) Nth0() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[0:1])
    return ret
}
            

func (s *AccountId) Nth1() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[1:2])
    return ret
}
            

func (s *AccountId) Nth2() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[2:3])
    return ret
}
            

func (s *AccountId) Nth3() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[3:4])
    return ret
}
            

func (s *AccountId) Nth4() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[4:5])
    return ret
}
            

func (s *AccountId) Nth5() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[5:6])
    return ret
}
            

func (s *AccountId) Nth6() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[6:7])
    return ret
}
            

func (s *AccountId) Nth7() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[7:8])
    return ret
}
            

func (s *AccountId) Nth8() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[8:9])
    return ret
}
            

func (s *AccountId) Nth9() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[9:10])
    return ret
}
            

func (s *AccountId) Nth10() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[10:11])
    return ret
}
            

func (s *AccountId) Nth11() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[11:12])
    return ret
}
            

func (s *AccountId) Nth12() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[12:13])
    return ret
}
            

func (s *AccountId) Nth13() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[13:14])
    return ret
}
            

func (s *AccountId) Nth14() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[14:15])
    return ret
}
            

func (s *AccountId) Nth15() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[15:16])
    return ret
}
            

func (s *AccountId) Nth16() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[16:17])
    return ret
}
            

func (s *AccountId) Nth17() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[17:18])
    return ret
}
            

func (s *AccountId) Nth18() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[18:19])
    return ret
}
            

func (s *AccountId) Nth19() *Byte {
    ret := ByteFromSliceUnchecked(s.inner[19:20])
    return ret
}
            

func (s *AccountId) AsBuilder() AccountIdBuilder {
	t := NewAccountIdBuilder()
	t.Nth0(*s.Nth0())
t.Nth1(*s.Nth1())
t.Nth2(*s.Nth2())
t.Nth3(*s.Nth3())
t.Nth4(*s.Nth4())
t.Nth5(*s.Nth5())
t.Nth6(*s.Nth6())
t.Nth7(*s.Nth7())
t.Nth8(*s.Nth8())
t.Nth9(*s.Nth9())
t.Nth10(*s.Nth10())
t.Nth11(*s.Nth11())
t.Nth12(*s.Nth12())
t.Nth13(*s.Nth13())
t.Nth14(*s.Nth14())
t.Nth15(*s.Nth15())
t.Nth16(*s.Nth16())
t.Nth17(*s.Nth17())
t.Nth18(*s.Nth18())
t.Nth19(*s.Nth19())
	return *t
}
        

type RecordBuilder struct {
    record_type Bytes
record_key Bytes
record_label Bytes
record_value Bytes
record_ttl Uint32
}
        

func (s *RecordBuilder) Build() Record {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (5 + 1)
    offsets := make([]uint32, 0, 5)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.record_type.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.record_key.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.record_label.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.record_value.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.record_ttl.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.record_type.AsSlice())
b.Write(s.record_key.AsSlice())
b.Write(s.record_label.AsSlice())
b.Write(s.record_value.AsSlice())
b.Write(s.record_ttl.AsSlice())
    return Record{inner: b.Bytes()}
}
                

func (s *RecordBuilder) RecordType(v Bytes) *RecordBuilder {
    s.record_type = v
    return s
}
            

func (s *RecordBuilder) RecordKey(v Bytes) *RecordBuilder {
    s.record_key = v
    return s
}
            

func (s *RecordBuilder) RecordLabel(v Bytes) *RecordBuilder {
    s.record_label = v
    return s
}
            

func (s *RecordBuilder) RecordValue(v Bytes) *RecordBuilder {
    s.record_value = v
    return s
}
            

func (s *RecordBuilder) RecordTtl(v Uint32) *RecordBuilder {
    s.record_ttl = v
    return s
}
            

func NewRecordBuilder() *RecordBuilder {
	return &RecordBuilder{ record_type: BytesDefault(),record_key: BytesDefault(),record_label: BytesDefault(),record_value: BytesDefault(),record_ttl: Uint32Default() }
}
    

type Record struct {
    inner []byte
}
        

func RecordFromSliceUnchecked(slice []byte) *Record {
    return &Record{inner: slice}
}
func (s *Record) AsSlice() []byte {
    return s.inner
}
            

func RecordDefault() Record {
    return *RecordFromSliceUnchecked([]byte{ 44,0,0,0,24,0,0,0,28,0,0,0,32,0,0,0,36,0,0,0,40,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func RecordFromSlice(slice []byte, compatible bool) (*Record, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "Record", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "Record", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "Record", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "Record", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "Record", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 5 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 5 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = BytesFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

    return &Record{inner: slice}, nil
}
            

func (s *Record) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *Record) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *Record) Len() uint {
    return s.FieldCount()
}
func (s *Record) IsEmpty() bool {
    return s.Len() == 0
}
func (s *Record) CountExtraFields() uint {
    return s.FieldCount() - 5
}

func (s *Record) HasExtraFields() bool {
    return 5 != s.FieldCount()
}
            

func (s *Record) RecordType() *Bytes {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *Record) RecordKey() *Bytes {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *Record) RecordLabel() *Bytes {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *Record) RecordValue() *Bytes {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *Record) RecordTtl() *Uint32 {
    var ret *Uint32
    start := unpackNumber(s.inner[20:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[24:])
        ret = Uint32FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint32FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *Record) AsBuilder() RecordBuilder {
    ret := NewRecordBuilder().RecordType(*s.RecordType()).RecordKey(*s.RecordKey()).RecordLabel(*s.RecordLabel()).RecordValue(*s.RecordValue()).RecordTtl(*s.RecordTtl())
    return *ret
}
        

type RecordsBuilder struct {
    inner []Record
}
    

func (s *RecordsBuilder) Build() Records {
    itemCount := len(s.inner)

    b := new(bytes.Buffer)

    // Empty dyn vector, just return size's bytes
    if itemCount == 0 {
        b.Write(packNumber(Number(HeaderSizeUint)))
        return Records{inner: b.Bytes()}
    }

    // Calculate first offset then loop for rest items offsets
    totalSize := HeaderSizeUint * uint32(itemCount+1)
    offsets := make([]uint32, 0, itemCount)
    offsets = append(offsets, totalSize)
    for i := 1; i < itemCount; i++ {
        totalSize += uint32(len(s.inner[i-1].AsSlice()))
        offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
    }
    totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < itemCount; i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    for i := 0; i < itemCount; i++ {
        b.Write(s.inner[i].AsSlice())
    }

    return Records{inner: b.Bytes()}
}
          

func (s *RecordsBuilder) Set(v []Record) *RecordsBuilder {
    s.inner = v
    return s
}
func (s *RecordsBuilder) Push(v Record) *RecordsBuilder {
    s.inner = append(s.inner, v)
    return s
}
func (s *RecordsBuilder) Extend(iter []Record) *RecordsBuilder {
    for i:=0; i < len(iter); i++ {
        s.inner = append(s.inner, iter[i])
    }
    return s
}
func (s *RecordsBuilder) Replace(index uint, v Record) *Record {
    if uint(len(s.inner)) > index {
        a := s.inner[index]
        s.inner[index] = v
        return &a
    }
    return nil
}
    

func NewRecordsBuilder() *RecordsBuilder {
	return &RecordsBuilder{ []Record{} }
}
        

type Records struct {
    inner []byte
}
        

func RecordsFromSliceUnchecked(slice []byte) *Records {
    return &Records{inner: slice}
}
func (s *Records) AsSlice() []byte {
    return s.inner
}
            

func RecordsDefault() Records {
    return *RecordsFromSliceUnchecked([]byte{ 4,0,0,0 })
}
            

func RecordsFromSlice(slice []byte, compatible bool) (*Records, error) {
    sliceLen := len(slice)

    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "Records", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "Records", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint {
        return &Records{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "Records", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "Records", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "Records", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }
    itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

    offsets := make([]uint32, itemCount)

    for i := 0; i < int(itemCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }

    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            errMsg := strings.Join([]string{"OffsetsNotMatch", "Records"}, " ")
            return nil, errors.New(errMsg)
        }
    }

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 {
            start := offsets[i-1]
            end := offsets[i]
            _, err := RecordFromSlice(slice[start:end], compatible)

            if err != nil {
                return nil, err
            }
        }
    }

    return &Records{inner: slice}, nil
}
            

func (s *Records) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *Records) ItemCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *Records) Len() uint {
    return s.ItemCount()
}
func (s *Records) IsEmpty() bool {
    return s.Len() == 0
}
// if *Record is nil, index is out of bounds
func (s *Records) Get(index uint) *Record {
    var b *Record
    if index < s.Len() {
        start_index := uint(HeaderSizeUint) * (1 + index)
        start := unpackNumber(s.inner[start_index:])

        if index == s.Len()-1 {
            b = RecordFromSliceUnchecked(s.inner[start:])
        } else {
            end_index := start_index + uint(HeaderSizeUint)
            end := unpackNumber(s.inner[end_index:])
            b = RecordFromSliceUnchecked(s.inner[start:end])
        }
    }
    return b
}
            

func (s *Records) AsBuilder() RecordsBuilder {
    size := s.ItemCount()
    t := NewRecordsBuilder()
    for i:=uint(0); i < size; i++ {
        t.Push(*s.Get(i))
    }
    return *t
}
        

type AccountSaleCellDataV1Builder struct {
    account_id AccountId
account Bytes
price Uint64
description Bytes
started_at Uint64
}
        

func (s *AccountSaleCellDataV1Builder) Build() AccountSaleCellDataV1 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (5 + 1)
    offsets := make([]uint32, 0, 5)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_id.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.price.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.description.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.started_at.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.account_id.AsSlice())
b.Write(s.account.AsSlice())
b.Write(s.price.AsSlice())
b.Write(s.description.AsSlice())
b.Write(s.started_at.AsSlice())
    return AccountSaleCellDataV1{inner: b.Bytes()}
}
                

func (s *AccountSaleCellDataV1Builder) AccountId(v AccountId) *AccountSaleCellDataV1Builder {
    s.account_id = v
    return s
}
            

func (s *AccountSaleCellDataV1Builder) Account(v Bytes) *AccountSaleCellDataV1Builder {
    s.account = v
    return s
}
            

func (s *AccountSaleCellDataV1Builder) Price(v Uint64) *AccountSaleCellDataV1Builder {
    s.price = v
    return s
}
            

func (s *AccountSaleCellDataV1Builder) Description(v Bytes) *AccountSaleCellDataV1Builder {
    s.description = v
    return s
}
            

func (s *AccountSaleCellDataV1Builder) StartedAt(v Uint64) *AccountSaleCellDataV1Builder {
    s.started_at = v
    return s
}
            

func NewAccountSaleCellDataV1Builder() *AccountSaleCellDataV1Builder {
	return &AccountSaleCellDataV1Builder{ account_id: AccountIdDefault(),account: BytesDefault(),price: Uint64Default(),description: BytesDefault(),started_at: Uint64Default() }
}
    

type AccountSaleCellDataV1 struct {
    inner []byte
}
        

func AccountSaleCellDataV1FromSliceUnchecked(slice []byte) *AccountSaleCellDataV1 {
    return &AccountSaleCellDataV1{inner: slice}
}
func (s *AccountSaleCellDataV1) AsSlice() []byte {
    return s.inner
}
            

func AccountSaleCellDataV1Default() AccountSaleCellDataV1 {
    return *AccountSaleCellDataV1FromSliceUnchecked([]byte{ 68,0,0,0,24,0,0,0,44,0,0,0,48,0,0,0,56,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func AccountSaleCellDataV1FromSlice(slice []byte, compatible bool) (*AccountSaleCellDataV1, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "AccountSaleCellDataV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountSaleCellDataV1", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountSaleCellDataV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountSaleCellDataV1", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "AccountSaleCellDataV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 5 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 5 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = AccountIdFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

    return &AccountSaleCellDataV1{inner: slice}, nil
}
            

func (s *AccountSaleCellDataV1) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *AccountSaleCellDataV1) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *AccountSaleCellDataV1) Len() uint {
    return s.FieldCount()
}
func (s *AccountSaleCellDataV1) IsEmpty() bool {
    return s.Len() == 0
}
func (s *AccountSaleCellDataV1) CountExtraFields() uint {
    return s.FieldCount() - 5
}

func (s *AccountSaleCellDataV1) HasExtraFields() bool {
    return 5 != s.FieldCount()
}
            

func (s *AccountSaleCellDataV1) AccountId() *AccountId {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return AccountIdFromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountSaleCellDataV1) Account() *Bytes {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountSaleCellDataV1) Price() *Uint64 {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountSaleCellDataV1) Description() *Bytes {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountSaleCellDataV1) StartedAt() *Uint64 {
    var ret *Uint64
    start := unpackNumber(s.inner[20:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[24:])
        ret = Uint64FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint64FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *AccountSaleCellDataV1) AsBuilder() AccountSaleCellDataV1Builder {
    ret := NewAccountSaleCellDataV1Builder().AccountId(*s.AccountId()).Account(*s.Account()).Price(*s.Price()).Description(*s.Description()).StartedAt(*s.StartedAt())
    return *ret
}
        

type AccountSaleCellDataBuilder struct {
    account_id AccountId
account Bytes
price Uint64
description Bytes
started_at Uint64
buyer_inviter_profit_rate Uint32
}
        

func (s *AccountSaleCellDataBuilder) Build() AccountSaleCellData {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (6 + 1)
    offsets := make([]uint32, 0, 6)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_id.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.price.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.description.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.started_at.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.buyer_inviter_profit_rate.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.account_id.AsSlice())
b.Write(s.account.AsSlice())
b.Write(s.price.AsSlice())
b.Write(s.description.AsSlice())
b.Write(s.started_at.AsSlice())
b.Write(s.buyer_inviter_profit_rate.AsSlice())
    return AccountSaleCellData{inner: b.Bytes()}
}
                

func (s *AccountSaleCellDataBuilder) AccountId(v AccountId) *AccountSaleCellDataBuilder {
    s.account_id = v
    return s
}
            

func (s *AccountSaleCellDataBuilder) Account(v Bytes) *AccountSaleCellDataBuilder {
    s.account = v
    return s
}
            

func (s *AccountSaleCellDataBuilder) Price(v Uint64) *AccountSaleCellDataBuilder {
    s.price = v
    return s
}
            

func (s *AccountSaleCellDataBuilder) Description(v Bytes) *AccountSaleCellDataBuilder {
    s.description = v
    return s
}
            

func (s *AccountSaleCellDataBuilder) StartedAt(v Uint64) *AccountSaleCellDataBuilder {
    s.started_at = v
    return s
}
            

func (s *AccountSaleCellDataBuilder) BuyerInviterProfitRate(v Uint32) *AccountSaleCellDataBuilder {
    s.buyer_inviter_profit_rate = v
    return s
}
            

func NewAccountSaleCellDataBuilder() *AccountSaleCellDataBuilder {
	return &AccountSaleCellDataBuilder{ account_id: AccountIdDefault(),account: BytesDefault(),price: Uint64Default(),description: BytesDefault(),started_at: Uint64Default(),buyer_inviter_profit_rate: Uint32Default() }
}
    

type AccountSaleCellData struct {
    inner []byte
}
        

func AccountSaleCellDataFromSliceUnchecked(slice []byte) *AccountSaleCellData {
    return &AccountSaleCellData{inner: slice}
}
func (s *AccountSaleCellData) AsSlice() []byte {
    return s.inner
}
            

func AccountSaleCellDataDefault() AccountSaleCellData {
    return *AccountSaleCellDataFromSliceUnchecked([]byte{ 76,0,0,0,28,0,0,0,48,0,0,0,52,0,0,0,60,0,0,0,64,0,0,0,72,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func AccountSaleCellDataFromSlice(slice []byte, compatible bool) (*AccountSaleCellData, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "AccountSaleCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountSaleCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountSaleCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountSaleCellData", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "AccountSaleCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 6 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 6 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = AccountIdFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

    return &AccountSaleCellData{inner: slice}, nil
}
            

func (s *AccountSaleCellData) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *AccountSaleCellData) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *AccountSaleCellData) Len() uint {
    return s.FieldCount()
}
func (s *AccountSaleCellData) IsEmpty() bool {
    return s.Len() == 0
}
func (s *AccountSaleCellData) CountExtraFields() uint {
    return s.FieldCount() - 6
}

func (s *AccountSaleCellData) HasExtraFields() bool {
    return 6 != s.FieldCount()
}
            

func (s *AccountSaleCellData) AccountId() *AccountId {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return AccountIdFromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountSaleCellData) Account() *Bytes {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountSaleCellData) Price() *Uint64 {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountSaleCellData) Description() *Bytes {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountSaleCellData) StartedAt() *Uint64 {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountSaleCellData) BuyerInviterProfitRate() *Uint32 {
    var ret *Uint32
    start := unpackNumber(s.inner[24:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[28:])
        ret = Uint32FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint32FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *AccountSaleCellData) AsBuilder() AccountSaleCellDataBuilder {
    ret := NewAccountSaleCellDataBuilder().AccountId(*s.AccountId()).Account(*s.Account()).Price(*s.Price()).Description(*s.Description()).StartedAt(*s.StartedAt()).BuyerInviterProfitRate(*s.BuyerInviterProfitRate())
    return *ret
}
        

type AccountAuctionCellDataBuilder struct {
    account_id AccountId
account Bytes
description Bytes
opening_price Uint64
increment_rate_each_bid Uint32
started_at Uint64
ended_at Uint64
current_bidder_lock Script
current_bid_price Uint64
prev_bidder_profit_rate Uint32
}
        

func (s *AccountAuctionCellDataBuilder) Build() AccountAuctionCellData {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (10 + 1)
    offsets := make([]uint32, 0, 10)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account_id.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.description.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.opening_price.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.increment_rate_each_bid.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.started_at.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.ended_at.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.current_bidder_lock.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.current_bid_price.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.prev_bidder_profit_rate.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.account_id.AsSlice())
b.Write(s.account.AsSlice())
b.Write(s.description.AsSlice())
b.Write(s.opening_price.AsSlice())
b.Write(s.increment_rate_each_bid.AsSlice())
b.Write(s.started_at.AsSlice())
b.Write(s.ended_at.AsSlice())
b.Write(s.current_bidder_lock.AsSlice())
b.Write(s.current_bid_price.AsSlice())
b.Write(s.prev_bidder_profit_rate.AsSlice())
    return AccountAuctionCellData{inner: b.Bytes()}
}
                

func (s *AccountAuctionCellDataBuilder) AccountId(v AccountId) *AccountAuctionCellDataBuilder {
    s.account_id = v
    return s
}
            

func (s *AccountAuctionCellDataBuilder) Account(v Bytes) *AccountAuctionCellDataBuilder {
    s.account = v
    return s
}
            

func (s *AccountAuctionCellDataBuilder) Description(v Bytes) *AccountAuctionCellDataBuilder {
    s.description = v
    return s
}
            

func (s *AccountAuctionCellDataBuilder) OpeningPrice(v Uint64) *AccountAuctionCellDataBuilder {
    s.opening_price = v
    return s
}
            

func (s *AccountAuctionCellDataBuilder) IncrementRateEachBid(v Uint32) *AccountAuctionCellDataBuilder {
    s.increment_rate_each_bid = v
    return s
}
            

func (s *AccountAuctionCellDataBuilder) StartedAt(v Uint64) *AccountAuctionCellDataBuilder {
    s.started_at = v
    return s
}
            

func (s *AccountAuctionCellDataBuilder) EndedAt(v Uint64) *AccountAuctionCellDataBuilder {
    s.ended_at = v
    return s
}
            

func (s *AccountAuctionCellDataBuilder) CurrentBidderLock(v Script) *AccountAuctionCellDataBuilder {
    s.current_bidder_lock = v
    return s
}
            

func (s *AccountAuctionCellDataBuilder) CurrentBidPrice(v Uint64) *AccountAuctionCellDataBuilder {
    s.current_bid_price = v
    return s
}
            

func (s *AccountAuctionCellDataBuilder) PrevBidderProfitRate(v Uint32) *AccountAuctionCellDataBuilder {
    s.prev_bidder_profit_rate = v
    return s
}
            

func NewAccountAuctionCellDataBuilder() *AccountAuctionCellDataBuilder {
	return &AccountAuctionCellDataBuilder{ account_id: AccountIdDefault(),account: BytesDefault(),description: BytesDefault(),opening_price: Uint64Default(),increment_rate_each_bid: Uint32Default(),started_at: Uint64Default(),ended_at: Uint64Default(),current_bidder_lock: ScriptDefault(),current_bid_price: Uint64Default(),prev_bidder_profit_rate: Uint32Default() }
}
    

type AccountAuctionCellData struct {
    inner []byte
}
        

func AccountAuctionCellDataFromSliceUnchecked(slice []byte) *AccountAuctionCellData {
    return &AccountAuctionCellData{inner: slice}
}
func (s *AccountAuctionCellData) AsSlice() []byte {
    return s.inner
}
            

func AccountAuctionCellDataDefault() AccountAuctionCellData {
    return *AccountAuctionCellDataFromSliceUnchecked([]byte{ 165,0,0,0,44,0,0,0,64,0,0,0,68,0,0,0,72,0,0,0,80,0,0,0,84,0,0,0,92,0,0,0,100,0,0,0,153,0,0,0,161,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,53,0,0,0,16,0,0,0,48,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func AccountAuctionCellDataFromSlice(slice []byte, compatible bool) (*AccountAuctionCellData, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "AccountAuctionCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountAuctionCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountAuctionCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountAuctionCellData", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "AccountAuctionCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 10 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 10 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = AccountIdFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ScriptFromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[8]:offsets[9]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[9]:offsets[10]], compatible)
if err != nil {
    return nil, err
}
                

    return &AccountAuctionCellData{inner: slice}, nil
}
            

func (s *AccountAuctionCellData) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *AccountAuctionCellData) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *AccountAuctionCellData) Len() uint {
    return s.FieldCount()
}
func (s *AccountAuctionCellData) IsEmpty() bool {
    return s.Len() == 0
}
func (s *AccountAuctionCellData) CountExtraFields() uint {
    return s.FieldCount() - 10
}

func (s *AccountAuctionCellData) HasExtraFields() bool {
    return 10 != s.FieldCount()
}
            

func (s *AccountAuctionCellData) AccountId() *AccountId {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return AccountIdFromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountAuctionCellData) Account() *Bytes {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountAuctionCellData) Description() *Bytes {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountAuctionCellData) OpeningPrice() *Uint64 {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountAuctionCellData) IncrementRateEachBid() *Uint32 {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountAuctionCellData) StartedAt() *Uint64 {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountAuctionCellData) EndedAt() *Uint64 {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountAuctionCellData) CurrentBidderLock() *Script {
    start := unpackNumber(s.inner[32:])
    end := unpackNumber(s.inner[36:])
    return ScriptFromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountAuctionCellData) CurrentBidPrice() *Uint64 {
    start := unpackNumber(s.inner[36:])
    end := unpackNumber(s.inner[40:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountAuctionCellData) PrevBidderProfitRate() *Uint32 {
    var ret *Uint32
    start := unpackNumber(s.inner[40:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[44:])
        ret = Uint32FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint32FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *AccountAuctionCellData) AsBuilder() AccountAuctionCellDataBuilder {
    ret := NewAccountAuctionCellDataBuilder().AccountId(*s.AccountId()).Account(*s.Account()).Description(*s.Description()).OpeningPrice(*s.OpeningPrice()).IncrementRateEachBid(*s.IncrementRateEachBid()).StartedAt(*s.StartedAt()).EndedAt(*s.EndedAt()).CurrentBidderLock(*s.CurrentBidderLock()).CurrentBidPrice(*s.CurrentBidPrice()).PrevBidderProfitRate(*s.PrevBidderProfitRate())
    return *ret
}
        

type PreAccountCellDataV1Builder struct {
    account AccountChars
refund_lock Script
owner_lock_args Bytes
inviter_id Bytes
inviter_lock ScriptOpt
channel_lock ScriptOpt
price PriceConfig
quote Uint64
invited_discount Uint32
created_at Uint64
}
        

func (s *PreAccountCellDataV1Builder) Build() PreAccountCellDataV1 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (10 + 1)
    offsets := make([]uint32, 0, 10)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.refund_lock.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.owner_lock_args.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.inviter_id.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.inviter_lock.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.channel_lock.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.price.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.quote.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.invited_discount.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.created_at.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.account.AsSlice())
b.Write(s.refund_lock.AsSlice())
b.Write(s.owner_lock_args.AsSlice())
b.Write(s.inviter_id.AsSlice())
b.Write(s.inviter_lock.AsSlice())
b.Write(s.channel_lock.AsSlice())
b.Write(s.price.AsSlice())
b.Write(s.quote.AsSlice())
b.Write(s.invited_discount.AsSlice())
b.Write(s.created_at.AsSlice())
    return PreAccountCellDataV1{inner: b.Bytes()}
}
                

func (s *PreAccountCellDataV1Builder) Account(v AccountChars) *PreAccountCellDataV1Builder {
    s.account = v
    return s
}
            

func (s *PreAccountCellDataV1Builder) RefundLock(v Script) *PreAccountCellDataV1Builder {
    s.refund_lock = v
    return s
}
            

func (s *PreAccountCellDataV1Builder) OwnerLockArgs(v Bytes) *PreAccountCellDataV1Builder {
    s.owner_lock_args = v
    return s
}
            

func (s *PreAccountCellDataV1Builder) InviterId(v Bytes) *PreAccountCellDataV1Builder {
    s.inviter_id = v
    return s
}
            

func (s *PreAccountCellDataV1Builder) InviterLock(v ScriptOpt) *PreAccountCellDataV1Builder {
    s.inviter_lock = v
    return s
}
            

func (s *PreAccountCellDataV1Builder) ChannelLock(v ScriptOpt) *PreAccountCellDataV1Builder {
    s.channel_lock = v
    return s
}
            

func (s *PreAccountCellDataV1Builder) Price(v PriceConfig) *PreAccountCellDataV1Builder {
    s.price = v
    return s
}
            

func (s *PreAccountCellDataV1Builder) Quote(v Uint64) *PreAccountCellDataV1Builder {
    s.quote = v
    return s
}
            

func (s *PreAccountCellDataV1Builder) InvitedDiscount(v Uint32) *PreAccountCellDataV1Builder {
    s.invited_discount = v
    return s
}
            

func (s *PreAccountCellDataV1Builder) CreatedAt(v Uint64) *PreAccountCellDataV1Builder {
    s.created_at = v
    return s
}
            

func NewPreAccountCellDataV1Builder() *PreAccountCellDataV1Builder {
	return &PreAccountCellDataV1Builder{ account: AccountCharsDefault(),refund_lock: ScriptDefault(),owner_lock_args: BytesDefault(),inviter_id: BytesDefault(),inviter_lock: ScriptOptDefault(),channel_lock: ScriptOptDefault(),price: PriceConfigDefault(),quote: Uint64Default(),invited_discount: Uint32Default(),created_at: Uint64Default() }
}
    

type PreAccountCellDataV1 struct {
    inner []byte
}
        

func PreAccountCellDataV1FromSliceUnchecked(slice []byte) *PreAccountCellDataV1 {
    return &PreAccountCellDataV1{inner: slice}
}
func (s *PreAccountCellDataV1) AsSlice() []byte {
    return s.inner
}
            

func PreAccountCellDataV1Default() PreAccountCellDataV1 {
    return *PreAccountCellDataV1FromSliceUnchecked([]byte{ 162,0,0,0,44,0,0,0,48,0,0,0,101,0,0,0,105,0,0,0,109,0,0,0,109,0,0,0,109,0,0,0,142,0,0,0,150,0,0,0,154,0,0,0,4,0,0,0,53,0,0,0,16,0,0,0,48,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,33,0,0,0,16,0,0,0,17,0,0,0,25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func PreAccountCellDataV1FromSlice(slice []byte, compatible bool) (*PreAccountCellDataV1, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "PreAccountCellDataV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "PreAccountCellDataV1", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "PreAccountCellDataV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "PreAccountCellDataV1", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "PreAccountCellDataV1", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 10 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 10 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = AccountCharsFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ScriptFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ScriptOptFromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ScriptOptFromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = PriceConfigFromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[8]:offsets[9]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[9]:offsets[10]], compatible)
if err != nil {
    return nil, err
}
                

    return &PreAccountCellDataV1{inner: slice}, nil
}
            

func (s *PreAccountCellDataV1) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *PreAccountCellDataV1) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *PreAccountCellDataV1) Len() uint {
    return s.FieldCount()
}
func (s *PreAccountCellDataV1) IsEmpty() bool {
    return s.Len() == 0
}
func (s *PreAccountCellDataV1) CountExtraFields() uint {
    return s.FieldCount() - 10
}

func (s *PreAccountCellDataV1) HasExtraFields() bool {
    return 10 != s.FieldCount()
}
            

func (s *PreAccountCellDataV1) Account() *AccountChars {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return AccountCharsFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellDataV1) RefundLock() *Script {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return ScriptFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellDataV1) OwnerLockArgs() *Bytes {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellDataV1) InviterId() *Bytes {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellDataV1) InviterLock() *ScriptOpt {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return ScriptOptFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellDataV1) ChannelLock() *ScriptOpt {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return ScriptOptFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellDataV1) Price() *PriceConfig {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return PriceConfigFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellDataV1) Quote() *Uint64 {
    start := unpackNumber(s.inner[32:])
    end := unpackNumber(s.inner[36:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellDataV1) InvitedDiscount() *Uint32 {
    start := unpackNumber(s.inner[36:])
    end := unpackNumber(s.inner[40:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellDataV1) CreatedAt() *Uint64 {
    var ret *Uint64
    start := unpackNumber(s.inner[40:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[44:])
        ret = Uint64FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint64FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *PreAccountCellDataV1) AsBuilder() PreAccountCellDataV1Builder {
    ret := NewPreAccountCellDataV1Builder().Account(*s.Account()).RefundLock(*s.RefundLock()).OwnerLockArgs(*s.OwnerLockArgs()).InviterId(*s.InviterId()).InviterLock(*s.InviterLock()).ChannelLock(*s.ChannelLock()).Price(*s.Price()).Quote(*s.Quote()).InvitedDiscount(*s.InvitedDiscount()).CreatedAt(*s.CreatedAt())
    return *ret
}
        

type PreAccountCellDataV2Builder struct {
    account AccountChars
refund_lock Script
owner_lock_args Bytes
inviter_id Bytes
inviter_lock ScriptOpt
channel_lock ScriptOpt
price PriceConfig
quote Uint64
invited_discount Uint32
created_at Uint64
initial_records Records
}
        

func (s *PreAccountCellDataV2Builder) Build() PreAccountCellDataV2 {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (11 + 1)
    offsets := make([]uint32, 0, 11)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.refund_lock.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.owner_lock_args.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.inviter_id.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.inviter_lock.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.channel_lock.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.price.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.quote.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.invited_discount.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.created_at.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.initial_records.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.account.AsSlice())
b.Write(s.refund_lock.AsSlice())
b.Write(s.owner_lock_args.AsSlice())
b.Write(s.inviter_id.AsSlice())
b.Write(s.inviter_lock.AsSlice())
b.Write(s.channel_lock.AsSlice())
b.Write(s.price.AsSlice())
b.Write(s.quote.AsSlice())
b.Write(s.invited_discount.AsSlice())
b.Write(s.created_at.AsSlice())
b.Write(s.initial_records.AsSlice())
    return PreAccountCellDataV2{inner: b.Bytes()}
}
                

func (s *PreAccountCellDataV2Builder) Account(v AccountChars) *PreAccountCellDataV2Builder {
    s.account = v
    return s
}
            

func (s *PreAccountCellDataV2Builder) RefundLock(v Script) *PreAccountCellDataV2Builder {
    s.refund_lock = v
    return s
}
            

func (s *PreAccountCellDataV2Builder) OwnerLockArgs(v Bytes) *PreAccountCellDataV2Builder {
    s.owner_lock_args = v
    return s
}
            

func (s *PreAccountCellDataV2Builder) InviterId(v Bytes) *PreAccountCellDataV2Builder {
    s.inviter_id = v
    return s
}
            

func (s *PreAccountCellDataV2Builder) InviterLock(v ScriptOpt) *PreAccountCellDataV2Builder {
    s.inviter_lock = v
    return s
}
            

func (s *PreAccountCellDataV2Builder) ChannelLock(v ScriptOpt) *PreAccountCellDataV2Builder {
    s.channel_lock = v
    return s
}
            

func (s *PreAccountCellDataV2Builder) Price(v PriceConfig) *PreAccountCellDataV2Builder {
    s.price = v
    return s
}
            

func (s *PreAccountCellDataV2Builder) Quote(v Uint64) *PreAccountCellDataV2Builder {
    s.quote = v
    return s
}
            

func (s *PreAccountCellDataV2Builder) InvitedDiscount(v Uint32) *PreAccountCellDataV2Builder {
    s.invited_discount = v
    return s
}
            

func (s *PreAccountCellDataV2Builder) CreatedAt(v Uint64) *PreAccountCellDataV2Builder {
    s.created_at = v
    return s
}
            

func (s *PreAccountCellDataV2Builder) InitialRecords(v Records) *PreAccountCellDataV2Builder {
    s.initial_records = v
    return s
}
            

func NewPreAccountCellDataV2Builder() *PreAccountCellDataV2Builder {
	return &PreAccountCellDataV2Builder{ account: AccountCharsDefault(),refund_lock: ScriptDefault(),owner_lock_args: BytesDefault(),inviter_id: BytesDefault(),inviter_lock: ScriptOptDefault(),channel_lock: ScriptOptDefault(),price: PriceConfigDefault(),quote: Uint64Default(),invited_discount: Uint32Default(),created_at: Uint64Default(),initial_records: RecordsDefault() }
}
    

type PreAccountCellDataV2 struct {
    inner []byte
}
        

func PreAccountCellDataV2FromSliceUnchecked(slice []byte) *PreAccountCellDataV2 {
    return &PreAccountCellDataV2{inner: slice}
}
func (s *PreAccountCellDataV2) AsSlice() []byte {
    return s.inner
}
            

func PreAccountCellDataV2Default() PreAccountCellDataV2 {
    return *PreAccountCellDataV2FromSliceUnchecked([]byte{ 170,0,0,0,48,0,0,0,52,0,0,0,105,0,0,0,109,0,0,0,113,0,0,0,113,0,0,0,113,0,0,0,146,0,0,0,154,0,0,0,158,0,0,0,166,0,0,0,4,0,0,0,53,0,0,0,16,0,0,0,48,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,33,0,0,0,16,0,0,0,17,0,0,0,25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0 })
}
            

func PreAccountCellDataV2FromSlice(slice []byte, compatible bool) (*PreAccountCellDataV2, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "PreAccountCellDataV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "PreAccountCellDataV2", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "PreAccountCellDataV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "PreAccountCellDataV2", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "PreAccountCellDataV2", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 11 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 11 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = AccountCharsFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ScriptFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ScriptOptFromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ScriptOptFromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = PriceConfigFromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[8]:offsets[9]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[9]:offsets[10]], compatible)
if err != nil {
    return nil, err
}
                

_, err = RecordsFromSlice(slice[offsets[10]:offsets[11]], compatible)
if err != nil {
    return nil, err
}
                

    return &PreAccountCellDataV2{inner: slice}, nil
}
            

func (s *PreAccountCellDataV2) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *PreAccountCellDataV2) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *PreAccountCellDataV2) Len() uint {
    return s.FieldCount()
}
func (s *PreAccountCellDataV2) IsEmpty() bool {
    return s.Len() == 0
}
func (s *PreAccountCellDataV2) CountExtraFields() uint {
    return s.FieldCount() - 11
}

func (s *PreAccountCellDataV2) HasExtraFields() bool {
    return 11 != s.FieldCount()
}
            

func (s *PreAccountCellDataV2) Account() *AccountChars {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return AccountCharsFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellDataV2) RefundLock() *Script {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return ScriptFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellDataV2) OwnerLockArgs() *Bytes {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellDataV2) InviterId() *Bytes {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellDataV2) InviterLock() *ScriptOpt {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return ScriptOptFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellDataV2) ChannelLock() *ScriptOpt {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return ScriptOptFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellDataV2) Price() *PriceConfig {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return PriceConfigFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellDataV2) Quote() *Uint64 {
    start := unpackNumber(s.inner[32:])
    end := unpackNumber(s.inner[36:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellDataV2) InvitedDiscount() *Uint32 {
    start := unpackNumber(s.inner[36:])
    end := unpackNumber(s.inner[40:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellDataV2) CreatedAt() *Uint64 {
    start := unpackNumber(s.inner[40:])
    end := unpackNumber(s.inner[44:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellDataV2) InitialRecords() *Records {
    var ret *Records
    start := unpackNumber(s.inner[44:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[48:])
        ret = RecordsFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = RecordsFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *PreAccountCellDataV2) AsBuilder() PreAccountCellDataV2Builder {
    ret := NewPreAccountCellDataV2Builder().Account(*s.Account()).RefundLock(*s.RefundLock()).OwnerLockArgs(*s.OwnerLockArgs()).InviterId(*s.InviterId()).InviterLock(*s.InviterLock()).ChannelLock(*s.ChannelLock()).Price(*s.Price()).Quote(*s.Quote()).InvitedDiscount(*s.InvitedDiscount()).CreatedAt(*s.CreatedAt()).InitialRecords(*s.InitialRecords())
    return *ret
}
        

type PreAccountCellDataBuilder struct {
    account AccountChars
refund_lock Script
owner_lock_args Bytes
inviter_id Bytes
inviter_lock ScriptOpt
channel_lock ScriptOpt
price PriceConfig
quote Uint64
invited_discount Uint32
created_at Uint64
initial_records Records
initial_cross_chain ChainId
}
        

func (s *PreAccountCellDataBuilder) Build() PreAccountCellData {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (12 + 1)
    offsets := make([]uint32, 0, 12)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.refund_lock.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.owner_lock_args.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.inviter_id.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.inviter_lock.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.channel_lock.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.price.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.quote.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.invited_discount.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.created_at.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.initial_records.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.initial_cross_chain.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.account.AsSlice())
b.Write(s.refund_lock.AsSlice())
b.Write(s.owner_lock_args.AsSlice())
b.Write(s.inviter_id.AsSlice())
b.Write(s.inviter_lock.AsSlice())
b.Write(s.channel_lock.AsSlice())
b.Write(s.price.AsSlice())
b.Write(s.quote.AsSlice())
b.Write(s.invited_discount.AsSlice())
b.Write(s.created_at.AsSlice())
b.Write(s.initial_records.AsSlice())
b.Write(s.initial_cross_chain.AsSlice())
    return PreAccountCellData{inner: b.Bytes()}
}
                

func (s *PreAccountCellDataBuilder) Account(v AccountChars) *PreAccountCellDataBuilder {
    s.account = v
    return s
}
            

func (s *PreAccountCellDataBuilder) RefundLock(v Script) *PreAccountCellDataBuilder {
    s.refund_lock = v
    return s
}
            

func (s *PreAccountCellDataBuilder) OwnerLockArgs(v Bytes) *PreAccountCellDataBuilder {
    s.owner_lock_args = v
    return s
}
            

func (s *PreAccountCellDataBuilder) InviterId(v Bytes) *PreAccountCellDataBuilder {
    s.inviter_id = v
    return s
}
            

func (s *PreAccountCellDataBuilder) InviterLock(v ScriptOpt) *PreAccountCellDataBuilder {
    s.inviter_lock = v
    return s
}
            

func (s *PreAccountCellDataBuilder) ChannelLock(v ScriptOpt) *PreAccountCellDataBuilder {
    s.channel_lock = v
    return s
}
            

func (s *PreAccountCellDataBuilder) Price(v PriceConfig) *PreAccountCellDataBuilder {
    s.price = v
    return s
}
            

func (s *PreAccountCellDataBuilder) Quote(v Uint64) *PreAccountCellDataBuilder {
    s.quote = v
    return s
}
            

func (s *PreAccountCellDataBuilder) InvitedDiscount(v Uint32) *PreAccountCellDataBuilder {
    s.invited_discount = v
    return s
}
            

func (s *PreAccountCellDataBuilder) CreatedAt(v Uint64) *PreAccountCellDataBuilder {
    s.created_at = v
    return s
}
            

func (s *PreAccountCellDataBuilder) InitialRecords(v Records) *PreAccountCellDataBuilder {
    s.initial_records = v
    return s
}
            

func (s *PreAccountCellDataBuilder) InitialCrossChain(v ChainId) *PreAccountCellDataBuilder {
    s.initial_cross_chain = v
    return s
}
            

func NewPreAccountCellDataBuilder() *PreAccountCellDataBuilder {
	return &PreAccountCellDataBuilder{ account: AccountCharsDefault(),refund_lock: ScriptDefault(),owner_lock_args: BytesDefault(),inviter_id: BytesDefault(),inviter_lock: ScriptOptDefault(),channel_lock: ScriptOptDefault(),price: PriceConfigDefault(),quote: Uint64Default(),invited_discount: Uint32Default(),created_at: Uint64Default(),initial_records: RecordsDefault(),initial_cross_chain: ChainIdDefault() }
}
    

type PreAccountCellData struct {
    inner []byte
}
        

func PreAccountCellDataFromSliceUnchecked(slice []byte) *PreAccountCellData {
    return &PreAccountCellData{inner: slice}
}
func (s *PreAccountCellData) AsSlice() []byte {
    return s.inner
}
            

func PreAccountCellDataDefault() PreAccountCellData {
    return *PreAccountCellDataFromSliceUnchecked([]byte{ 207,0,0,0,52,0,0,0,56,0,0,0,109,0,0,0,113,0,0,0,117,0,0,0,117,0,0,0,117,0,0,0,150,0,0,0,158,0,0,0,162,0,0,0,170,0,0,0,174,0,0,0,4,0,0,0,53,0,0,0,16,0,0,0,48,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,33,0,0,0,16,0,0,0,17,0,0,0,25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,33,0,0,0,16,0,0,0,17,0,0,0,25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func PreAccountCellDataFromSlice(slice []byte, compatible bool) (*PreAccountCellData, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "PreAccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "PreAccountCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "PreAccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "PreAccountCellData", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "PreAccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 12 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 12 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = AccountCharsFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ScriptFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ScriptOptFromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ScriptOptFromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = PriceConfigFromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint32FromSlice(slice[offsets[8]:offsets[9]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[9]:offsets[10]], compatible)
if err != nil {
    return nil, err
}
                

_, err = RecordsFromSlice(slice[offsets[10]:offsets[11]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ChainIdFromSlice(slice[offsets[11]:offsets[12]], compatible)
if err != nil {
    return nil, err
}
                

    return &PreAccountCellData{inner: slice}, nil
}
            

func (s *PreAccountCellData) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *PreAccountCellData) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *PreAccountCellData) Len() uint {
    return s.FieldCount()
}
func (s *PreAccountCellData) IsEmpty() bool {
    return s.Len() == 0
}
func (s *PreAccountCellData) CountExtraFields() uint {
    return s.FieldCount() - 12
}

func (s *PreAccountCellData) HasExtraFields() bool {
    return 12 != s.FieldCount()
}
            

func (s *PreAccountCellData) Account() *AccountChars {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return AccountCharsFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellData) RefundLock() *Script {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return ScriptFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellData) OwnerLockArgs() *Bytes {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellData) InviterId() *Bytes {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellData) InviterLock() *ScriptOpt {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return ScriptOptFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellData) ChannelLock() *ScriptOpt {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return ScriptOptFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellData) Price() *PriceConfig {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return PriceConfigFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellData) Quote() *Uint64 {
    start := unpackNumber(s.inner[32:])
    end := unpackNumber(s.inner[36:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellData) InvitedDiscount() *Uint32 {
    start := unpackNumber(s.inner[36:])
    end := unpackNumber(s.inner[40:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellData) CreatedAt() *Uint64 {
    start := unpackNumber(s.inner[40:])
    end := unpackNumber(s.inner[44:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellData) InitialRecords() *Records {
    start := unpackNumber(s.inner[44:])
    end := unpackNumber(s.inner[48:])
    return RecordsFromSliceUnchecked(s.inner[start:end])
}
               

func (s *PreAccountCellData) InitialCrossChain() *ChainId {
    var ret *ChainId
    start := unpackNumber(s.inner[48:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[52:])
        ret = ChainIdFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = ChainIdFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *PreAccountCellData) AsBuilder() PreAccountCellDataBuilder {
    ret := NewPreAccountCellDataBuilder().Account(*s.Account()).RefundLock(*s.RefundLock()).OwnerLockArgs(*s.OwnerLockArgs()).InviterId(*s.InviterId()).InviterLock(*s.InviterLock()).ChannelLock(*s.ChannelLock()).Price(*s.Price()).Quote(*s.Quote()).InvitedDiscount(*s.InvitedDiscount()).CreatedAt(*s.CreatedAt()).InitialRecords(*s.InitialRecords()).InitialCrossChain(*s.InitialCrossChain())
    return *ret
}
        

type ChainIdBuilder struct {
    checked Uint8
coin_type Uint64
chain_id Uint64
}
        

func (s *ChainIdBuilder) Build() ChainId {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (3 + 1)
    offsets := make([]uint32, 0, 3)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.checked.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.coin_type.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.chain_id.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.checked.AsSlice())
b.Write(s.coin_type.AsSlice())
b.Write(s.chain_id.AsSlice())
    return ChainId{inner: b.Bytes()}
}
                

func (s *ChainIdBuilder) Checked(v Uint8) *ChainIdBuilder {
    s.checked = v
    return s
}
            

func (s *ChainIdBuilder) CoinType(v Uint64) *ChainIdBuilder {
    s.coin_type = v
    return s
}
            

func (s *ChainIdBuilder) ChainId(v Uint64) *ChainIdBuilder {
    s.chain_id = v
    return s
}
            

func NewChainIdBuilder() *ChainIdBuilder {
	return &ChainIdBuilder{ checked: Uint8Default(),coin_type: Uint64Default(),chain_id: Uint64Default() }
}
    

type ChainId struct {
    inner []byte
}
        

func ChainIdFromSliceUnchecked(slice []byte) *ChainId {
    return &ChainId{inner: slice}
}
func (s *ChainId) AsSlice() []byte {
    return s.inner
}
            

func ChainIdDefault() ChainId {
    return *ChainIdFromSliceUnchecked([]byte{ 33,0,0,0,16,0,0,0,17,0,0,0,25,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func ChainIdFromSlice(slice []byte, compatible bool) (*ChainId, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ChainId", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ChainId", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ChainId", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ChainId", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ChainId", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 3 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 3 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

    return &ChainId{inner: slice}, nil
}
            

func (s *ChainId) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ChainId) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ChainId) Len() uint {
    return s.FieldCount()
}
func (s *ChainId) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ChainId) CountExtraFields() uint {
    return s.FieldCount() - 3
}

func (s *ChainId) HasExtraFields() bool {
    return 3 != s.FieldCount()
}
            

func (s *ChainId) Checked() *Uint8 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ChainId) CoinType() *Uint64 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *ChainId) ChainId() *Uint64 {
    var ret *Uint64
    start := unpackNumber(s.inner[12:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[16:])
        ret = Uint64FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint64FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ChainId) AsBuilder() ChainIdBuilder {
    ret := NewChainIdBuilder().Checked(*s.Checked()).CoinType(*s.CoinType()).ChainId(*s.ChainId())
    return *ret
}
        

type AccountCharsBuilder struct {
    inner []AccountChar
}
    

func (s *AccountCharsBuilder) Build() AccountChars {
    itemCount := len(s.inner)

    b := new(bytes.Buffer)

    // Empty dyn vector, just return size's bytes
    if itemCount == 0 {
        b.Write(packNumber(Number(HeaderSizeUint)))
        return AccountChars{inner: b.Bytes()}
    }

    // Calculate first offset then loop for rest items offsets
    totalSize := HeaderSizeUint * uint32(itemCount+1)
    offsets := make([]uint32, 0, itemCount)
    offsets = append(offsets, totalSize)
    for i := 1; i < itemCount; i++ {
        totalSize += uint32(len(s.inner[i-1].AsSlice()))
        offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
    }
    totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < itemCount; i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    for i := 0; i < itemCount; i++ {
        b.Write(s.inner[i].AsSlice())
    }

    return AccountChars{inner: b.Bytes()}
}
          

func (s *AccountCharsBuilder) Set(v []AccountChar) *AccountCharsBuilder {
    s.inner = v
    return s
}
func (s *AccountCharsBuilder) Push(v AccountChar) *AccountCharsBuilder {
    s.inner = append(s.inner, v)
    return s
}
func (s *AccountCharsBuilder) Extend(iter []AccountChar) *AccountCharsBuilder {
    for i:=0; i < len(iter); i++ {
        s.inner = append(s.inner, iter[i])
    }
    return s
}
func (s *AccountCharsBuilder) Replace(index uint, v AccountChar) *AccountChar {
    if uint(len(s.inner)) > index {
        a := s.inner[index]
        s.inner[index] = v
        return &a
    }
    return nil
}
    

func NewAccountCharsBuilder() *AccountCharsBuilder {
	return &AccountCharsBuilder{ []AccountChar{} }
}
        

type AccountChars struct {
    inner []byte
}
        

func AccountCharsFromSliceUnchecked(slice []byte) *AccountChars {
    return &AccountChars{inner: slice}
}
func (s *AccountChars) AsSlice() []byte {
    return s.inner
}
            

func AccountCharsDefault() AccountChars {
    return *AccountCharsFromSliceUnchecked([]byte{ 4,0,0,0 })
}
            

func AccountCharsFromSlice(slice []byte, compatible bool) (*AccountChars, error) {
    sliceLen := len(slice)

    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "AccountChars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountChars", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint {
        return &AccountChars{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountChars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountChars", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "AccountChars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }
    itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

    offsets := make([]uint32, itemCount)

    for i := 0; i < int(itemCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }

    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountChars"}, " ")
            return nil, errors.New(errMsg)
        }
    }

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 {
            start := offsets[i-1]
            end := offsets[i]
            _, err := AccountCharFromSlice(slice[start:end], compatible)

            if err != nil {
                return nil, err
            }
        }
    }

    return &AccountChars{inner: slice}, nil
}
            

func (s *AccountChars) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *AccountChars) ItemCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *AccountChars) Len() uint {
    return s.ItemCount()
}
func (s *AccountChars) IsEmpty() bool {
    return s.Len() == 0
}
// if *AccountChar is nil, index is out of bounds
func (s *AccountChars) Get(index uint) *AccountChar {
    var b *AccountChar
    if index < s.Len() {
        start_index := uint(HeaderSizeUint) * (1 + index)
        start := unpackNumber(s.inner[start_index:])

        if index == s.Len()-1 {
            b = AccountCharFromSliceUnchecked(s.inner[start:])
        } else {
            end_index := start_index + uint(HeaderSizeUint)
            end := unpackNumber(s.inner[end_index:])
            b = AccountCharFromSliceUnchecked(s.inner[start:end])
        }
    }
    return b
}
            

func (s *AccountChars) AsBuilder() AccountCharsBuilder {
    size := s.ItemCount()
    t := NewAccountCharsBuilder()
    for i:=uint(0); i < size; i++ {
        t.Push(*s.Get(i))
    }
    return *t
}
        

type AccountCharBuilder struct {
    char_set_name Uint32
bytes Bytes
}
        

func (s *AccountCharBuilder) Build() AccountChar {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (2 + 1)
    offsets := make([]uint32, 0, 2)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.char_set_name.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.bytes.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.char_set_name.AsSlice())
b.Write(s.bytes.AsSlice())
    return AccountChar{inner: b.Bytes()}
}
                

func (s *AccountCharBuilder) CharSetName(v Uint32) *AccountCharBuilder {
    s.char_set_name = v
    return s
}
            

func (s *AccountCharBuilder) Bytes(v Bytes) *AccountCharBuilder {
    s.bytes = v
    return s
}
            

func NewAccountCharBuilder() *AccountCharBuilder {
	return &AccountCharBuilder{ char_set_name: Uint32Default(),bytes: BytesDefault() }
}
    

type AccountChar struct {
    inner []byte
}
        

func AccountCharFromSliceUnchecked(slice []byte) *AccountChar {
    return &AccountChar{inner: slice}
}
func (s *AccountChar) AsSlice() []byte {
    return s.inner
}
            

func AccountCharDefault() AccountChar {
    return *AccountCharFromSliceUnchecked([]byte{ 20,0,0,0,12,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func AccountCharFromSlice(slice []byte, compatible bool) (*AccountChar, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "AccountChar", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountChar", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountChar", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountChar", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "AccountChar", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 2 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 2 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

    return &AccountChar{inner: slice}, nil
}
            

func (s *AccountChar) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *AccountChar) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *AccountChar) Len() uint {
    return s.FieldCount()
}
func (s *AccountChar) IsEmpty() bool {
    return s.Len() == 0
}
func (s *AccountChar) CountExtraFields() uint {
    return s.FieldCount() - 2
}

func (s *AccountChar) HasExtraFields() bool {
    return 2 != s.FieldCount()
}
            

func (s *AccountChar) CharSetName() *Uint32 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *AccountChar) Bytes() *Bytes {
    var ret *Bytes
    start := unpackNumber(s.inner[8:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[12:])
        ret = BytesFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = BytesFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *AccountChar) AsBuilder() AccountCharBuilder {
    ret := NewAccountCharBuilder().CharSetName(*s.CharSetName()).Bytes(*s.Bytes())
    return *ret
}
        

type OfferCellDataBuilder struct {
    account Bytes
price Uint64
message Bytes
inviter_lock Script
channel_lock Script
}
        

func (s *OfferCellDataBuilder) Build() OfferCellData {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (5 + 1)
    offsets := make([]uint32, 0, 5)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.price.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.message.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.inviter_lock.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.channel_lock.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.account.AsSlice())
b.Write(s.price.AsSlice())
b.Write(s.message.AsSlice())
b.Write(s.inviter_lock.AsSlice())
b.Write(s.channel_lock.AsSlice())
    return OfferCellData{inner: b.Bytes()}
}
                

func (s *OfferCellDataBuilder) Account(v Bytes) *OfferCellDataBuilder {
    s.account = v
    return s
}
            

func (s *OfferCellDataBuilder) Price(v Uint64) *OfferCellDataBuilder {
    s.price = v
    return s
}
            

func (s *OfferCellDataBuilder) Message(v Bytes) *OfferCellDataBuilder {
    s.message = v
    return s
}
            

func (s *OfferCellDataBuilder) InviterLock(v Script) *OfferCellDataBuilder {
    s.inviter_lock = v
    return s
}
            

func (s *OfferCellDataBuilder) ChannelLock(v Script) *OfferCellDataBuilder {
    s.channel_lock = v
    return s
}
            

func NewOfferCellDataBuilder() *OfferCellDataBuilder {
	return &OfferCellDataBuilder{ account: BytesDefault(),price: Uint64Default(),message: BytesDefault(),inviter_lock: ScriptDefault(),channel_lock: ScriptDefault() }
}
    

type OfferCellData struct {
    inner []byte
}
        

func OfferCellDataFromSliceUnchecked(slice []byte) *OfferCellData {
    return &OfferCellData{inner: slice}
}
func (s *OfferCellData) AsSlice() []byte {
    return s.inner
}
            

func OfferCellDataDefault() OfferCellData {
    return *OfferCellDataFromSliceUnchecked([]byte{ 146,0,0,0,24,0,0,0,28,0,0,0,36,0,0,0,40,0,0,0,93,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,53,0,0,0,16,0,0,0,48,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,53,0,0,0,16,0,0,0,48,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func OfferCellDataFromSlice(slice []byte, compatible bool) (*OfferCellData, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "OfferCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "OfferCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "OfferCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "OfferCellData", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "OfferCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 5 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 5 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = BytesFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ScriptFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ScriptFromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

    return &OfferCellData{inner: slice}, nil
}
            

func (s *OfferCellData) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *OfferCellData) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *OfferCellData) Len() uint {
    return s.FieldCount()
}
func (s *OfferCellData) IsEmpty() bool {
    return s.Len() == 0
}
func (s *OfferCellData) CountExtraFields() uint {
    return s.FieldCount() - 5
}

func (s *OfferCellData) HasExtraFields() bool {
    return 5 != s.FieldCount()
}
            

func (s *OfferCellData) Account() *Bytes {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *OfferCellData) Price() *Uint64 {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *OfferCellData) Message() *Bytes {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *OfferCellData) InviterLock() *Script {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return ScriptFromSliceUnchecked(s.inner[start:end])
}
               

func (s *OfferCellData) ChannelLock() *Script {
    var ret *Script
    start := unpackNumber(s.inner[20:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[24:])
        ret = ScriptFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = ScriptFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *OfferCellData) AsBuilder() OfferCellDataBuilder {
    ret := NewOfferCellDataBuilder().Account(*s.Account()).Price(*s.Price()).Message(*s.Message()).InviterLock(*s.InviterLock()).ChannelLock(*s.ChannelLock())
    return *ret
}
        

type SubAccountBuilder struct {
    lock Script
id AccountId
account AccountChars
suffix Bytes
registered_at Uint64
expired_at Uint64
status Uint8
records Records
nonce Uint64
enable_sub_account Uint8
renew_sub_account_price Uint64
}
        

func (s *SubAccountBuilder) Build() SubAccount {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (11 + 1)
    offsets := make([]uint32, 0, 11)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.lock.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.id.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.account.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.suffix.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.registered_at.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.expired_at.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.status.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.records.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.nonce.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.enable_sub_account.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.renew_sub_account_price.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.lock.AsSlice())
b.Write(s.id.AsSlice())
b.Write(s.account.AsSlice())
b.Write(s.suffix.AsSlice())
b.Write(s.registered_at.AsSlice())
b.Write(s.expired_at.AsSlice())
b.Write(s.status.AsSlice())
b.Write(s.records.AsSlice())
b.Write(s.nonce.AsSlice())
b.Write(s.enable_sub_account.AsSlice())
b.Write(s.renew_sub_account_price.AsSlice())
    return SubAccount{inner: b.Bytes()}
}
                

func (s *SubAccountBuilder) Lock(v Script) *SubAccountBuilder {
    s.lock = v
    return s
}
            

func (s *SubAccountBuilder) Id(v AccountId) *SubAccountBuilder {
    s.id = v
    return s
}
            

func (s *SubAccountBuilder) Account(v AccountChars) *SubAccountBuilder {
    s.account = v
    return s
}
            

func (s *SubAccountBuilder) Suffix(v Bytes) *SubAccountBuilder {
    s.suffix = v
    return s
}
            

func (s *SubAccountBuilder) RegisteredAt(v Uint64) *SubAccountBuilder {
    s.registered_at = v
    return s
}
            

func (s *SubAccountBuilder) ExpiredAt(v Uint64) *SubAccountBuilder {
    s.expired_at = v
    return s
}
            

func (s *SubAccountBuilder) Status(v Uint8) *SubAccountBuilder {
    s.status = v
    return s
}
            

func (s *SubAccountBuilder) Records(v Records) *SubAccountBuilder {
    s.records = v
    return s
}
            

func (s *SubAccountBuilder) Nonce(v Uint64) *SubAccountBuilder {
    s.nonce = v
    return s
}
            

func (s *SubAccountBuilder) EnableSubAccount(v Uint8) *SubAccountBuilder {
    s.enable_sub_account = v
    return s
}
            

func (s *SubAccountBuilder) RenewSubAccountPrice(v Uint64) *SubAccountBuilder {
    s.renew_sub_account_price = v
    return s
}
            

func NewSubAccountBuilder() *SubAccountBuilder {
	return &SubAccountBuilder{ lock: ScriptDefault(),id: AccountIdDefault(),account: AccountCharsDefault(),suffix: BytesDefault(),registered_at: Uint64Default(),expired_at: Uint64Default(),status: Uint8Default(),records: RecordsDefault(),nonce: Uint64Default(),enable_sub_account: Uint8Default(),renew_sub_account_price: Uint64Default() }
}
    

type SubAccount struct {
    inner []byte
}
        

func SubAccountFromSliceUnchecked(slice []byte) *SubAccount {
    return &SubAccount{inner: slice}
}
func (s *SubAccount) AsSlice() []byte {
    return s.inner
}
            

func SubAccountDefault() SubAccount {
    return *SubAccountFromSliceUnchecked([]byte{ 167,0,0,0,48,0,0,0,101,0,0,0,121,0,0,0,125,0,0,0,129,0,0,0,137,0,0,0,145,0,0,0,146,0,0,0,150,0,0,0,158,0,0,0,159,0,0,0,53,0,0,0,16,0,0,0,48,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func SubAccountFromSlice(slice []byte, compatible bool) (*SubAccount, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "SubAccount", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "SubAccount", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "SubAccount", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "SubAccount", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "SubAccount", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 11 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 11 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = ScriptFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = AccountIdFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = AccountCharsFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint8FromSlice(slice[offsets[6]:offsets[7]], compatible)
if err != nil {
    return nil, err
}
                

_, err = RecordsFromSlice(slice[offsets[7]:offsets[8]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[8]:offsets[9]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint8FromSlice(slice[offsets[9]:offsets[10]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[10]:offsets[11]], compatible)
if err != nil {
    return nil, err
}
                

    return &SubAccount{inner: slice}, nil
}
            

func (s *SubAccount) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *SubAccount) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *SubAccount) Len() uint {
    return s.FieldCount()
}
func (s *SubAccount) IsEmpty() bool {
    return s.Len() == 0
}
func (s *SubAccount) CountExtraFields() uint {
    return s.FieldCount() - 11
}

func (s *SubAccount) HasExtraFields() bool {
    return 11 != s.FieldCount()
}
            

func (s *SubAccount) Lock() *Script {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return ScriptFromSliceUnchecked(s.inner[start:end])
}
               

func (s *SubAccount) Id() *AccountId {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return AccountIdFromSliceUnchecked(s.inner[start:end])
}
               

func (s *SubAccount) Account() *AccountChars {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return AccountCharsFromSliceUnchecked(s.inner[start:end])
}
               

func (s *SubAccount) Suffix() *Bytes {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *SubAccount) RegisteredAt() *Uint64 {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *SubAccount) ExpiredAt() *Uint64 {
    start := unpackNumber(s.inner[24:])
    end := unpackNumber(s.inner[28:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *SubAccount) Status() *Uint8 {
    start := unpackNumber(s.inner[28:])
    end := unpackNumber(s.inner[32:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *SubAccount) Records() *Records {
    start := unpackNumber(s.inner[32:])
    end := unpackNumber(s.inner[36:])
    return RecordsFromSliceUnchecked(s.inner[start:end])
}
               

func (s *SubAccount) Nonce() *Uint64 {
    start := unpackNumber(s.inner[36:])
    end := unpackNumber(s.inner[40:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *SubAccount) EnableSubAccount() *Uint8 {
    start := unpackNumber(s.inner[40:])
    end := unpackNumber(s.inner[44:])
    return Uint8FromSliceUnchecked(s.inner[start:end])
}
               

func (s *SubAccount) RenewSubAccountPrice() *Uint64 {
    var ret *Uint64
    start := unpackNumber(s.inner[44:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[48:])
        ret = Uint64FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint64FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *SubAccount) AsBuilder() SubAccountBuilder {
    ret := NewSubAccountBuilder().Lock(*s.Lock()).Id(*s.Id()).Account(*s.Account()).Suffix(*s.Suffix()).RegisteredAt(*s.RegisteredAt()).ExpiredAt(*s.ExpiredAt()).Status(*s.Status()).Records(*s.Records()).Nonce(*s.Nonce()).EnableSubAccount(*s.EnableSubAccount()).RenewSubAccountPrice(*s.RenewSubAccountPrice())
    return *ret
}
        

type SubAccountRuleBuilder struct {
    index Uint32
name Bytes
note Bytes
price Uint64
ast ASTExpression
status Uint8
}
        

func (s *SubAccountRuleBuilder) Build() SubAccountRule {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (6 + 1)
    offsets := make([]uint32, 0, 6)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.index.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.name.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.note.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.price.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.ast.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.status.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.index.AsSlice())
b.Write(s.name.AsSlice())
b.Write(s.note.AsSlice())
b.Write(s.price.AsSlice())
b.Write(s.ast.AsSlice())
b.Write(s.status.AsSlice())
    return SubAccountRule{inner: b.Bytes()}
}
                

func (s *SubAccountRuleBuilder) Index(v Uint32) *SubAccountRuleBuilder {
    s.index = v
    return s
}
            

func (s *SubAccountRuleBuilder) Name(v Bytes) *SubAccountRuleBuilder {
    s.name = v
    return s
}
            

func (s *SubAccountRuleBuilder) Note(v Bytes) *SubAccountRuleBuilder {
    s.note = v
    return s
}
            

func (s *SubAccountRuleBuilder) Price(v Uint64) *SubAccountRuleBuilder {
    s.price = v
    return s
}
            

func (s *SubAccountRuleBuilder) Ast(v ASTExpression) *SubAccountRuleBuilder {
    s.ast = v
    return s
}
            

func (s *SubAccountRuleBuilder) Status(v Uint8) *SubAccountRuleBuilder {
    s.status = v
    return s
}
            

func NewSubAccountRuleBuilder() *SubAccountRuleBuilder {
	return &SubAccountRuleBuilder{ index: Uint32Default(),name: BytesDefault(),note: BytesDefault(),price: Uint64Default(),ast: ASTExpressionDefault(),status: Uint8Default() }
}
    

type SubAccountRule struct {
    inner []byte
}
        

func SubAccountRuleFromSliceUnchecked(slice []byte) *SubAccountRule {
    return &SubAccountRule{inner: slice}
}
func (s *SubAccountRule) AsSlice() []byte {
    return s.inner
}
            

func SubAccountRuleDefault() SubAccountRule {
    return *SubAccountRuleFromSliceUnchecked([]byte{ 66,0,0,0,28,0,0,0,32,0,0,0,36,0,0,0,40,0,0,0,48,0,0,0,65,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17,0,0,0,12,0,0,0,13,0,0,0,0,0,0,0,0,0 })
}
            

func SubAccountRuleFromSlice(slice []byte, compatible bool) (*SubAccountRule, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "SubAccountRule", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "SubAccountRule", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "SubAccountRule", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "SubAccountRule", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "SubAccountRule", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 6 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 6 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[2]:offsets[3]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint64FromSlice(slice[offsets[3]:offsets[4]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ASTExpressionFromSlice(slice[offsets[4]:offsets[5]], compatible)
if err != nil {
    return nil, err
}
                

_, err = Uint8FromSlice(slice[offsets[5]:offsets[6]], compatible)
if err != nil {
    return nil, err
}
                

    return &SubAccountRule{inner: slice}, nil
}
            

func (s *SubAccountRule) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *SubAccountRule) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *SubAccountRule) Len() uint {
    return s.FieldCount()
}
func (s *SubAccountRule) IsEmpty() bool {
    return s.Len() == 0
}
func (s *SubAccountRule) CountExtraFields() uint {
    return s.FieldCount() - 6
}

func (s *SubAccountRule) HasExtraFields() bool {
    return 6 != s.FieldCount()
}
            

func (s *SubAccountRule) Index() *Uint32 {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return Uint32FromSliceUnchecked(s.inner[start:end])
}
               

func (s *SubAccountRule) Name() *Bytes {
    start := unpackNumber(s.inner[8:])
    end := unpackNumber(s.inner[12:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *SubAccountRule) Note() *Bytes {
    start := unpackNumber(s.inner[12:])
    end := unpackNumber(s.inner[16:])
    return BytesFromSliceUnchecked(s.inner[start:end])
}
               

func (s *SubAccountRule) Price() *Uint64 {
    start := unpackNumber(s.inner[16:])
    end := unpackNumber(s.inner[20:])
    return Uint64FromSliceUnchecked(s.inner[start:end])
}
               

func (s *SubAccountRule) Ast() *ASTExpression {
    start := unpackNumber(s.inner[20:])
    end := unpackNumber(s.inner[24:])
    return ASTExpressionFromSliceUnchecked(s.inner[start:end])
}
               

func (s *SubAccountRule) Status() *Uint8 {
    var ret *Uint8
    start := unpackNumber(s.inner[24:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[28:])
        ret = Uint8FromSliceUnchecked(s.inner[start:end])
    } else {
        ret = Uint8FromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *SubAccountRule) AsBuilder() SubAccountRuleBuilder {
    ret := NewSubAccountRuleBuilder().Index(*s.Index()).Name(*s.Name()).Note(*s.Note()).Price(*s.Price()).Ast(*s.Ast()).Status(*s.Status())
    return *ret
}
        

type SubAccountRulesBuilder struct {
    inner []SubAccountRule
}
    

func (s *SubAccountRulesBuilder) Build() SubAccountRules {
    itemCount := len(s.inner)

    b := new(bytes.Buffer)

    // Empty dyn vector, just return size's bytes
    if itemCount == 0 {
        b.Write(packNumber(Number(HeaderSizeUint)))
        return SubAccountRules{inner: b.Bytes()}
    }

    // Calculate first offset then loop for rest items offsets
    totalSize := HeaderSizeUint * uint32(itemCount+1)
    offsets := make([]uint32, 0, itemCount)
    offsets = append(offsets, totalSize)
    for i := 1; i < itemCount; i++ {
        totalSize += uint32(len(s.inner[i-1].AsSlice()))
        offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
    }
    totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < itemCount; i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    for i := 0; i < itemCount; i++ {
        b.Write(s.inner[i].AsSlice())
    }

    return SubAccountRules{inner: b.Bytes()}
}
          

func (s *SubAccountRulesBuilder) Set(v []SubAccountRule) *SubAccountRulesBuilder {
    s.inner = v
    return s
}
func (s *SubAccountRulesBuilder) Push(v SubAccountRule) *SubAccountRulesBuilder {
    s.inner = append(s.inner, v)
    return s
}
func (s *SubAccountRulesBuilder) Extend(iter []SubAccountRule) *SubAccountRulesBuilder {
    for i:=0; i < len(iter); i++ {
        s.inner = append(s.inner, iter[i])
    }
    return s
}
func (s *SubAccountRulesBuilder) Replace(index uint, v SubAccountRule) *SubAccountRule {
    if uint(len(s.inner)) > index {
        a := s.inner[index]
        s.inner[index] = v
        return &a
    }
    return nil
}
    

func NewSubAccountRulesBuilder() *SubAccountRulesBuilder {
	return &SubAccountRulesBuilder{ []SubAccountRule{} }
}
        

type SubAccountRules struct {
    inner []byte
}
        

func SubAccountRulesFromSliceUnchecked(slice []byte) *SubAccountRules {
    return &SubAccountRules{inner: slice}
}
func (s *SubAccountRules) AsSlice() []byte {
    return s.inner
}
            

func SubAccountRulesDefault() SubAccountRules {
    return *SubAccountRulesFromSliceUnchecked([]byte{ 4,0,0,0 })
}
            

func SubAccountRulesFromSlice(slice []byte, compatible bool) (*SubAccountRules, error) {
    sliceLen := len(slice)

    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "SubAccountRules", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "SubAccountRules", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint {
        return &SubAccountRules{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "SubAccountRules", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "SubAccountRules", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "SubAccountRules", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }
    itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

    offsets := make([]uint32, itemCount)

    for i := 0; i < int(itemCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }

    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            errMsg := strings.Join([]string{"OffsetsNotMatch", "SubAccountRules"}, " ")
            return nil, errors.New(errMsg)
        }
    }

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 {
            start := offsets[i-1]
            end := offsets[i]
            _, err := SubAccountRuleFromSlice(slice[start:end], compatible)

            if err != nil {
                return nil, err
            }
        }
    }

    return &SubAccountRules{inner: slice}, nil
}
            

func (s *SubAccountRules) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *SubAccountRules) ItemCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *SubAccountRules) Len() uint {
    return s.ItemCount()
}
func (s *SubAccountRules) IsEmpty() bool {
    return s.Len() == 0
}
// if *SubAccountRule is nil, index is out of bounds
func (s *SubAccountRules) Get(index uint) *SubAccountRule {
    var b *SubAccountRule
    if index < s.Len() {
        start_index := uint(HeaderSizeUint) * (1 + index)
        start := unpackNumber(s.inner[start_index:])

        if index == s.Len()-1 {
            b = SubAccountRuleFromSliceUnchecked(s.inner[start:])
        } else {
            end_index := start_index + uint(HeaderSizeUint)
            end := unpackNumber(s.inner[end_index:])
            b = SubAccountRuleFromSliceUnchecked(s.inner[start:end])
        }
    }
    return b
}
            

func (s *SubAccountRules) AsBuilder() SubAccountRulesBuilder {
    size := s.ItemCount()
    t := NewSubAccountRulesBuilder()
    for i:=uint(0); i < size; i++ {
        t.Push(*s.Get(i))
    }
    return *t
}
        

type ASTExpressionBuilder struct {
    expression_type Byte
expression Bytes
}
        

func (s *ASTExpressionBuilder) Build() ASTExpression {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (2 + 1)
    offsets := make([]uint32, 0, 2)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.expression_type.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.expression.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.expression_type.AsSlice())
b.Write(s.expression.AsSlice())
    return ASTExpression{inner: b.Bytes()}
}
                

func (s *ASTExpressionBuilder) ExpressionType(v Byte) *ASTExpressionBuilder {
    s.expression_type = v
    return s
}
            

func (s *ASTExpressionBuilder) Expression(v Bytes) *ASTExpressionBuilder {
    s.expression = v
    return s
}
            

func NewASTExpressionBuilder() *ASTExpressionBuilder {
	return &ASTExpressionBuilder{ expression_type: ByteDefault(),expression: BytesDefault() }
}
    

type ASTExpression struct {
    inner []byte
}
        

func ASTExpressionFromSliceUnchecked(slice []byte) *ASTExpression {
    return &ASTExpression{inner: slice}
}
func (s *ASTExpression) AsSlice() []byte {
    return s.inner
}
            

func ASTExpressionDefault() ASTExpression {
    return *ASTExpressionFromSliceUnchecked([]byte{ 17,0,0,0,12,0,0,0,13,0,0,0,0,0,0,0,0 })
}
            

func ASTExpressionFromSlice(slice []byte, compatible bool) (*ASTExpression, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ASTExpression", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ASTExpression", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ASTExpression", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ASTExpression", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ASTExpression", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 2 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 2 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = ByteFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

    return &ASTExpression{inner: slice}, nil
}
            

func (s *ASTExpression) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ASTExpression) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ASTExpression) Len() uint {
    return s.FieldCount()
}
func (s *ASTExpression) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ASTExpression) CountExtraFields() uint {
    return s.FieldCount() - 2
}

func (s *ASTExpression) HasExtraFields() bool {
    return 2 != s.FieldCount()
}
            

func (s *ASTExpression) ExpressionType() *Byte {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return ByteFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ASTExpression) Expression() *Bytes {
    var ret *Bytes
    start := unpackNumber(s.inner[8:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[12:])
        ret = BytesFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = BytesFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ASTExpression) AsBuilder() ASTExpressionBuilder {
    ret := NewASTExpressionBuilder().ExpressionType(*s.ExpressionType()).Expression(*s.Expression())
    return *ret
}
        

type ASTExpressionsBuilder struct {
    inner []ASTExpression
}
    

func (s *ASTExpressionsBuilder) Build() ASTExpressions {
    itemCount := len(s.inner)

    b := new(bytes.Buffer)

    // Empty dyn vector, just return size's bytes
    if itemCount == 0 {
        b.Write(packNumber(Number(HeaderSizeUint)))
        return ASTExpressions{inner: b.Bytes()}
    }

    // Calculate first offset then loop for rest items offsets
    totalSize := HeaderSizeUint * uint32(itemCount+1)
    offsets := make([]uint32, 0, itemCount)
    offsets = append(offsets, totalSize)
    for i := 1; i < itemCount; i++ {
        totalSize += uint32(len(s.inner[i-1].AsSlice()))
        offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
    }
    totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < itemCount; i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    for i := 0; i < itemCount; i++ {
        b.Write(s.inner[i].AsSlice())
    }

    return ASTExpressions{inner: b.Bytes()}
}
          

func (s *ASTExpressionsBuilder) Set(v []ASTExpression) *ASTExpressionsBuilder {
    s.inner = v
    return s
}
func (s *ASTExpressionsBuilder) Push(v ASTExpression) *ASTExpressionsBuilder {
    s.inner = append(s.inner, v)
    return s
}
func (s *ASTExpressionsBuilder) Extend(iter []ASTExpression) *ASTExpressionsBuilder {
    for i:=0; i < len(iter); i++ {
        s.inner = append(s.inner, iter[i])
    }
    return s
}
func (s *ASTExpressionsBuilder) Replace(index uint, v ASTExpression) *ASTExpression {
    if uint(len(s.inner)) > index {
        a := s.inner[index]
        s.inner[index] = v
        return &a
    }
    return nil
}
    

func NewASTExpressionsBuilder() *ASTExpressionsBuilder {
	return &ASTExpressionsBuilder{ []ASTExpression{} }
}
        

type ASTExpressions struct {
    inner []byte
}
        

func ASTExpressionsFromSliceUnchecked(slice []byte) *ASTExpressions {
    return &ASTExpressions{inner: slice}
}
func (s *ASTExpressions) AsSlice() []byte {
    return s.inner
}
            

func ASTExpressionsDefault() ASTExpressions {
    return *ASTExpressionsFromSliceUnchecked([]byte{ 4,0,0,0 })
}
            

func ASTExpressionsFromSlice(slice []byte, compatible bool) (*ASTExpressions, error) {
    sliceLen := len(slice)

    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ASTExpressions", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ASTExpressions", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) == HeaderSizeUint {
        return &ASTExpressions{inner: slice}, nil
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ASTExpressions", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ASTExpressions", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ASTExpressions", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }
    itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

    offsets := make([]uint32, itemCount)

    for i := 0; i < int(itemCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }

    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            errMsg := strings.Join([]string{"OffsetsNotMatch", "ASTExpressions"}, " ")
            return nil, errors.New(errMsg)
        }
    }

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 {
            start := offsets[i-1]
            end := offsets[i]
            _, err := ASTExpressionFromSlice(slice[start:end], compatible)

            if err != nil {
                return nil, err
            }
        }
    }

    return &ASTExpressions{inner: slice}, nil
}
            

func (s *ASTExpressions) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ASTExpressions) ItemCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ASTExpressions) Len() uint {
    return s.ItemCount()
}
func (s *ASTExpressions) IsEmpty() bool {
    return s.Len() == 0
}
// if *ASTExpression is nil, index is out of bounds
func (s *ASTExpressions) Get(index uint) *ASTExpression {
    var b *ASTExpression
    if index < s.Len() {
        start_index := uint(HeaderSizeUint) * (1 + index)
        start := unpackNumber(s.inner[start_index:])

        if index == s.Len()-1 {
            b = ASTExpressionFromSliceUnchecked(s.inner[start:])
        } else {
            end_index := start_index + uint(HeaderSizeUint)
            end := unpackNumber(s.inner[end_index:])
            b = ASTExpressionFromSliceUnchecked(s.inner[start:end])
        }
    }
    return b
}
            

func (s *ASTExpressions) AsBuilder() ASTExpressionsBuilder {
    size := s.ItemCount()
    t := NewASTExpressionsBuilder()
    for i:=uint(0); i < size; i++ {
        t.Push(*s.Get(i))
    }
    return *t
}
        

type ASTOperatorBuilder struct {
    symbol Byte
expressions ASTExpressions
}
        

func (s *ASTOperatorBuilder) Build() ASTOperator {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (2 + 1)
    offsets := make([]uint32, 0, 2)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.symbol.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.expressions.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.symbol.AsSlice())
b.Write(s.expressions.AsSlice())
    return ASTOperator{inner: b.Bytes()}
}
                

func (s *ASTOperatorBuilder) Symbol(v Byte) *ASTOperatorBuilder {
    s.symbol = v
    return s
}
            

func (s *ASTOperatorBuilder) Expressions(v ASTExpressions) *ASTOperatorBuilder {
    s.expressions = v
    return s
}
            

func NewASTOperatorBuilder() *ASTOperatorBuilder {
	return &ASTOperatorBuilder{ symbol: ByteDefault(),expressions: ASTExpressionsDefault() }
}
    

type ASTOperator struct {
    inner []byte
}
        

func ASTOperatorFromSliceUnchecked(slice []byte) *ASTOperator {
    return &ASTOperator{inner: slice}
}
func (s *ASTOperator) AsSlice() []byte {
    return s.inner
}
            

func ASTOperatorDefault() ASTOperator {
    return *ASTOperatorFromSliceUnchecked([]byte{ 17,0,0,0,12,0,0,0,13,0,0,0,0,4,0,0,0 })
}
            

func ASTOperatorFromSlice(slice []byte, compatible bool) (*ASTOperator, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ASTOperator", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ASTOperator", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ASTOperator", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ASTOperator", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ASTOperator", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 2 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 2 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = ByteFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ASTExpressionsFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

    return &ASTOperator{inner: slice}, nil
}
            

func (s *ASTOperator) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ASTOperator) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ASTOperator) Len() uint {
    return s.FieldCount()
}
func (s *ASTOperator) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ASTOperator) CountExtraFields() uint {
    return s.FieldCount() - 2
}

func (s *ASTOperator) HasExtraFields() bool {
    return 2 != s.FieldCount()
}
            

func (s *ASTOperator) Symbol() *Byte {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return ByteFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ASTOperator) Expressions() *ASTExpressions {
    var ret *ASTExpressions
    start := unpackNumber(s.inner[8:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[12:])
        ret = ASTExpressionsFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = ASTExpressionsFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ASTOperator) AsBuilder() ASTOperatorBuilder {
    ret := NewASTOperatorBuilder().Symbol(*s.Symbol()).Expressions(*s.Expressions())
    return *ret
}
        

type ASTFunctionBuilder struct {
    name Byte
arguments ASTExpressions
}
        

func (s *ASTFunctionBuilder) Build() ASTFunction {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (2 + 1)
    offsets := make([]uint32, 0, 2)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.name.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.arguments.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.name.AsSlice())
b.Write(s.arguments.AsSlice())
    return ASTFunction{inner: b.Bytes()}
}
                

func (s *ASTFunctionBuilder) Name(v Byte) *ASTFunctionBuilder {
    s.name = v
    return s
}
            

func (s *ASTFunctionBuilder) Arguments(v ASTExpressions) *ASTFunctionBuilder {
    s.arguments = v
    return s
}
            

func NewASTFunctionBuilder() *ASTFunctionBuilder {
	return &ASTFunctionBuilder{ name: ByteDefault(),arguments: ASTExpressionsDefault() }
}
    

type ASTFunction struct {
    inner []byte
}
        

func ASTFunctionFromSliceUnchecked(slice []byte) *ASTFunction {
    return &ASTFunction{inner: slice}
}
func (s *ASTFunction) AsSlice() []byte {
    return s.inner
}
            

func ASTFunctionDefault() ASTFunction {
    return *ASTFunctionFromSliceUnchecked([]byte{ 17,0,0,0,12,0,0,0,13,0,0,0,0,4,0,0,0 })
}
            

func ASTFunctionFromSlice(slice []byte, compatible bool) (*ASTFunction, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ASTFunction", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ASTFunction", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ASTFunction", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ASTFunction", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ASTFunction", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 2 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 2 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = ByteFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ASTExpressionsFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

    return &ASTFunction{inner: slice}, nil
}
            

func (s *ASTFunction) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ASTFunction) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ASTFunction) Len() uint {
    return s.FieldCount()
}
func (s *ASTFunction) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ASTFunction) CountExtraFields() uint {
    return s.FieldCount() - 2
}

func (s *ASTFunction) HasExtraFields() bool {
    return 2 != s.FieldCount()
}
            

func (s *ASTFunction) Name() *Byte {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return ByteFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ASTFunction) Arguments() *ASTExpressions {
    var ret *ASTExpressions
    start := unpackNumber(s.inner[8:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[12:])
        ret = ASTExpressionsFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = ASTExpressionsFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ASTFunction) AsBuilder() ASTFunctionBuilder {
    ret := NewASTFunctionBuilder().Name(*s.Name()).Arguments(*s.Arguments())
    return *ret
}
        

type ASTVariableBuilder struct {
    name Byte
}
        

func (s *ASTVariableBuilder) Build() ASTVariable {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (1 + 1)
    offsets := make([]uint32, 0, 1)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.name.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.name.AsSlice())
    return ASTVariable{inner: b.Bytes()}
}
                

func (s *ASTVariableBuilder) Name(v Byte) *ASTVariableBuilder {
    s.name = v
    return s
}
            

func NewASTVariableBuilder() *ASTVariableBuilder {
	return &ASTVariableBuilder{ name: ByteDefault() }
}
    

type ASTVariable struct {
    inner []byte
}
        

func ASTVariableFromSliceUnchecked(slice []byte) *ASTVariable {
    return &ASTVariable{inner: slice}
}
func (s *ASTVariable) AsSlice() []byte {
    return s.inner
}
            

func ASTVariableDefault() ASTVariable {
    return *ASTVariableFromSliceUnchecked([]byte{ 9,0,0,0,8,0,0,0,0 })
}
            

func ASTVariableFromSlice(slice []byte, compatible bool) (*ASTVariable, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ASTVariable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ASTVariable", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ASTVariable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ASTVariable", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ASTVariable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 1 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 1 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = ByteFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

    return &ASTVariable{inner: slice}, nil
}
            

func (s *ASTVariable) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ASTVariable) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ASTVariable) Len() uint {
    return s.FieldCount()
}
func (s *ASTVariable) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ASTVariable) CountExtraFields() uint {
    return s.FieldCount() - 1
}

func (s *ASTVariable) HasExtraFields() bool {
    return 1 != s.FieldCount()
}
            

func (s *ASTVariable) Name() *Byte {
    var ret *Byte
    start := unpackNumber(s.inner[4:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[8:])
        ret = ByteFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = ByteFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ASTVariable) AsBuilder() ASTVariableBuilder {
    ret := NewASTVariableBuilder().Name(*s.Name())
    return *ret
}
        

type ASTValueBuilder struct {
    value_type Byte
value Bytes
}
        

func (s *ASTValueBuilder) Build() ASTValue {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (2 + 1)
    offsets := make([]uint32, 0, 2)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.value_type.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.value.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.value_type.AsSlice())
b.Write(s.value.AsSlice())
    return ASTValue{inner: b.Bytes()}
}
                

func (s *ASTValueBuilder) ValueType(v Byte) *ASTValueBuilder {
    s.value_type = v
    return s
}
            

func (s *ASTValueBuilder) Value(v Bytes) *ASTValueBuilder {
    s.value = v
    return s
}
            

func NewASTValueBuilder() *ASTValueBuilder {
	return &ASTValueBuilder{ value_type: ByteDefault(),value: BytesDefault() }
}
    

type ASTValue struct {
    inner []byte
}
        

func ASTValueFromSliceUnchecked(slice []byte) *ASTValue {
    return &ASTValue{inner: slice}
}
func (s *ASTValue) AsSlice() []byte {
    return s.inner
}
            

func ASTValueDefault() ASTValue {
    return *ASTValueFromSliceUnchecked([]byte{ 17,0,0,0,12,0,0,0,13,0,0,0,0,0,0,0,0 })
}
            

func ASTValueFromSlice(slice []byte, compatible bool) (*ASTValue, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ASTValue", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ASTValue", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "ASTValue", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "ASTValue", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "ASTValue", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 2 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 2 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = ByteFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

    return &ASTValue{inner: slice}, nil
}
            

func (s *ASTValue) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *ASTValue) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *ASTValue) Len() uint {
    return s.FieldCount()
}
func (s *ASTValue) IsEmpty() bool {
    return s.Len() == 0
}
func (s *ASTValue) CountExtraFields() uint {
    return s.FieldCount() - 2
}

func (s *ASTValue) HasExtraFields() bool {
    return 2 != s.FieldCount()
}
            

func (s *ASTValue) ValueType() *Byte {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return ByteFromSliceUnchecked(s.inner[start:end])
}
               

func (s *ASTValue) Value() *Bytes {
    var ret *Bytes
    start := unpackNumber(s.inner[8:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[12:])
        ret = BytesFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = BytesFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *ASTValue) AsBuilder() ASTValueBuilder {
    ret := NewASTValueBuilder().ValueType(*s.ValueType()).Value(*s.Value())
    return *ret
}
        

type DeviceKeyBuilder struct {
    main_alg_id Uint8
sub_alg_id Uint8
cid Byte10
pubkey Byte10
}
        

func (s *DeviceKeyBuilder) Build() DeviceKey {
    b := new(bytes.Buffer)
    b.Write(s.main_alg_id.AsSlice())
b.Write(s.sub_alg_id.AsSlice())
b.Write(s.cid.AsSlice())
b.Write(s.pubkey.AsSlice())
    return DeviceKey{inner: b.Bytes()}
}
            

func (s *DeviceKeyBuilder) MainAlgId(v Uint8) *DeviceKeyBuilder {
    s.main_alg_id = v
    return s
}
            

func (s *DeviceKeyBuilder) SubAlgId(v Uint8) *DeviceKeyBuilder {
    s.sub_alg_id = v
    return s
}
            

func (s *DeviceKeyBuilder) Cid(v Byte10) *DeviceKeyBuilder {
    s.cid = v
    return s
}
            

func (s *DeviceKeyBuilder) Pubkey(v Byte10) *DeviceKeyBuilder {
    s.pubkey = v
    return s
}
            

func NewDeviceKeyBuilder() *DeviceKeyBuilder {
	return &DeviceKeyBuilder{ main_alg_id: Uint8Default(),sub_alg_id: Uint8Default(),cid: Byte10Default(),pubkey: Byte10Default() }
}
    

type DeviceKey struct {
    inner []byte
}
        

func DeviceKeyFromSliceUnchecked(slice []byte) *DeviceKey {
    return &DeviceKey{inner: slice}
}
func (s *DeviceKey) AsSlice() []byte {
    return s.inner
}
            

func DeviceKeyDefault() DeviceKey {
    return *DeviceKeyFromSliceUnchecked([]byte{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func DeviceKeyFromSlice(slice []byte, _compatible bool) (*DeviceKey, error) {
    sliceLen := len(slice)
    if sliceLen != 22 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "DeviceKey", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(22)}, " ")
        return nil, errors.New(errMsg)
    }
    return &DeviceKey{inner: slice}, nil
}
        

func (s *DeviceKey) MainAlgId() *Uint8 {
    ret := Uint8FromSliceUnchecked(s.inner[0:1])
    return ret
}
                

func (s *DeviceKey) SubAlgId() *Uint8 {
    ret := Uint8FromSliceUnchecked(s.inner[1:2])
    return ret
}
                

func (s *DeviceKey) Cid() *Byte10 {
    ret := Byte10FromSliceUnchecked(s.inner[2:12])
    return ret
}
                

func (s *DeviceKey) Pubkey() *Byte10 {
    ret := Byte10FromSliceUnchecked(s.inner[12:22])
    return ret
}
                

func (s *DeviceKey) AsBuilder() DeviceKeyBuilder {
    ret := NewDeviceKeyBuilder().MainAlgId(*s.MainAlgId()).SubAlgId(*s.SubAlgId()).Cid(*s.Cid()).Pubkey(*s.Pubkey())
    return *ret
}
        

type DeviceKeyListBuilder struct {
    inner []DeviceKey
}
    

func (s *DeviceKeyListBuilder) Build() DeviceKeyList {
    size := packNumber(Number(len(s.inner)))

    b := new(bytes.Buffer)

    b.Write(size)
    len := len(s.inner)
    for i := 0; i < len; i++ {
        b.Write(s.inner[i].AsSlice())
    }

    sb := DeviceKeyList{inner: b.Bytes()}

    return sb
}
            

func (s *DeviceKeyListBuilder) Set(v []DeviceKey) *DeviceKeyListBuilder {
    s.inner = v
    return s
}
func (s *DeviceKeyListBuilder) Push(v DeviceKey) *DeviceKeyListBuilder {
    s.inner = append(s.inner, v)
    return s
}
func (s *DeviceKeyListBuilder) Extend(iter []DeviceKey) *DeviceKeyListBuilder {
    for i:=0; i < len(iter); i++ {
        s.inner = append(s.inner, iter[i])
    }
    return s
}
func (s *DeviceKeyListBuilder) Replace(index uint, v DeviceKey) *DeviceKey {
    if uint(len(s.inner)) > index {
        a := s.inner[index]
        s.inner[index] = v
        return &a
    }
    return nil
}
    

func NewDeviceKeyListBuilder() *DeviceKeyListBuilder {
	return &DeviceKeyListBuilder{ []DeviceKey{} }
}
        

type DeviceKeyList struct {
    inner []byte
}
        

func DeviceKeyListFromSliceUnchecked(slice []byte) *DeviceKeyList {
    return &DeviceKeyList{inner: slice}
}
func (s *DeviceKeyList) AsSlice() []byte {
    return s.inner
}
            

func DeviceKeyListDefault() DeviceKeyList {
    return *DeviceKeyListFromSliceUnchecked([]byte{ 0,0,0,0 })
}
            

func DeviceKeyListFromSlice(slice []byte, _compatible bool) (*DeviceKeyList, error) {
    sliceLen := len(slice)
    if sliceLen < int(HeaderSizeUint) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "DeviceKeyList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }
    itemCount := unpackNumber(slice)
    if itemCount == 0 {
        if sliceLen != int(HeaderSizeUint) {
            errMsg := strings.Join([]string{"TotalSizeNotMatch", "DeviceKeyList", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(HeaderSizeUint))}, " ")
            return nil, errors.New(errMsg)
        }
        return &DeviceKeyList{inner: slice}, nil
    }
    totalSize := int(HeaderSizeUint) + int(22*itemCount)
    if sliceLen != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "DeviceKeyList", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }
    return &DeviceKeyList{inner: slice}, nil
}
            

func (s *DeviceKeyList) TotalSize() uint {
    return uint(HeaderSizeUint) + 22 * s.ItemCount()
}
func (s *DeviceKeyList) ItemCount() uint {
    number := uint(unpackNumber(s.inner))
    return number
}
func (s *DeviceKeyList) Len() uint {
    return s.ItemCount()
}
func (s *DeviceKeyList) IsEmpty() bool {
    return s.Len() == 0
}
// if *DeviceKey is nil, index is out of bounds
func (s *DeviceKeyList) Get(index uint) *DeviceKey {
    var re *DeviceKey
    if index < s.Len() {
        start := uint(HeaderSizeUint) + 22*index
        end := start + 22
        re = DeviceKeyFromSliceUnchecked(s.inner[start:end])
    }
    return re
}
        

func (s *DeviceKeyList) AsBuilder() DeviceKeyListBuilder {
    size := s.ItemCount()
    t := NewDeviceKeyListBuilder()
    for i:=uint(0); i < size; i++ {
        t.Push(*s.Get(i))
    }
    return *t
}
        

type DeviceKeyListCellDataBuilder struct {
    keys DeviceKeyList
refund_lock Script
}
        

func (s *DeviceKeyListCellDataBuilder) Build() DeviceKeyListCellData {
    b := new(bytes.Buffer)

    totalSize := HeaderSizeUint * (2 + 1)
    offsets := make([]uint32, 0, 2)

    offsets = append(offsets, totalSize)
totalSize += uint32(len(s.keys.AsSlice()))
offsets = append(offsets, totalSize)
totalSize += uint32(len(s.refund_lock.AsSlice()))

    b.Write(packNumber(Number(totalSize)))

    for i := 0; i < len(offsets); i++ {
        b.Write(packNumber(Number(offsets[i])))
    }

    b.Write(s.keys.AsSlice())
b.Write(s.refund_lock.AsSlice())
    return DeviceKeyListCellData{inner: b.Bytes()}
}
                

func (s *DeviceKeyListCellDataBuilder) Keys(v DeviceKeyList) *DeviceKeyListCellDataBuilder {
    s.keys = v
    return s
}
            

func (s *DeviceKeyListCellDataBuilder) RefundLock(v Script) *DeviceKeyListCellDataBuilder {
    s.refund_lock = v
    return s
}
            

func NewDeviceKeyListCellDataBuilder() *DeviceKeyListCellDataBuilder {
	return &DeviceKeyListCellDataBuilder{ keys: DeviceKeyListDefault(),refund_lock: ScriptDefault() }
}
    

type DeviceKeyListCellData struct {
    inner []byte
}
        

func DeviceKeyListCellDataFromSliceUnchecked(slice []byte) *DeviceKeyListCellData {
    return &DeviceKeyListCellData{inner: slice}
}
func (s *DeviceKeyListCellData) AsSlice() []byte {
    return s.inner
}
            

func DeviceKeyListCellDataDefault() DeviceKeyListCellData {
    return *DeviceKeyListCellDataFromSliceUnchecked([]byte{ 69,0,0,0,12,0,0,0,16,0,0,0,0,0,0,0,53,0,0,0,16,0,0,0,48,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 })
}
            

func DeviceKeyListCellDataFromSlice(slice []byte, compatible bool) (*DeviceKeyListCellData, error) {
    sliceLen := len(slice)
    if uint32(sliceLen) < HeaderSizeUint {
        errMsg := strings.Join([]string{"HeaderIsBroken", "DeviceKeyListCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
        return nil, errors.New(errMsg)
    }

    totalSize := unpackNumber(slice)
    if Number(sliceLen) != totalSize {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "DeviceKeyListCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
        return nil, errors.New(errMsg)
    }

    if uint32(sliceLen) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"TotalSizeNotMatch", "DeviceKeyListCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    offsetFirst := unpackNumber(slice[HeaderSizeUint:])
    if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
        errMsg := strings.Join([]string{"OffsetsNotMatch", "DeviceKeyListCellData", strconv.Itoa(int(offsetFirst%4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint*2))}, " ")
        return nil, errors.New(errMsg)
    }

    if sliceLen < int(offsetFirst) {
        errMsg := strings.Join([]string{"HeaderIsBroken", "DeviceKeyListCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
        return nil, errors.New(errMsg)
    }

    fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
    if fieldCount < 2 {
        return nil, errors.New("FieldCountNotMatch")
    } else if !compatible && fieldCount > 2 {
        return nil, errors.New("FieldCountNotMatch")
    }

    offsets := make([]uint32, fieldCount)

    for i := 0; i < int(fieldCount); i++ {
        offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
    }
    offsets = append(offsets, uint32(totalSize))

    for i := 0; i < len(offsets); i++ {
        if i&1 != 0 && offsets[i-1] > offsets[i] {
            return nil, errors.New("OffsetsNotMatch")
        }
    }

    var err error
    
_, err = DeviceKeyListFromSlice(slice[offsets[0]:offsets[1]], compatible)
if err != nil {
    return nil, err
}
                

_, err = ScriptFromSlice(slice[offsets[1]:offsets[2]], compatible)
if err != nil {
    return nil, err
}
                

    return &DeviceKeyListCellData{inner: slice}, nil
}
            

func (s *DeviceKeyListCellData) TotalSize() uint {
    return uint(unpackNumber(s.inner))
}
func (s *DeviceKeyListCellData) FieldCount() uint {
    var number uint = 0
    if uint32(s.TotalSize()) == HeaderSizeUint {
        return number
    }
    number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
    return number
}
func (s *DeviceKeyListCellData) Len() uint {
    return s.FieldCount()
}
func (s *DeviceKeyListCellData) IsEmpty() bool {
    return s.Len() == 0
}
func (s *DeviceKeyListCellData) CountExtraFields() uint {
    return s.FieldCount() - 2
}

func (s *DeviceKeyListCellData) HasExtraFields() bool {
    return 2 != s.FieldCount()
}
            

func (s *DeviceKeyListCellData) Keys() *DeviceKeyList {
    start := unpackNumber(s.inner[4:])
    end := unpackNumber(s.inner[8:])
    return DeviceKeyListFromSliceUnchecked(s.inner[start:end])
}
               

func (s *DeviceKeyListCellData) RefundLock() *Script {
    var ret *Script
    start := unpackNumber(s.inner[8:])
    if s.HasExtraFields() {
        end := unpackNumber(s.inner[12:])
        ret = ScriptFromSliceUnchecked(s.inner[start:end])
    } else {
        ret = ScriptFromSliceUnchecked(s.inner[start:])
    }
    return ret
}
                        

func (s *DeviceKeyListCellData) AsBuilder() DeviceKeyListCellDataBuilder {
    ret := NewDeviceKeyListCellDataBuilder().Keys(*s.Keys()).RefundLock(*s.RefundLock())
    return *ret
}
        
